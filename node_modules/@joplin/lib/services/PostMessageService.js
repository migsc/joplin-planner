"use strict";
// Passing messages across the various sandbox boundaries can be complex and is
// hard to unit test. This class is an attempt to clarify and track what happens
// when messages are sent.
//
// Essentially it works like this:
//
// The component that might post messages, for example from a content script to
// the plugin, and expect responses:
//
// - First it registers a responder with the PostMessageService - this is what
//   will be used to send back responses.
// - Whenever it sends a message it calls PostMessageService.postMessage() and
//   wait for the response
// - This class forwards the message to the relevant participant and wait for the
//   response
// - Then it sends back the response to the component using the registered
//   responder.
//
// There's still quite a bit of boiler plate code on the content script or
// webview side to mask the complexity of passing messages. In particular, it
// needs to create and return a promise when a message is posted. Then in
// another location, when the response is received, it resolves that promise.
// See UserWebviewIndex.js to see how it's done.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponderComponentType = exports.MessageParticipant = void 0;
const Logger_1 = require("../Logger");
const PluginService_1 = require("./plugins/PluginService");
const logger = Logger_1.default.create('PostMessageService');
var MessageParticipant;
(function (MessageParticipant) {
    MessageParticipant["ContentScript"] = "contentScript";
    MessageParticipant["Plugin"] = "plugin";
    MessageParticipant["UserWebview"] = "userWebview";
})(MessageParticipant = exports.MessageParticipant || (exports.MessageParticipant = {}));
var ResponderComponentType;
(function (ResponderComponentType) {
    ResponderComponentType["NoteTextViewer"] = "noteTextViewer";
    ResponderComponentType["UserWebview"] = "userWebview";
})(ResponderComponentType = exports.ResponderComponentType || (exports.ResponderComponentType = {}));
class PostMessageService {
    constructor() {
        this.responders_ = {};
        this.viewMessageHandlers_ = {};
    }
    static instance() {
        if (this.instance_)
            return this.instance_;
        this.instance_ = new PostMessageService();
        return this.instance_;
    }
    postMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            let response = null;
            let error = null;
            if (message.from === MessageParticipant.Plugin && message.to === MessageParticipant.UserWebview) {
                this.viewMessageHandler(message);
                return;
            }
            try {
                if (message.from === MessageParticipant.ContentScript && message.to === MessageParticipant.Plugin) {
                    const pluginId = PluginService_1.default.instance().pluginIdByContentScriptId(message.contentScriptId);
                    if (!pluginId)
                        throw new Error(`Could not find plugin associated with content script "${message.contentScriptId}"`);
                    response = yield PluginService_1.default.instance().pluginById(pluginId).emitContentScriptMessage(message.contentScriptId, message.content);
                }
                else if (message.from === MessageParticipant.UserWebview && message.to === MessageParticipant.Plugin) {
                    response = yield PluginService_1.default.instance().pluginById(message.pluginId).viewController(message.viewId).emitMessage({ message: message.content });
                }
                else {
                    throw new Error(`Unhandled message: ${JSON.stringify(message)}`);
                }
            }
            catch (e) {
                error = e;
            }
            this.sendResponse(message, response, error);
        });
    }
    viewMessageHandler(message) {
        const viewMessageHandler = this.viewMessageHandlers_[[ResponderComponentType.UserWebview, message.viewId].join(':')];
        if (!viewMessageHandler) {
            logger.warn('Cannot receive message because no viewMessageHandler was found', message);
        }
        else {
            viewMessageHandler(message.content);
        }
    }
    sendResponse(message, responseContent, error) {
        let responder = null;
        if (message.from === MessageParticipant.ContentScript) {
            responder = this.responder(ResponderComponentType.NoteTextViewer, message.viewId);
        }
        else if (message.from === MessageParticipant.UserWebview) {
            responder = this.responder(ResponderComponentType.UserWebview, message.viewId);
        }
        if (!responder) {
            logger.warn('Cannot respond to message because no responder was found', message);
        }
        responder({
            responseId: message.id,
            response: responseContent,
            error,
        });
    }
    responder(type, viewId) {
        return this.responders_[[type, viewId].join(':')];
    }
    registerResponder(type, viewId, responder) {
        this.responders_[[type, viewId].join(':')] = responder;
    }
    registerViewMessageHandler(type, viewId, callback) {
        this.viewMessageHandlers_[[type, viewId].join(':')] = callback;
    }
    unregisterViewMessageHandler(type, viewId) {
        delete this.viewMessageHandlers_[[type, viewId].join(':')];
    }
    unregisterResponder(type, viewId) {
        delete this.responders_[[type, viewId].join(':')];
    }
}
exports.default = PostMessageService;
//# sourceMappingURL=PostMessageService.js.map