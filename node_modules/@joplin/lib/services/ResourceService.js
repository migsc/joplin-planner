"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const NoteResource_1 = require("../models/NoteResource");
const BaseModel_1 = require("../BaseModel");
const BaseService_1 = require("./BaseService");
const Setting_1 = require("../models/Setting");
const shim_1 = require("../shim");
const ItemChange_1 = require("../models/ItemChange");
const Note_1 = require("../models/Note");
const Resource_1 = require("../models/Resource");
const SearchEngine_1 = require("./searchengine/SearchEngine");
const ItemChangeUtils_1 = require("./ItemChangeUtils");
const time_1 = require("../time");
const { sprintf } = require('sprintf-js');
class ResourceService extends BaseService_1.default {
    constructor() {
        super(...arguments);
        this.isIndexing_ = false;
        this.maintenanceCalls_ = [];
        this.maintenanceTimer1_ = null;
        this.maintenanceTimer2_ = null;
    }
    indexNoteResources() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger().info('ResourceService::indexNoteResources: Start');
            if (this.isIndexing_) {
                this.logger().info('ResourceService::indexNoteResources: Already indexing - waiting for it to finish');
                yield time_1.default.waitTillCondition(() => !this.isIndexing_);
                return;
            }
            this.isIndexing_ = true;
            try {
                yield ItemChange_1.default.waitForAllSaved();
                let foundNoteWithEncryption = false;
                while (true) {
                    const changes = yield ItemChange_1.default.modelSelectAll(`
					SELECT id, item_id, type
					FROM item_changes
					WHERE item_type = ?
					AND id > ?
					ORDER BY id ASC
					LIMIT 10
					`, [BaseModel_1.default.TYPE_NOTE, Setting_1.default.value('resourceService.lastProcessedChangeId')]);
                    if (!changes.length)
                        break;
                    const noteIds = changes.map((a) => a.item_id);
                    const notes = yield Note_1.default.modelSelectAll(`SELECT id, title, body, encryption_applied FROM notes WHERE id IN ("${noteIds.join('","')}")`);
                    const noteById = (noteId) => {
                        for (let i = 0; i < notes.length; i++) {
                            if (notes[i].id === noteId)
                                return notes[i];
                        }
                        // The note may have been deleted since the change was recorded. For example in this case:
                        // - Note created (Some Change object is recorded)
                        // - Note is deleted
                        // - ResourceService indexer runs.
                        // In that case, there will be a change for the note, but the note will be gone.
                        return null;
                    };
                    for (let i = 0; i < changes.length; i++) {
                        const change = changes[i];
                        if (change.type === ItemChange_1.default.TYPE_CREATE || change.type === ItemChange_1.default.TYPE_UPDATE) {
                            const note = noteById(change.item_id);
                            if (note) {
                                if (note.encryption_applied) {
                                    // If we hit an encrypted note, abort processing for now.
                                    // Note will eventually get decrypted and processing can resume then.
                                    // This is a limitation of the change tracking system - we cannot skip a change
                                    // and keep processing the rest since we only keep track of "lastProcessedChangeId".
                                    foundNoteWithEncryption = true;
                                    break;
                                }
                                yield this.setAssociatedResources(note.id, note.body);
                            }
                            else {
                                this.logger().warn(`ResourceService::indexNoteResources: A change was recorded for a note that has been deleted: ${change.item_id}`);
                            }
                        }
                        else if (change.type === ItemChange_1.default.TYPE_DELETE) {
                            yield NoteResource_1.default.remove(change.item_id);
                        }
                        else {
                            throw new Error(`Invalid change type: ${change.type}`);
                        }
                        Setting_1.default.setValue('resourceService.lastProcessedChangeId', change.id);
                    }
                    if (foundNoteWithEncryption)
                        break;
                }
                yield Setting_1.default.saveAll();
                yield NoteResource_1.default.addOrphanedResources();
                yield ItemChangeUtils_1.default.deleteProcessedChanges();
            }
            catch (error) {
                this.logger().error('ResourceService::indexNoteResources:', error);
            }
            this.isIndexing_ = false;
            this.logger().info('ResourceService::indexNoteResources: Completed');
        });
    }
    setAssociatedResources(noteId, noteBody) {
        return __awaiter(this, void 0, void 0, function* () {
            const resourceIds = yield Note_1.default.linkedResourceIds(noteBody);
            yield NoteResource_1.default.setAssociatedResources(noteId, resourceIds);
        });
    }
    deleteOrphanResources(expiryDelay = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (expiryDelay === null)
                expiryDelay = Setting_1.default.value('revisionService.ttlDays') * 24 * 60 * 60 * 1000;
            const resourceIds = yield NoteResource_1.default.orphanResources(expiryDelay);
            this.logger().info('ResourceService::deleteOrphanResources:', resourceIds);
            for (let i = 0; i < resourceIds.length; i++) {
                const resourceId = resourceIds[i];
                const results = yield SearchEngine_1.default.instance().search(resourceId);
                if (results.length) {
                    const note = yield Note_1.default.load(results[0].id);
                    if (note) {
                        this.logger().info(sprintf('ResourceService::deleteOrphanResources: Skipping deletion of resource %s because it is still referenced in note %s. Re-indexing note content to fix the issue.', resourceId, note.id));
                        yield this.setAssociatedResources(note.id, note.body);
                    }
                }
                else {
                    yield Resource_1.default.delete(resourceId);
                }
            }
        });
    }
    static autoSetFileSize(resourceId, filePath, waitTillExists = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const itDoes = yield shim_1.default.fsDriver().waitTillExists(filePath, waitTillExists ? 10000 : 0);
            if (!itDoes) {
                // this.logger().warn('Trying to set file size on non-existent resource:', resourceId, filePath);
                return;
            }
            const fileStat = yield shim_1.default.fsDriver().stat(filePath);
            yield Resource_1.default.setFileSizeOnly(resourceId, fileStat.size);
        });
    }
    static autoSetFileSizes() {
        return __awaiter(this, void 0, void 0, function* () {
            const resources = yield Resource_1.default.needFileSizeSet();
            for (const r of resources) {
                yield this.autoSetFileSize(r.id, Resource_1.default.fullPath(r), false);
            }
        });
    }
    maintenance() {
        return __awaiter(this, void 0, void 0, function* () {
            this.maintenanceCalls_.push(true);
            try {
                yield this.indexNoteResources();
                yield this.deleteOrphanResources();
            }
            finally {
                this.maintenanceCalls_.pop();
            }
        });
    }
    static runInBackground() {
        if (this.isRunningInBackground_)
            return;
        this.isRunningInBackground_ = true;
        const service = this.instance();
        service.maintenanceTimer1_ = shim_1.default.setTimeout(() => {
            void service.maintenance();
        }, 1000 * 30);
        service.maintenanceTimer2_ = shim_1.default.setInterval(() => {
            void service.maintenance();
        }, 1000 * 60 * 60 * 4);
    }
    cancelTimers() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.maintenanceTimer1_) {
                shim_1.default.clearTimeout(this.maintenanceTimer1_);
                this.maintenanceTimer1_ = null;
            }
            if (this.maintenanceTimer2_) {
                shim_1.default.clearInterval(this.maintenanceTimer2_);
                this.maintenanceTimer2_ = null;
            }
            return new Promise((resolve) => {
                const iid = shim_1.default.setInterval(() => {
                    if (!this.maintenanceCalls_.length) {
                        shim_1.default.clearInterval(iid);
                        resolve(null);
                    }
                }, 100);
            });
        });
    }
    static instance() {
        if (this.instance_)
            return this.instance_;
        this.instance_ = new ResourceService();
        return this.instance_;
    }
}
exports.default = ResourceService;
ResourceService.isRunningInBackground_ = false;
ResourceService.instance_ = null;
//# sourceMappingURL=ResourceService.js.map