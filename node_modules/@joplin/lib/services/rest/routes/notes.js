"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractMediaUrls = void 0;
const Setting_1 = require("../../../models/Setting");
const shim_1 = require("../../../shim");
const uuid_1 = require("../../../uuid");
const readonlyProperties_1 = require("../utils/readonlyProperties");
const defaultSaveOptions_1 = require("../utils/defaultSaveOptions");
const defaultAction_1 = require("../utils/defaultAction");
const BaseModel_1 = require("../../../BaseModel");
const defaultLoadOptions_1 = require("../utils/defaultLoadOptions");
const Api_1 = require("../Api");
const markdownUtils_1 = require("../../../markdownUtils");
const collectionToPaginatedResults_1 = require("../utils/collectionToPaginatedResults");
const registry_1 = require("../../../registry");
const database_1 = require("../../../database");
const Folder_1 = require("../../../models/Folder");
const Note_1 = require("../../../models/Note");
const Tag_1 = require("../../../models/Tag");
const Resource_1 = require("../../../models/Resource");
const htmlUtils_1 = require("../../../htmlUtils");
const markupLanguageUtils_1 = require("../../../markupLanguageUtils");
const mimeUtils = require('../../../mime-utils.js').mime;
const md5 = require('md5');
const HtmlToMd_1 = require("../../../HtmlToMd");
const urlUtils = require('../../../urlUtils.js');
const ArrayUtils = require("../../../ArrayUtils");
const { mimeTypeFromHeaders } = require('../../../net-utils');
const { fileExtension, safeFileExtension, safeFilename, filename } = require('../../../path-utils');
const { fileUriToPath } = require('../../../urlUtils');
const { MarkupToHtml } = require('@joplin/renderer');
const { ErrorNotFound } = require('../utils/errors');
let htmlToMdParser_ = null;
function htmlToMdParser() {
    if (htmlToMdParser_)
        return htmlToMdParser_;
    htmlToMdParser_ = new HtmlToMd_1.default();
    return htmlToMdParser_;
}
function requestNoteToNote(requestNote) {
    return __awaiter(this, void 0, void 0, function* () {
        const output = {
            title: requestNote.title ? requestNote.title : '',
            body: requestNote.body ? requestNote.body : '',
        };
        if (requestNote.id)
            output.id = requestNote.id;
        const baseUrl = requestNote.base_url ? requestNote.base_url : '';
        if (requestNote.body_html) {
            if (requestNote.convert_to === 'html') {
                const style = yield buildNoteStyleSheet(requestNote.stylesheets);
                const minify = require('html-minifier').minify;
                const minifyOptions = {
                    // Remove all spaces and, especially, newlines from tag attributes, as that would
                    // break the rendering.
                    customAttrCollapse: /.*/,
                    // Need to remove all whitespaces because whitespace at a beginning of a line
                    // means a code block in Markdown.
                    collapseWhitespace: true,
                    minifyCSS: true,
                    maxLineLength: 300,
                };
                const uglifycss = require('uglifycss');
                const styleString = uglifycss.processString(style.join('\n'), {
                    // Need to set a max length because Ace Editor takes forever
                    // to display notes with long lines.
                    maxLineLen: 200,
                });
                const styleTag = style.length ? `<style>${styleString}</style>` + '\n' : '';
                let minifiedHtml = '';
                try {
                    minifiedHtml = minify(requestNote.body_html, minifyOptions);
                }
                catch (error) {
                    console.warn('Could not minify HTML - using non-minified HTML instead', error);
                    minifiedHtml = requestNote.body_html;
                }
                output.body = styleTag + minifiedHtml;
                output.body = htmlUtils_1.default.prependBaseUrl(output.body, baseUrl);
                output.markup_language = MarkupToHtml.MARKUP_LANGUAGE_HTML;
            }
            else {
                // Convert to Markdown
                // Parsing will not work if the HTML is not wrapped in a top level tag, which is not guaranteed
                // when getting the content from elsewhere. So here wrap it - it won't change anything to the final
                // rendering but it makes sure everything will be parsed.
                output.body = yield htmlToMdParser().parse(`<div>${requestNote.body_html}</div>`, {
                    baseUrl: baseUrl,
                    anchorNames: requestNote.anchor_names ? requestNote.anchor_names : [],
                    convertEmbeddedPdfsToLinks: true,
                });
                output.markup_language = MarkupToHtml.MARKUP_LANGUAGE_MARKDOWN;
            }
        }
        if (requestNote.parent_id) {
            output.parent_id = requestNote.parent_id;
        }
        else {
            const folder = yield Folder_1.default.defaultFolder();
            if (!folder)
                throw new Error('Cannot find folder for note');
            output.parent_id = folder.id;
        }
        if ('source_url' in requestNote)
            output.source_url = requestNote.source_url;
        if ('author' in requestNote)
            output.author = requestNote.author;
        if ('user_updated_time' in requestNote)
            output.user_updated_time = database_1.default.formatValue(database_1.default.TYPE_INT, requestNote.user_updated_time);
        if ('user_created_time' in requestNote)
            output.user_created_time = database_1.default.formatValue(database_1.default.TYPE_INT, requestNote.user_created_time);
        if ('is_todo' in requestNote)
            output.is_todo = database_1.default.formatValue(database_1.default.TYPE_INT, requestNote.is_todo);
        if ('markup_language' in requestNote)
            output.markup_language = database_1.default.formatValue(database_1.default.TYPE_INT, requestNote.markup_language);
        if ('longitude' in requestNote)
            output.longitude = requestNote.longitude;
        if ('latitude' in requestNote)
            output.latitude = requestNote.latitude;
        if ('altitude' in requestNote)
            output.altitude = requestNote.altitude;
        if (!output.markup_language)
            output.markup_language = MarkupToHtml.MARKUP_LANGUAGE_MARKDOWN;
        return output;
    });
}
function buildNoteStyleSheet(stylesheets) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!stylesheets)
            return [];
        const output = [];
        for (const stylesheet of stylesheets) {
            if (stylesheet.type === 'text') {
                output.push(stylesheet.value);
            }
            else if (stylesheet.type === 'url') {
                try {
                    const tempPath = `${Setting_1.default.value('tempDir')}/${md5(`${Math.random()}_${Date.now()}`)}.css`;
                    yield shim_1.default.fetchBlob(stylesheet.value, { path: tempPath, maxRetry: 1 });
                    const text = yield shim_1.default.fsDriver().readFile(tempPath);
                    output.push(text);
                    yield shim_1.default.fsDriver().remove(tempPath);
                }
                catch (error) {
                    registry_1.reg.logger().warn(`Cannot download stylesheet at ${stylesheet.value}`, error);
                }
            }
            else {
                throw new Error(`Invalid stylesheet type: ${stylesheet.type}`);
            }
        }
        return output;
    });
}
function tryToGuessExtFromMimeType(response, mediaPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const mimeType = mimeTypeFromHeaders(response.headers);
        if (!mimeType)
            return mediaPath;
        const newExt = mimeUtils.toFileExtension(mimeType);
        if (!newExt)
            return mediaPath;
        const newMediaPath = `${mediaPath}.${newExt}`;
        yield shim_1.default.fsDriver().move(mediaPath, newMediaPath);
        return newMediaPath;
    });
}
function downloadMediaFile(url /* , allowFileProtocolImages */) {
    return __awaiter(this, void 0, void 0, function* () {
        const tempDir = Setting_1.default.value('tempDir');
        // The URL we get to download have been extracted from the Markdown document
        url = markdownUtils_1.default.unescapeLinkUrl(url);
        const isDataUrl = url && url.toLowerCase().indexOf('data:') === 0;
        // PDFs and other heavy resoucres are often served as seperate files insted of data urls, its very unlikely to encounter a pdf as a data url
        if (isDataUrl && !url.toLowerCase().startsWith('data:image/')) {
            registry_1.reg.logger().warn(`Resources in data URL format is only supported for images ${url}`);
            return '';
        }
        const name = isDataUrl ? md5(`${Math.random()}_${Date.now()}`) : filename(url);
        let fileExt = isDataUrl ? mimeUtils.toFileExtension(mimeUtils.fromDataUrl(url)) : safeFileExtension(fileExtension(url).toLowerCase());
        if (!mimeUtils.fromFileExtension(fileExt))
            fileExt = ''; // If the file extension is unknown - clear it.
        if (fileExt)
            fileExt = `.${fileExt}`;
        // Append a UUID because simply checking if the file exists is not enough since
        // multiple resources can be downloaded at the same time (race condition).
        let mediaPath = `${tempDir}/${safeFilename(name)}_${uuid_1.default.create()}${fileExt}`;
        try {
            if (isDataUrl) {
                yield shim_1.default.imageFromDataUrl(url, mediaPath);
            }
            else if (urlUtils.urlProtocol(url).toLowerCase() === 'file:') {
                // Can't think of any reason to disallow this at this point
                // if (!allowFileProtocolImages) throw new Error('For security reasons, this URL with file:// protocol cannot be downloaded');
                const localPath = fileUriToPath(url);
                yield shim_1.default.fsDriver().copy(localPath, mediaPath);
            }
            else {
                const response = yield shim_1.default.fetchBlob(url, { path: mediaPath, maxRetry: 1 });
                // If we could not find the file extension from the URL, try to get it
                // now based on the Content-Type header.
                if (!fileExt)
                    mediaPath = yield tryToGuessExtFromMimeType(response, mediaPath);
            }
            return mediaPath;
        }
        catch (error) {
            registry_1.reg.logger().warn(`Cannot download image at ${url}`, error);
            return '';
        }
    });
}
function downloadMediaFiles(urls /* , allowFileProtocolImages:boolean */) {
    return __awaiter(this, void 0, void 0, function* () {
        const PromisePool = require('es6-promise-pool');
        const output = {};
        const downloadOne = (url) => __awaiter(this, void 0, void 0, function* () {
            const mediaPath = yield downloadMediaFile(url); // , allowFileProtocolImages);
            if (mediaPath)
                output[url] = { path: mediaPath, originalUrl: url };
        });
        let urlIndex = 0;
        const promiseProducer = () => {
            if (urlIndex >= urls.length)
                return null;
            const url = urls[urlIndex++];
            return downloadOne(url);
        };
        const concurrency = 10;
        const pool = new PromisePool(promiseProducer, concurrency);
        yield pool.start();
        return output;
    });
}
function createResourcesFromPaths(urls) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const url in urls) {
            if (!urls.hasOwnProperty(url))
                continue;
            const urlInfo = urls[url];
            try {
                const resource = yield shim_1.default.createResourceFromPath(urlInfo.path);
                urlInfo.resource = resource;
            }
            catch (error) {
                registry_1.reg.logger().warn(`Cannot create resource for ${url}`, error);
            }
        }
        return urls;
    });
}
function removeTempFiles(urls) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const url in urls) {
            if (!urls.hasOwnProperty(url))
                continue;
            const urlInfo = urls[url];
            try {
                yield shim_1.default.fsDriver().remove(urlInfo.path);
            }
            catch (error) {
                registry_1.reg.logger().warn(`Cannot remove ${urlInfo.path}`, error);
            }
        }
    });
}
function replaceUrlsByResources(markupLanguage, md, urls, imageSizes) {
    const imageSizesIndexes = {};
    if (markupLanguage === MarkupToHtml.MARKUP_LANGUAGE_HTML) {
        return htmlUtils_1.default.replaceMediaUrls(md, (url) => {
            const urlInfo = urls[url];
            if (!urlInfo || !urlInfo.resource)
                return url;
            return Resource_1.default.internalUrl(urlInfo.resource);
        });
    }
    else {
        // eslint-disable-next-line no-useless-escape
        return md.replace(/(!?\[.*?\]\()([^\s\)]+)(.*?\))/g, (_match, before, url, after) => {
            let type = 'link';
            if (before.startsWith('[embedded_pdf]')) {
                type = 'pdf';
            }
            else if (before.startsWith('![')) {
                type = 'image';
            }
            const urlInfo = urls[url];
            if (type === 'link' || !urlInfo || !urlInfo.resource)
                return before + url + after;
            const resourceUrl = Resource_1.default.internalUrl(urlInfo.resource);
            if (type === 'pdf') {
                return `[${markdownUtils_1.default.escapeLinkUrl(url)}](${resourceUrl}${after}`;
            }
            if (!(urlInfo.originalUrl in imageSizesIndexes))
                imageSizesIndexes[urlInfo.originalUrl] = 0;
            const imageSizesCollection = imageSizes[urlInfo.originalUrl];
            if (!imageSizesCollection) {
                // Either its not an image or we don't know the size of the image
                // In some cases, we won't find the image size information for that particular image URL. Normally
                // it will only happen when using the "Clip simplified page" feature, which can modify the
                // image URLs (for example it will select a smaller size resolution). In that case, it's
                // fine to return the image as-is because it has already good dimensions.
                return before + resourceUrl + after;
            }
            const imageSize = imageSizesCollection[imageSizesIndexes[urlInfo.originalUrl]];
            imageSizesIndexes[urlInfo.originalUrl]++;
            if (imageSize && (imageSize.naturalWidth !== imageSize.width || imageSize.naturalHeight !== imageSize.height)) {
                return `<img width="${imageSize.width}" height="${imageSize.height}" src="${resourceUrl}"/>`;
            }
            else {
                return before + resourceUrl + after;
            }
        });
    }
}
function extractMediaUrls(markupLanguage, text) {
    const urls = [];
    urls.push(...ArrayUtils.unique(markupLanguageUtils_1.default.extractImageUrls(markupLanguage, text)));
    urls.push(...ArrayUtils.unique(markupLanguageUtils_1.default.extractPdfUrls(markupLanguage, text)));
    return urls;
}
exports.extractMediaUrls = extractMediaUrls;
// Note must have been saved first
function attachImageFromDataUrl(note, imageDataUrl, cropRect) {
    return __awaiter(this, void 0, void 0, function* () {
        const tempDir = Setting_1.default.value('tempDir');
        const mime = mimeUtils.fromDataUrl(imageDataUrl);
        let ext = mimeUtils.toFileExtension(mime) || '';
        if (ext)
            ext = `.${ext}`;
        const tempFilePath = `${tempDir}/${md5(`${Math.random()}_${Date.now()}`)}${ext}`;
        const imageConvOptions = {};
        if (cropRect)
            imageConvOptions.cropRect = cropRect;
        yield shim_1.default.imageFromDataUrl(imageDataUrl, tempFilePath, imageConvOptions);
        return yield shim_1.default.attachFileToNote(note, tempFilePath);
    });
}
function default_1(request, id = null, link = null) {
    return __awaiter(this, void 0, void 0, function* () {
        if (request.method === 'GET') {
            if (link && link === 'tags') {
                return (0, collectionToPaginatedResults_1.default)(BaseModel_1.ModelType.Tag, yield Tag_1.default.tagsByNoteId(id), request);
            }
            else if (link && link === 'resources') {
                const note = yield Note_1.default.load(id);
                if (!note)
                    throw new ErrorNotFound();
                const resourceIds = yield Note_1.default.linkedResourceIds(note.body);
                const output = [];
                const loadOptions = (0, defaultLoadOptions_1.default)(request, BaseModel_1.default.TYPE_RESOURCE);
                for (const resourceId of resourceIds) {
                    output.push(yield Resource_1.default.load(resourceId, loadOptions));
                }
                return (0, collectionToPaginatedResults_1.default)(BaseModel_1.ModelType.Resource, output, request);
            }
            else if (link) {
                throw new ErrorNotFound();
            }
            return (0, defaultAction_1.default)(BaseModel_1.default.TYPE_NOTE, request, id, link);
        }
        if (request.method === Api_1.RequestMethod.POST) {
            const requestId = Date.now();
            const requestNote = JSON.parse(request.body);
            // const allowFileProtocolImages = urlUtils.urlProtocol(requestNote.base_url).toLowerCase() === 'file:';
            const imageSizes = requestNote.image_sizes ? requestNote.image_sizes : {};
            let note = yield requestNoteToNote(requestNote);
            const mediaUrls = extractMediaUrls(note.markup_language, note.body);
            registry_1.reg.logger().info(`Request (${requestId}): Downloading media files: ${mediaUrls.length}`);
            let result = yield downloadMediaFiles(mediaUrls); // , allowFileProtocolImages);
            registry_1.reg.logger().info(`Request (${requestId}): Creating resources from paths: ${Object.getOwnPropertyNames(result).length}`);
            result = yield createResourcesFromPaths(result);
            yield removeTempFiles(result);
            note.body = replaceUrlsByResources(note.markup_language, note.body, result, imageSizes);
            registry_1.reg.logger().info(`Request (${requestId}): Saving note...`);
            const saveOptions = (0, defaultSaveOptions_1.default)('POST', note.id);
            saveOptions.autoTimestamp = false; // No auto-timestamp because user may have provided them
            const timestamp = Date.now();
            note.updated_time = timestamp;
            note.created_time = timestamp;
            if (!('user_updated_time' in note))
                note.user_updated_time = timestamp;
            if (!('user_created_time' in note))
                note.user_created_time = timestamp;
            note = yield Note_1.default.save(note, saveOptions);
            if (requestNote.tags) {
                const tagTitles = requestNote.tags.split(',');
                yield Tag_1.default.setNoteTagsByTitles(note.id, tagTitles);
            }
            if (requestNote.image_data_url) {
                note = yield attachImageFromDataUrl(note, requestNote.image_data_url, requestNote.crop_rect);
            }
            registry_1.reg.logger().info(`Request (${requestId}): Created note ${note.id}`);
            return note;
        }
        if (request.method === 'PUT') {
            const note = yield Note_1.default.load(id);
            if (!note)
                throw new ErrorNotFound();
            const saveOptions = Object.assign(Object.assign({}, (0, defaultSaveOptions_1.default)('PUT', note.id)), { autoTimestamp: false, userSideValidation: true });
            const timestamp = Date.now();
            const newProps = request.bodyJson((0, readonlyProperties_1.default)('PUT'));
            if (!('user_updated_time' in newProps))
                newProps.user_updated_time = timestamp;
            let newNote = Object.assign(Object.assign(Object.assign({}, note), newProps), { updated_time: timestamp });
            newNote = yield Note_1.default.save(newNote, saveOptions);
            const requestNote = JSON.parse(request.body);
            if (requestNote.tags || requestNote.tags === '') {
                const tagTitles = requestNote.tags.split(',');
                yield Tag_1.default.setNoteTagsByTitles(id, tagTitles);
            }
            return newNote;
        }
        return (0, defaultAction_1.default)(BaseModel_1.default.TYPE_NOTE, request, id, link);
    });
}
exports.default = default_1;
//# sourceMappingURL=notes.js.map