"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseModel_1 = require("../../../BaseModel");
const ItemChange_1 = require("../../../models/ItemChange");
const Note_1 = require("../../../models/Note");
const test_utils_1 = require("../../../testing/test-utils");
const Api_1 = require("../Api");
let api = null;
describe('routes/events', function () {
    beforeEach((done) => __awaiter(this, void 0, void 0, function* () {
        api = new Api_1.default();
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.switchClient)(1);
        done();
    }));
    it('should retrieve the latest events', () => __awaiter(this, void 0, void 0, function* () {
        let cursor = '0';
        {
            const response = yield api.route(Api_1.RequestMethod.GET, 'events', { cursor });
            expect(response.cursor).toBe('0');
        }
        const note1 = yield Note_1.default.save({ title: 'toto' });
        yield Note_1.default.save({ id: note1.id, title: 'tutu' });
        const note2 = yield Note_1.default.save({ title: 'tata' });
        yield ItemChange_1.default.waitForAllSaved();
        {
            const response = yield api.route(Api_1.RequestMethod.GET, 'events', { cursor });
            expect(response.cursor).toBe('3');
            expect(response.items.length).toBe(2);
            expect(response.has_more).toBe(false);
            expect(response.items.map((it) => it.item_id).sort()).toEqual([note1.id, note2.id].sort());
            cursor = response.cursor;
        }
        {
            const response = yield api.route(Api_1.RequestMethod.GET, 'events', { cursor });
            expect(response.cursor).toBe(cursor);
            expect(response.items.length).toBe(0);
            expect(response.has_more).toBe(false);
        }
        yield Note_1.default.save({ id: note2.id, title: 'titi' });
        yield ItemChange_1.default.waitForAllSaved();
        {
            const response = yield api.route(Api_1.RequestMethod.GET, 'events', { cursor });
            expect(response.cursor).toBe('4');
            expect(response.items.length).toBe(1);
            expect(response.items[0].item_id).toBe(note2.id);
        }
    }));
    it('should limit the number of response items', () => __awaiter(this, void 0, void 0, function* () {
        const promises = [];
        for (let i = 0; i < 101; i++) {
            promises.push(Note_1.default.save({ title: 'toto' }));
        }
        yield Promise.all(promises);
        yield ItemChange_1.default.waitForAllSaved();
        const response1 = yield api.route(Api_1.RequestMethod.GET, 'events', { cursor: '0' });
        expect(response1.items.length).toBe(100);
        expect(response1.has_more).toBe(true);
        const response2 = yield api.route(Api_1.RequestMethod.GET, 'events', { cursor: response1.cursor });
        expect(response2.items.length).toBe(1);
        expect(response2.has_more).toBe(false);
    }));
    it('should retrieve a single item', () => __awaiter(this, void 0, void 0, function* () {
        const beforeTime = Date.now();
        const note = yield Note_1.default.save({ title: 'toto' });
        yield ItemChange_1.default.waitForAllSaved();
        const response = yield api.route(Api_1.RequestMethod.GET, 'events/1');
        expect(response.item_type).toBe(BaseModel_1.ModelType.Note);
        expect(response.type).toBe(1);
        expect(response.item_id).toBe(note.id);
        expect(response.created_time).toBeGreaterThanOrEqual(beforeTime);
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return api.route(Api_1.RequestMethod.GET, 'events/1234'); }));
    }));
});
//# sourceMappingURL=events.test.js.map