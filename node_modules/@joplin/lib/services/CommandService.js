"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = void 0;
const eventManager_1 = require("../eventManager");
const BaseService_1 = require("./BaseService");
const shim_1 = require("../shim");
const WhenClause_1 = require("./WhenClause");
exports.utils = {
    store: {
        dispatch: () => { },
        getState: () => { },
    },
};
class CommandService extends BaseService_1.default {
    constructor() {
        super(...arguments);
        this.commands_ = {};
    }
    static instance() {
        if (this.instance_)
            return this.instance_;
        this.instance_ = new CommandService();
        return this.instance_;
    }
    initialize(store, devMode, stateToWhenClauseContext) {
        exports.utils.store = store;
        this.store_ = store;
        this.devMode_ = devMode;
        this.stateToWhenClauseContext_ = stateToWhenClauseContext;
    }
    on(eventName, callback) {
        eventManager_1.default.on(eventName, callback);
    }
    off(eventName, callback) {
        eventManager_1.default.off(eventName, callback);
    }
    searchCommands(query, returnAllWhenEmpty, excludeWithoutLabel = true) {
        query = query.toLowerCase();
        const output = [];
        const whenClauseContext = this.currentWhenClauseContext();
        for (const commandName of this.commandNames()) {
            const label = this.label(commandName, true);
            if (!label && excludeWithoutLabel)
                continue;
            if (!this.isEnabled(commandName, whenClauseContext))
                continue;
            const title = label ? `${label} (${commandName})` : commandName;
            if ((returnAllWhenEmpty && !query) || title.toLowerCase().includes(query)) {
                output.push({
                    commandName: commandName,
                    title: title,
                });
            }
        }
        output.sort((a, b) => {
            return a.title.toLowerCase() < b.title.toLowerCase() ? -1 : +1;
        });
        return output;
    }
    commandNames(publicOnly = false) {
        if (publicOnly) {
            const output = [];
            for (const name in this.commands_) {
                if (!this.isPublic(name))
                    continue;
                output.push(name);
            }
            return output;
        }
        else {
            return Object.keys(this.commands_);
        }
    }
    commandByName(name, options = null) {
        options = Object.assign({ mustExist: true, runtimeMustBeRegistered: false }, options);
        const command = this.commands_[name];
        if (!command) {
            if (options.mustExist)
                throw new Error(`Command not found: ${name}. Make sure the declaration has been registered.`);
            return null;
        }
        if (options.runtimeMustBeRegistered && !command.runtime)
            throw new Error(`Runtime is not registered for command ${name}`);
        return command;
    }
    registerDeclaration(declaration) {
        declaration = Object.assign({}, declaration);
        if (!declaration.label)
            declaration.label = '';
        if (!declaration.iconName)
            declaration.iconName = '';
        this.commands_[declaration.name] = {
            declaration: declaration,
        };
    }
    registerRuntime(commandName, runtime) {
        if (typeof commandName !== 'string')
            throw new Error(`Command name must be a string. Got: ${JSON.stringify(commandName)}`);
        const command = this.commandByName(commandName);
        runtime = Object.assign({}, runtime);
        if (!runtime.enabledCondition)
            runtime.enabledCondition = 'true';
        command.runtime = runtime;
    }
    registerCommands(commands) {
        for (const command of commands) {
            CommandService.instance().registerRuntime(command.declaration.name, command.runtime());
        }
    }
    unregisterCommands(commands) {
        for (const command of commands) {
            CommandService.instance().unregisterRuntime(command.declaration.name);
        }
    }
    componentRegisterCommands(component, commands) {
        for (const command of commands) {
            CommandService.instance().registerRuntime(command.declaration.name, command.runtime(component));
        }
    }
    componentUnregisterCommands(commands) {
        for (const command of commands) {
            CommandService.instance().unregisterRuntime(command.declaration.name);
        }
    }
    unregisterRuntime(commandName) {
        const command = this.commandByName(commandName, { mustExist: false });
        if (!command || !command.runtime)
            return;
        delete command.runtime;
    }
    createContext() {
        return {
            state: this.store_.getState(),
            dispatch: (action) => {
                this.store_.dispatch(action);
            },
        };
    }
    execute(commandName, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            const command = this.commandByName(commandName);
            // Some commands such as "showModalMessage" can be executed many
            // times per seconds, so we should only display this message in
            // debug mode.
            if (commandName !== 'showModalMessage')
                this.logger().debug('CommandService::execute:', commandName, args);
            if (!command.runtime)
                throw new Error(`Cannot execute a command without a runtime: ${commandName}`);
            return command.runtime.execute(this.createContext(), ...args);
        });
    }
    scheduleExecute(commandName, args) {
        shim_1.default.setTimeout(() => {
            void this.execute(commandName, args);
        }, 10);
    }
    currentWhenClauseContext() {
        return this.stateToWhenClauseContext_(this.store_.getState());
    }
    isPublic(commandName) {
        return !!this.label(commandName);
    }
    // When looping on commands and checking their enabled state, the whenClauseContext
    // should be specified (created using currentWhenClauseContext) to avoid having
    // to re-create it on each call.
    isEnabled(commandName, whenClauseContext = null) {
        const command = this.commandByName(commandName);
        if (!command || !command.runtime)
            return false;
        if (!whenClauseContext)
            whenClauseContext = this.currentWhenClauseContext();
        const exp = new WhenClause_1.default(command.runtime.enabledCondition, this.devMode_);
        return exp.evaluate(whenClauseContext);
    }
    // The title is dynamic and derived from the state, which is why the state is passed
    // as an argument. Title can be used for example to display the alarm date on the
    // "set alarm" toolbar button.
    title(commandName, state = null) {
        const command = this.commandByName(commandName);
        if (!command || !command.runtime)
            return null;
        state = state || this.store_.getState();
        if (command.runtime.mapStateToTitle) {
            return command.runtime.mapStateToTitle(state);
        }
        else {
            return '';
        }
    }
    iconName(commandName, variant = null) {
        const command = this.commandByName(commandName);
        if (!command)
            throw new Error(`No such command: ${commandName}`);
        if (variant === 'tinymce')
            return command.declaration.tinymceIconName ? command.declaration.tinymceIconName : 'preferences';
        return command.declaration.iconName;
    }
    label(commandName, fullLabel = false) {
        const command = this.commandByName(commandName);
        if (!command)
            throw new Error(`Command: ${commandName} is not declared`);
        const output = [];
        const parentLabel = (d) => {
            if (!d.parentLabel)
                return '';
            if (typeof d.parentLabel === 'function')
                return d.parentLabel();
            return d.parentLabel;
        };
        if (fullLabel && parentLabel(command.declaration))
            output.push(parentLabel(command.declaration));
        output.push(typeof command.declaration.label === 'function' ? command.declaration.label() : command.declaration.label);
        return output.join(': ');
    }
    description(commandName) {
        const command = this.commandByName(commandName);
        if (command.declaration.description)
            return command.declaration.description;
        return this.label(commandName, true);
    }
    exists(commandName) {
        const command = this.commandByName(commandName, { mustExist: false });
        return !!command;
    }
}
exports.default = CommandService;
//# sourceMappingURL=CommandService.js.map