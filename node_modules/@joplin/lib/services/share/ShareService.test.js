"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Note_1 = require("../../models/Note");
const test_utils_1 = require("../../testing/test-utils");
const ShareService_1 = require("./ShareService");
const reducer_1 = require("../../reducer");
const redux_1 = require("redux");
const Folder_1 = require("../../models/Folder");
const syncInfoUtils_1 = require("../synchronizer/syncInfoUtils");
const ppk_1 = require("../e2ee/ppk");
const MasterKey_1 = require("../../models/MasterKey");
const utils_1 = require("../e2ee/utils");
const Logger_1 = require("../../Logger");
const shim_1 = require("../../shim");
const Resource_1 = require("../../models/Resource");
const fs_extra_1 = require("fs-extra");
const BaseItem_1 = require("../../models/BaseItem");
const testImagePath = `${test_utils_1.supportDir}/photo.jpg`;
const testReducer = (state = reducer_1.defaultState, action) => {
    return (0, reducer_1.default)(state, action);
};
function mockService(api) {
    const service = new ShareService_1.default();
    const store = (0, redux_1.createStore)(testReducer);
    service.initialize(store, (0, test_utils_1.encryptionService)(), api);
    return service;
}
describe('ShareService', function () {
    beforeEach((done) => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.switchClient)(1);
        done();
    }));
    it('should not change the note user timestamps when sharing or unsharing', () => __awaiter(this, void 0, void 0, function* () {
        let note = yield Note_1.default.save({});
        const service = mockService({
            exec: (method, path = '', _query = null, _body = null, _headers = null, _options = null) => {
                if (method === 'GET' && path === 'api/shares')
                    return { items: [] };
                return null;
            },
            personalizedUserContentBaseUrl(_userId) {
            },
        });
        yield (0, test_utils_1.msleep)(1);
        yield service.shareNote(note.id, false);
        function checkTimestamps(previousNote, newNote) {
            // After sharing or unsharing, only the updated_time property should
            // be updated, for sync purposes. All other timestamps shouldn't
            // change.
            expect(previousNote.user_created_time).toBe(newNote.user_created_time);
            expect(previousNote.user_updated_time).toBe(newNote.user_updated_time);
            expect(previousNote.updated_time < newNote.updated_time).toBe(true);
            expect(previousNote.created_time).toBe(newNote.created_time);
        }
        {
            const noteReloaded = yield Note_1.default.load(note.id);
            checkTimestamps(note, noteReloaded);
            note = noteReloaded;
        }
        yield (0, test_utils_1.msleep)(1);
        yield service.unshareNote(note.id);
        {
            const noteReloaded = yield Note_1.default.load(note.id);
            checkTimestamps(note, noteReloaded);
        }
    }));
    function testShareFolderService(extraExecHandlers = {}, options = {}) {
        return mockService({
            exec: (method, path, query, body) => __awaiter(this, void 0, void 0, function* () {
                if (extraExecHandlers[`${method} ${path}`])
                    return extraExecHandlers[`${method} ${path}`](query, body);
                if (method === 'GET' && path === 'api/shares') {
                    return {
                        items: [
                            {
                                id: 'share_1',
                                master_key_id: options.master_key_id,
                            },
                        ],
                    };
                }
                if (method === 'POST' && path === 'api/shares') {
                    return {
                        id: 'share_1',
                    };
                }
                throw new Error(`Unhandled: ${method} ${path}`);
            }),
        });
    }
    function testShareFolder(service) {
        return __awaiter(this, void 0, void 0, function* () {
            const folder = yield Folder_1.default.save({});
            let note = yield Note_1.default.save({ parent_id: folder.id });
            note = yield shim_1.default.attachFileToNote(note, testImagePath);
            const resourceId = (yield Note_1.default.linkedResourceIds(note.body))[0];
            const resource = yield Resource_1.default.load(resourceId);
            yield (0, test_utils_1.resourceService)().indexNoteResources();
            const share = yield service.shareFolder(folder.id);
            expect(share.id).toBe('share_1');
            expect((yield Folder_1.default.load(folder.id)).share_id).toBe('share_1');
            expect((yield Note_1.default.load(note.id)).share_id).toBe('share_1');
            expect((yield Resource_1.default.load(resource.id)).share_id).toBe('share_1');
            return { share, folder, note, resource };
        });
    }
    it('should share a folder', () => __awaiter(this, void 0, void 0, function* () {
        yield testShareFolder(testShareFolderService());
    }));
    it('should share a folder - E2EE', () => __awaiter(this, void 0, void 0, function* () {
        const masterKey = yield (0, test_utils_1.loadEncryptionMasterKey)();
        yield (0, utils_1.setupAndEnableEncryption)((0, test_utils_1.encryptionService)(), masterKey, '111111');
        const ppk = yield (0, ppk_1.generateKeyPair)((0, test_utils_1.encryptionService)(), '111111');
        (0, syncInfoUtils_1.setPpk)(ppk);
        let shareService = testShareFolderService();
        expect(yield MasterKey_1.default.count()).toBe(1);
        let { folder, note, resource } = yield testShareFolder(shareService);
        yield Folder_1.default.updateAllShareIds((0, test_utils_1.resourceService)());
        // The share service should automatically create a new encryption key
        // specifically for that shared folder
        expect(yield MasterKey_1.default.count()).toBe(2);
        folder = yield Folder_1.default.load(folder.id);
        note = yield Note_1.default.load(note.id);
        resource = yield Resource_1.default.load(resource.id);
        // The key that is not the master key is the folder key
        const folderKey = (yield MasterKey_1.default.all()).find(mk => mk.id !== masterKey.id);
        // Double-check that it's going to encrypt the folder using the shared
        // key (and not the user's own master key)
        expect(folderKey.id).not.toBe(masterKey.id);
        expect(folder.master_key_id).toBe(folderKey.id);
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        // Reload the service so that the mocked calls use the newly created key
        shareService = testShareFolderService({}, { master_key_id: folderKey.id });
        BaseItem_1.default.shareService_ = shareService;
        Resource_1.default.shareService_ = shareService;
        try {
            const serializedNote = yield Note_1.default.serializeForSync(note);
            expect(serializedNote).toContain(folderKey.id);
            // The resource should be encrypted using the above key (if it is,
            // the key ID will be in the header).
            const result = yield Resource_1.default.fullPathForSyncUpload(resource);
            const content = yield (0, fs_extra_1.readFile)(result.path, 'utf8');
            expect(content).toContain(folderKey.id);
        }
        finally {
            BaseItem_1.default.shareService_ = shareService;
            Resource_1.default.shareService_ = null;
        }
    }));
    it('should add a recipient', () => __awaiter(this, void 0, void 0, function* () {
        (0, syncInfoUtils_1.setEncryptionEnabled)(true);
        yield (0, utils_1.updateMasterPassword)('', '111111');
        const ppk = yield (0, ppk_1.generateKeyPair)((0, test_utils_1.encryptionService)(), '111111');
        (0, syncInfoUtils_1.setPpk)(ppk);
        const recipientPpk = yield (0, ppk_1.generateKeyPair)((0, test_utils_1.encryptionService)(), '222222');
        expect(ppk.id).not.toBe(recipientPpk.id);
        let uploadedEmail = '';
        let uploadedMasterKey = null;
        const service = testShareFolderService({
            'POST api/shares': (_query, body) => {
                return {
                    id: 'share_1',
                    master_key_id: body.master_key_id,
                };
            },
            'GET api/users/toto%40example.com/public_key': (_query, _body) => __awaiter(this, void 0, void 0, function* () {
                return recipientPpk;
            }),
            'POST api/shares/share_1/users': (_query, body) => __awaiter(this, void 0, void 0, function* () {
                uploadedEmail = body.email;
                uploadedMasterKey = JSON.parse(body.master_key);
            }),
        });
        const { share } = yield testShareFolder(service);
        yield service.addShareRecipient(share.id, share.master_key_id, 'toto@example.com');
        expect(uploadedEmail).toBe('toto@example.com');
        const content = JSON.parse(uploadedMasterKey.content);
        expect(content.ppkId).toBe(recipientPpk.id);
    }));
    it('should leave folders that are no longer with the user', () => __awaiter(this, void 0, void 0, function* () {
        // `checkShareConsistency` will emit a warning so we need to silent it
        // in tests.
        const previousLogLevel = Logger_1.default.globalLogger.setLevel(Logger_1.LogLevel.Error);
        const service = testShareFolderService({
            'GET api/shares': (_query, _body) => __awaiter(this, void 0, void 0, function* () {
                return {
                    items: [],
                    has_more: false,
                };
            }),
        });
        const folder = yield Folder_1.default.save({ share_id: 'nolongershared' });
        yield service.checkShareConsistency();
        expect(yield Folder_1.default.load(folder.id)).toBeFalsy();
        Logger_1.default.globalLogger.setLevel(previousLogLevel);
    }));
});
//# sourceMappingURL=ShareService.test.js.map