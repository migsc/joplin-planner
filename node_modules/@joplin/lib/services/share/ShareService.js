"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const JoplinServerApi_1 = require("../../JoplinServerApi");
const locale_1 = require("../../locale");
const Logger_1 = require("../../Logger");
const Folder_1 = require("../../models/Folder");
const MasterKey_1 = require("../../models/MasterKey");
const Note_1 = require("../../models/Note");
const Setting_1 = require("../../models/Setting");
const ppk_1 = require("../e2ee/ppk");
const utils_1 = require("../e2ee/utils");
const ResourceService_1 = require("../ResourceService");
const syncInfoUtils_1 = require("../synchronizer/syncInfoUtils");
const reducer_1 = require("./reducer");
const logger = Logger_1.default.create('ShareService');
function formatShareInvitations(invitations) {
    return invitations.map(inv => {
        return Object.assign(Object.assign({}, inv), { master_key: inv.master_key ? JSON.parse(inv.master_key) : null });
    });
}
class ShareService {
    constructor() {
        this.api_ = null;
        this.store_ = null;
        this.encryptionService_ = null;
        this.initialized_ = false;
    }
    static instance() {
        if (this.instance_)
            return this.instance_;
        this.instance_ = new ShareService();
        return this.instance_;
    }
    initialize(store, encryptionService, api = null) {
        this.initialized_ = true;
        this.store_ = store;
        this.encryptionService_ = encryptionService;
        this.api_ = api;
    }
    get enabled() {
        if (!this.initialized_)
            return false;
        return [9, 10].includes(Setting_1.default.value('sync.target')); // Joplin Server, Joplin Cloud targets
    }
    get store() {
        return this.store_;
    }
    get state() {
        return this.store.getState()[reducer_1.stateRootKey];
    }
    get userId() {
        return this.api() ? this.api().userId : '';
    }
    api() {
        if (this.api_)
            return this.api_;
        const syncTargetId = Setting_1.default.value('sync.target');
        this.api_ = new JoplinServerApi_1.default({
            baseUrl: () => Setting_1.default.value(`sync.${syncTargetId}.path`),
            userContentBaseUrl: () => Setting_1.default.value(`sync.${syncTargetId}.userContentPath`),
            username: () => Setting_1.default.value(`sync.${syncTargetId}.username`),
            password: () => Setting_1.default.value(`sync.${syncTargetId}.password`),
        });
        return this.api_;
    }
    shareFolder(folderId) {
        return __awaiter(this, void 0, void 0, function* () {
            const folder = yield Folder_1.default.load(folderId);
            if (!folder)
                throw new Error(`No such folder: ${folderId}`);
            let folderMasterKey = null;
            if ((0, syncInfoUtils_1.getEncryptionEnabled)()) {
                const syncInfo = (0, syncInfoUtils_1.localSyncInfo)();
                // Shouldn't happen
                if (!syncInfo.ppk)
                    throw new Error('Cannot share notebook because E2EE is enabled and no Public Private Key pair exists.');
                // TODO: handle "undefinedMasterPassword" error - show master password dialog
                folderMasterKey = yield this.encryptionService_.generateMasterKey((0, utils_1.getMasterPassword)());
                folderMasterKey = yield MasterKey_1.default.save(folderMasterKey);
                (0, syncInfoUtils_1.addMasterKey)(syncInfo, folderMasterKey);
            }
            const newFolderProps = {};
            if (folder.parent_id)
                newFolderProps.parent_id = '';
            if (folderMasterKey)
                newFolderProps.master_key_id = folderMasterKey.id;
            if (Object.keys(newFolderProps).length) {
                yield Folder_1.default.save(Object.assign({ id: folder.id }, newFolderProps));
            }
            const share = yield this.api().exec('POST', 'api/shares', {}, {
                folder_id: folderId,
                master_key_id: folderMasterKey ? folderMasterKey.id : '',
            });
            // Note: race condition if the share is created but the app crashes
            // before setting share_id on the folder. See unshareFolder() for info.
            yield Folder_1.default.save({ id: folder.id, share_id: share.id });
            yield Folder_1.default.updateAllShareIds(ResourceService_1.default.instance());
            return share;
        });
    }
    // This allows the notebook owner to stop sharing it. For a recipient to
    // leave the shared notebook, see the leaveSharedFolder command.
    unshareFolder(folderId) {
        return __awaiter(this, void 0, void 0, function* () {
            const folder = yield Folder_1.default.load(folderId);
            if (!folder)
                throw new Error(`No such folder: ${folderId}`);
            const share = this.shares.find(s => s.folder_id === folderId);
            if (!share)
                throw new Error(`No share for folder: ${folderId}`);
            // First, delete the share - which in turns is going to remove the items
            // for all users, except the owner.
            yield this.deleteShare(share.id);
            // Then reset the "share_id" field for the folder and all sub-items.
            // This could potentially be done server-side, when deleting the share,
            // but since clients are normally responsible for maintaining the
            // share_id property, we do it here for consistency. It will also avoid
            // conflicts because changes will come only from the clients.
            //
            // Note that there could be a race condition here if the share is
            // deleted, but the app crashes just before setting share_id to "". It's
            // very unlikely to happen so we leave like this for now.
            //
            // We could potentially have a clean up process at some point:
            //
            // - It would download all share objects
            // - Then look for all items where the share_id is not in any of these
            //   shares objects
            // - And set those to ""
            //
            // Likewise, it could apply the share_id to folders based on
            // share.folder_id
            //
            // Setting the share_id is not critical - what matters is that when the
            // share is deleted, other users no longer have access to the item, so
            // can't change or read them.
            yield Folder_1.default.save({ id: folder.id, share_id: '' });
            // It's ok if updateAllShareIds() doesn't run because it's executed on
            // each sync too.
            yield Folder_1.default.updateAllShareIds(ResourceService_1.default.instance());
        });
    }
    // This is when a share recipient decides to leave the shared folder.
    //
    // In that case, we should only delete the folder but none of its children.
    // Deleting the folder tells the server that we want to leave the share. The
    // server will then proceed to delete all associated user_items. So
    // eventually all the notebook content will also be deleted for the current
    // user.
    //
    // We don't delete the children here because that would delete them for the
    // other share participants too.
    //
    // If `folderShareUserId` is provided, the function will check that the user
    // does not own the share. It would be an error to leave such a folder
    // (instead "unshareFolder" should be called).
    leaveSharedFolder(folderId, folderShareUserId = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (folderShareUserId !== null) {
                const userId = Setting_1.default.value('sync.userId');
                if (folderShareUserId === userId)
                    throw new Error('Cannot leave own notebook');
            }
            yield Folder_1.default.delete(folderId, { deleteChildren: false });
        });
    }
    // Finds any folder that is associated with a share, but the user no longer
    // has access to the share, and remove these folders. This check is
    // necessary otherwise sync will try to update items that are not longer
    // accessible and will throw the error "Could not find share with ID: xxxx")
    checkShareConsistency() {
        return __awaiter(this, void 0, void 0, function* () {
            const rootSharedFolders = yield Folder_1.default.rootSharedFolders();
            let hasRefreshedShares = false;
            let shares = this.shares;
            for (const folder of rootSharedFolders) {
                let share = shares.find(s => s.id === folder.share_id);
                if (!share && !hasRefreshedShares) {
                    shares = yield this.refreshShares();
                    share = shares.find(s => s.id === folder.share_id);
                    hasRefreshedShares = true;
                }
                if (!share) {
                    // This folder is a associated with a share, but the user no
                    // longer has access to this share. It can happen for two
                    // reasons:
                    //
                    // - It no longer exists
                    // - Or the user rejected that share from a different device,
                    //   and the folder was not deleted as it should have been.
                    //
                    // In that case we need to leave the notebook.
                    logger.warn(`Found a folder that was associated with a share, but the user not longer has access to the share - leaving the folder. Folder: ${folder.title} (${folder.id}). Share: ${folder.share_id}`);
                    yield this.leaveSharedFolder(folder.id);
                }
            }
        });
    }
    shareNote(noteId, recursive) {
        return __awaiter(this, void 0, void 0, function* () {
            const note = yield Note_1.default.load(noteId);
            if (!note)
                throw new Error(`No such note: ${noteId}`);
            const share = yield this.api().exec('POST', 'api/shares', {}, {
                note_id: noteId,
                recursive: recursive ? 1 : 0,
            });
            yield Note_1.default.save({
                id: note.id,
                parent_id: note.parent_id,
                is_shared: 1,
                updated_time: Date.now(),
            }, {
                autoTimestamp: false,
            });
            return share;
        });
    }
    unshareNote(noteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const note = yield Note_1.default.load(noteId);
            if (!note)
                throw new Error(`No such note: ${noteId}`);
            const shares = yield this.refreshShares();
            const noteShares = shares.filter(s => s.note_id === noteId);
            const promises = [];
            for (const share of noteShares) {
                promises.push(this.deleteShare(share.id));
            }
            yield Promise.all(promises);
            yield Note_1.default.save({
                id: note.id,
                parent_id: note.parent_id,
                is_shared: 0,
                updated_time: Date.now(),
            }, {
                autoTimestamp: false,
            });
        });
    }
    shareUrl(userId, share) {
        return `${this.api().personalizedUserContentBaseUrl(userId)}/shares/${share.id}`;
    }
    folderShare(folderId) {
        return this.shares.find(s => s.folder_id === folderId);
    }
    isSharedFolderOwner(folderId, userId = null) {
        if (userId === null)
            userId = this.userId;
        const share = this.folderShare(folderId);
        if (!share)
            throw new Error(`Cannot find share associated with folder: ${folderId}`);
        return share.user.id === userId;
    }
    get shares() {
        return this.state.shares;
    }
    get shareLinkNoteIds() {
        return this.shares.filter(s => !!s.note_id).map(s => s.note_id);
    }
    get shareInvitations() {
        return this.state.shareInvitations;
    }
    userPublicKey(userEmail) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.api().exec('GET', `api/users/${encodeURIComponent(userEmail)}/public_key`);
        });
    }
    addShareRecipient(shareId, masterKeyId, recipientEmail) {
        return __awaiter(this, void 0, void 0, function* () {
            let recipientMasterKey = null;
            if ((0, syncInfoUtils_1.getEncryptionEnabled)()) {
                const syncInfo = (0, syncInfoUtils_1.localSyncInfo)();
                const masterKey = syncInfo.masterKeys.find(m => m.id === masterKeyId);
                if (!masterKey)
                    throw new Error(`Cannot find master key with ID "${masterKeyId}"`);
                const recipientPublicKey = yield this.userPublicKey(recipientEmail);
                if (!recipientPublicKey)
                    throw new Error((0, locale_1._)('Cannot share encrypted notebook with recipient %s because they have not enabled end-to-end encryption. They may do so from the screen Configuration > Encryption.', recipientEmail));
                logger.info('Reencrypting master key with recipient public key', recipientPublicKey);
                recipientMasterKey = yield (0, ppk_1.mkReencryptFromPasswordToPublicKey)(this.encryptionService_, masterKey, (0, utils_1.getMasterPassword)(), recipientPublicKey);
            }
            return this.api().exec('POST', `api/shares/${shareId}/users`, {}, {
                email: recipientEmail,
                master_key: JSON.stringify(recipientMasterKey),
            });
        });
    }
    deleteShareRecipient(shareUserId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.api().exec('DELETE', `api/share_users/${shareUserId}`);
        });
    }
    deleteShare(shareId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.api().exec('DELETE', `api/shares/${shareId}`);
        });
    }
    loadShares() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.api().exec('GET', 'api/shares');
        });
    }
    loadShareUsers(shareId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.api().exec('GET', `api/shares/${shareId}/users`);
        });
    }
    loadShareInvitations() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.api().exec('GET', 'api/share_users');
        });
    }
    setProcessingShareInvitationResponse(v) {
        this.store.dispatch({
            type: 'SHARE_INVITATION_RESPONSE_PROCESSING',
            value: v,
        });
    }
    respondInvitation(shareUserId, masterKey, accept) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info('respondInvitation: ', shareUserId, accept);
            if (accept) {
                if (masterKey) {
                    const reencryptedMasterKey = yield (0, ppk_1.mkReencryptFromPublicKeyToPassword)(this.encryptionService_, masterKey, (0, syncInfoUtils_1.localSyncInfo)().ppk, (0, utils_1.getMasterPassword)(), (0, utils_1.getMasterPassword)());
                    logger.info('respondInvitation: Key has been reencrypted using master password', reencryptedMasterKey);
                    yield MasterKey_1.default.save(reencryptedMasterKey);
                }
                yield this.api().exec('PATCH', `api/share_users/${shareUserId}`, null, { status: 1 });
            }
            else {
                yield this.api().exec('PATCH', `api/share_users/${shareUserId}`, null, { status: 2 });
            }
        });
    }
    refreshShareInvitations() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.loadShareInvitations();
            const invitations = formatShareInvitations(result.items);
            logger.info('Refresh share invitations:', invitations);
            this.store.dispatch({
                type: 'SHARE_INVITATION_SET',
                shareInvitations: invitations,
            });
        });
    }
    shareById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const stateShare = this.state.shares.find(s => s.id === id);
            if (stateShare)
                return stateShare;
            const refreshedShares = yield this.refreshShares();
            const refreshedShare = refreshedShares.find(s => s.id === id);
            if (!refreshedShare)
                throw new Error(`Could not find share with ID: ${id}`);
            return refreshedShare;
        });
    }
    // In most cases the share objects will already be part of the state, so
    // this function checks there first. If the required share objects are not
    // present, it refreshes them from the API.
    sharesByIds(ids) {
        return __awaiter(this, void 0, void 0, function* () {
            const buildOutput = (shares) => __awaiter(this, void 0, void 0, function* () {
                const output = {};
                for (const share of shares) {
                    if (ids.includes(share.id))
                        output[share.id] = share;
                }
                return output;
            });
            let output = yield buildOutput(this.state.shares);
            if (Object.keys(output).length === ids.length)
                return output;
            const refreshedShares = yield this.refreshShares();
            output = yield buildOutput(refreshedShares);
            if (Object.keys(output).length !== ids.length) {
                logger.error('sharesByIds: Need:', ids);
                logger.error('sharesByIds: Got:', Object.keys(refreshedShares));
                throw new Error('Could not retrieve required share objects');
            }
            return output;
        });
    }
    refreshShares() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.loadShares();
            logger.info('Refreshed shares:', result);
            this.store.dispatch({
                type: 'SHARE_SET',
                shares: result.items,
            });
            return result.items;
        });
    }
    refreshShareUsers(shareId) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.loadShareUsers(shareId);
            logger.info('Refreshed share users:', result);
            this.store.dispatch({
                type: 'SHARE_USER_SET',
                shareId: shareId,
                shareUsers: result.items,
            });
        });
    }
    updateNoLongerSharedItems() {
        return __awaiter(this, void 0, void 0, function* () {
            const shareIds = this.shares.map(share => share.id).concat(this.shareInvitations.map(si => si.share.id));
            yield Folder_1.default.updateNoLongerSharedItems(shareIds);
        });
    }
    maintenance() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.enabled) {
                let hasError = false;
                try {
                    yield this.refreshShareInvitations();
                    yield this.refreshShares();
                    Setting_1.default.setValue('sync.userId', this.api().userId);
                }
                catch (error) {
                    hasError = true;
                    logger.error('Failed to run maintenance:', error);
                }
                // If there was no errors, it means we have all the share objects,
                // so we can run the clean up function.
                if (!hasError)
                    yield this.updateNoLongerSharedItems();
            }
        });
    }
}
exports.default = ShareService;
//# sourceMappingURL=ShareService.js.map