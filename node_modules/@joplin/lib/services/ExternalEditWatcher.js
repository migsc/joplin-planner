"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = require("../Logger");
const Setting_1 = require("../models/Setting");
const shim_1 = require("../shim");
const path_utils_1 = require("../path-utils");
const time_1 = require("../time");
const Note_1 = require("../models/Note");
const utils_1 = require("./ExternalEditWatcher/utils");
const EventEmitter = require('events');
const chokidar = require('chokidar');
const { ErrorNotFound } = require('./rest/utils/errors');
class ExternalEditWatcher {
    constructor() {
        this.logger_ = new Logger_1.default();
        this.watcher_ = null;
        this.eventEmitter_ = new EventEmitter();
        this.skipNextChangeEvent_ = {};
        this.chokidar_ = chokidar;
    }
    static instance() {
        if (this.instance_)
            return this.instance_;
        this.instance_ = new ExternalEditWatcher();
        return this.instance_;
    }
    initialize(bridge, dispatch) {
        this.bridge_ = bridge;
        this.dispatch = dispatch;
    }
    externalApi() {
        const loadNote = (noteId) => __awaiter(this, void 0, void 0, function* () {
            const note = yield Note_1.default.load(noteId);
            if (!note)
                throw new ErrorNotFound(`No such note: ${noteId}`);
            return note;
        });
        return {
            openAndWatch: (args) => __awaiter(this, void 0, void 0, function* () {
                const note = yield loadNote(args.noteId);
                return this.openAndWatch(note);
            }),
            stopWatching: (args) => __awaiter(this, void 0, void 0, function* () {
                return this.stopWatching(args.noteId);
            }),
            noteIsWatched: (args) => __awaiter(this, void 0, void 0, function* () {
                const note = yield loadNote(args.noteId);
                return this.noteIsWatched(note);
            }),
        };
    }
    tempDir() {
        return Setting_1.default.value('profileDir');
    }
    on(eventName, callback) {
        return this.eventEmitter_.on(eventName, callback);
    }
    off(eventName, callback) {
        return this.eventEmitter_.removeListener(eventName, callback);
    }
    setLogger(l) {
        this.logger_ = l;
    }
    logger() {
        return this.logger_;
    }
    watch(fileToWatch) {
        if (!this.chokidar_)
            return;
        if (!this.watcher_) {
            this.watcher_ = this.chokidar_.watch(fileToWatch, {
                useFsEvents: false,
            });
            this.watcher_.on('all', (event, path) => __awaiter(this, void 0, void 0, function* () {
                this.logger().debug(`ExternalEditWatcher: Event: ${event}: ${path}`);
                if (event === 'unlink') {
                    // File are unwatched in the stopWatching functions below. When we receive an unlink event
                    // here it might be that the file is quickly moved to a different location and replaced by
                    // another file with the same name, as it happens with emacs. So because of this
                    // we keep watching anyway.
                    // See: https://github.com/laurent22/joplin/issues/710#issuecomment-420997167
                    // this.watcher_.unwatch(path);
                }
                else if (event === 'change') {
                    const id = this.noteFilePathToId_(path);
                    if (!this.skipNextChangeEvent_[id]) {
                        const note = yield Note_1.default.load(id);
                        if (!note) {
                            this.logger().warn(`ExternalEditWatcher: Watched note has been deleted: ${id}`);
                            void this.stopWatching(id);
                            return;
                        }
                        let noteContent = yield shim_1.default.fsDriver().readFile(path, 'utf-8');
                        // In some very rare cases, the "change" event is going to be emitted but the file will be empty.
                        // This is likely to be the editor that first clears the file, then writes the content to it, so if
                        // the file content is read very quickly after the change event, we'll get empty content.
                        // Usually, re-reading the content again will fix the issue and give back the file content.
                        // To replicate on Windows: associate Typora as external editor, and leave Ctrl+S pressed -
                        // it will keep on saving very fast and the bug should happen at some point.
                        // Below we re-read the file multiple times until we get the content, but in my tests it always
                        // work in the first try anyway. The loop is just for extra safety.
                        // https://github.com/laurent22/joplin/issues/1854
                        if (!noteContent) {
                            this.logger().warn(`ExternalEditWatcher: Watched note is empty - this is likely to be a bug and re-reading the note should fix it. Trying again... ${id}`);
                            for (let i = 0; i < 10; i++) {
                                noteContent = yield shim_1.default.fsDriver().readFile(path, 'utf-8');
                                if (noteContent) {
                                    this.logger().info(`ExternalEditWatcher: Note is now readable: ${id}`);
                                    break;
                                }
                                yield time_1.default.msleep(100);
                            }
                            if (!noteContent)
                                this.logger().warn(`ExternalEditWatcher: Could not re-read note - user might have purposely deleted note content: ${id}`);
                        }
                        this.logger().debug('ExternalEditWatcher: Updating note object.');
                        const updatedNote = yield Note_1.default.unserializeForEdit(noteContent);
                        updatedNote.id = id;
                        updatedNote.parent_id = note.parent_id;
                        yield Note_1.default.save(updatedNote);
                        this.eventEmitter_.emit('noteChange', { id: updatedNote.id, note: updatedNote });
                    }
                    else {
                        this.logger().debug('ExternalEditWatcher: Skipping this event.');
                    }
                    this.skipNextChangeEvent_ = {};
                }
                else if (event === 'error') {
                    this.logger().error('ExternalEditWatcher: error');
                }
            }));
            // Hack to support external watcher on some linux applications (gedit, gvim, etc)
            // taken from https://github.com/paulmillr/chokidar/issues/591
            this.watcher_.on('raw', (event, _path, options) => __awaiter(this, void 0, void 0, function* () {
                const watchedPath = options.watchedPath;
                this.logger().debug(`ExternalEditWatcher: Raw event: ${event}: ${watchedPath}`);
                if (event === 'rename') {
                    this.watcher_.unwatch(watchedPath);
                    this.watcher_.add(watchedPath);
                }
            }));
        }
        else {
            this.watcher_.add(fileToWatch);
        }
        return this.watcher_;
    }
    noteIdToFilePath_(noteId) {
        return `${this.tempDir()}/edit-${noteId}.md`;
    }
    noteFilePathToId_(path) {
        let id = (0, path_utils_1.toSystemSlashes)(path, 'linux').split('/');
        if (!id.length)
            throw new Error(`Invalid path: ${path}`);
        id = id[id.length - 1];
        id = id.split('.');
        id.pop();
        id = id[0].split('-');
        return id[1];
    }
    watchedFiles() {
        if (!this.watcher_)
            return [];
        const output = [];
        const watchedPaths = this.watcher_.getWatched();
        for (const dirName in watchedPaths) {
            if (!watchedPaths.hasOwnProperty(dirName))
                continue;
            for (let i = 0; i < watchedPaths[dirName].length; i++) {
                const f = watchedPaths[dirName][i];
                output.push(`${this.tempDir()}/${f}`);
            }
        }
        return output;
    }
    noteIsWatched(note) {
        if (!this.watcher_)
            return false;
        const noteFilename = (0, path_utils_1.basename)(this.noteIdToFilePath_(note.id));
        const watchedPaths = this.watcher_.getWatched();
        for (const dirName in watchedPaths) {
            if (!watchedPaths.hasOwnProperty(dirName))
                continue;
            for (let i = 0; i < watchedPaths[dirName].length; i++) {
                const f = watchedPaths[dirName][i];
                if (f === noteFilename)
                    return true;
            }
        }
        return false;
    }
    openAndWatch(note) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!note || !note.id) {
                this.logger().warn('ExternalEditWatcher: Cannot open note: ', note);
                return;
            }
            const filePath = yield this.writeNoteToFile_(note);
            if (!filePath)
                return;
            this.watch(filePath);
            yield (0, utils_1.openFileWithExternalEditor)(filePath, this.bridge_());
            this.dispatch({
                type: 'NOTE_FILE_WATCHER_ADD',
                id: note.id,
            });
            this.logger().info(`ExternalEditWatcher: Started watching ${filePath}`);
        });
    }
    stopWatching(noteId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!noteId)
                return;
            const filePath = this.noteIdToFilePath_(noteId);
            if (this.watcher_)
                this.watcher_.unwatch(filePath);
            yield shim_1.default.fsDriver().remove(filePath);
            this.dispatch({
                type: 'NOTE_FILE_WATCHER_REMOVE',
                id: noteId,
            });
            this.logger().info(`ExternalEditWatcher: Stopped watching ${filePath}`);
        });
    }
    stopWatchingAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const filePaths = this.watchedFiles();
            for (let i = 0; i < filePaths.length; i++) {
                yield shim_1.default.fsDriver().remove(filePaths[i]);
            }
            if (this.watcher_)
                this.watcher_.close();
            this.watcher_ = null;
            this.logger().info('ExternalEditWatcher: Stopped watching all files');
            this.dispatch({
                type: 'NOTE_FILE_WATCHER_CLEAR',
            });
        });
    }
    updateNoteFile(note) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.noteIsWatched(note))
                return;
            if (!note || !note.id) {
                this.logger().warn('ExternalEditWatcher: Cannot update note file: ', note);
                return;
            }
            this.logger().debug(`ExternalEditWatcher: Update note file: ${note.id}`);
            // When the note file is updated programmatically, we skip the next change event to
            // avoid update loops. We only want to listen to file changes made by the user.
            this.skipNextChangeEvent_[note.id] = true;
            yield this.writeNoteToFile_(note);
        });
    }
    writeNoteToFile_(note) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!note || !note.id) {
                this.logger().warn('ExternalEditWatcher: Cannot update note file: ', note);
                return null;
            }
            const filePath = this.noteIdToFilePath_(note.id);
            const noteContent = yield Note_1.default.serializeForEdit(note);
            yield shim_1.default.fsDriver().writeFile(filePath, noteContent, 'utf-8');
            return filePath;
        });
    }
}
exports.default = ExternalEditWatcher;
//# sourceMappingURL=ExternalEditWatcher.js.map