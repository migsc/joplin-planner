"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseModel_1 = require("../../BaseModel");
const Logger_1 = require("../../Logger");
const BaseItem_1 = require("../../models/BaseItem");
const logger = Logger_1.default.create('ItemUploader');
class ItemUploader {
    constructor(api, apiCall) {
        this.preUploadedItems_ = {};
        this.preUploadedItemUpdatedTimes_ = {};
        this.maxBatchSize_ = 1 * 1024 * 1024; // 1MB;
        this.api_ = api;
        this.apiCall_ = apiCall;
    }
    get maxBatchSize() {
        return this.maxBatchSize_;
    }
    set maxBatchSize(v) {
        this.maxBatchSize_ = v;
    }
    serializeAndUploadItem(ItemClass, path, local) {
        return __awaiter(this, void 0, void 0, function* () {
            const preUploadItem = this.preUploadedItems_[path];
            if (preUploadItem) {
                if (this.preUploadedItemUpdatedTimes_[path] !== local.updated_time) {
                    // Normally this should be rare as it can only happen if the
                    // item has been changed between the moment it was pre-uploaded
                    // and the moment where it's being processed by the
                    // synchronizer. It could happen for example for a note being
                    // edited just at the same time. In that case, we proceed with
                    // the regular upload.
                    logger.warn(`Pre-uploaded item updated_time has changed. It is going to be re-uploaded again: ${path} (From ${this.preUploadedItemUpdatedTimes_[path]} to ${local.updated_time})`);
                }
                else {
                    if (preUploadItem.error)
                        throw new Error(preUploadItem.error.message ? preUploadItem.error.message : 'Unknown pre-upload error');
                    return;
                }
            }
            const content = yield ItemClass.serializeForSync(local);
            yield this.apiCall_('put', path, content);
        });
    }
    preUploadItems(items) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.api_.supportsMultiPut)
                return;
            const itemsToUpload = [];
            for (const local of items) {
                // For resources, additional logic is necessary - in particular the blob
                // should be uploaded before the metadata, so we can't batch process.
                if (local.type_ === BaseModel_1.ModelType.Resource)
                    continue;
                const ItemClass = BaseItem_1.default.itemClass(local);
                itemsToUpload.push({
                    name: BaseItem_1.default.systemPath(local),
                    body: yield ItemClass.serializeForSync(local),
                    localItemUpdatedTime: local.updated_time,
                });
            }
            let batchSize = 0;
            let currentBatch = [];
            const uploadBatch = (batch) => __awaiter(this, void 0, void 0, function* () {
                for (const batchItem of batch) {
                    this.preUploadedItemUpdatedTimes_[batchItem.name] = batchItem.localItemUpdatedTime;
                }
                const response = yield this.apiCall_('multiPut', batch);
                this.preUploadedItems_ = Object.assign(Object.assign({}, this.preUploadedItems_), response.items);
            });
            while (itemsToUpload.length) {
                const itemToUpload = itemsToUpload.pop();
                const itemSize = itemToUpload.name.length + itemToUpload.body.length;
                // Although it should be rare, if the item itself is above the
                // batch max size, we skip it. In that case it will be uploaded the
                // regular way when the synchronizer calls `serializeAndUploadItem()`
                if (itemSize > this.maxBatchSize)
                    continue;
                if (batchSize + itemSize > this.maxBatchSize) {
                    yield uploadBatch(currentBatch);
                    batchSize = itemSize;
                    currentBatch = [itemToUpload];
                }
                else {
                    batchSize += itemSize;
                    currentBatch.push(itemToUpload);
                }
            }
            if (currentBatch.length)
                yield uploadBatch(currentBatch);
        });
    }
}
exports.default = ItemUploader;
//# sourceMappingURL=ItemUploader.js.map