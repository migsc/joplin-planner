"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const test_utils_1 = require("../../testing/test-utils");
const MasterKey_1 = require("../../models/MasterKey");
const syncInfoUtils_1 = require("./syncInfoUtils");
describe('syncInfoUtils', function () {
    beforeEach((done) => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.switchClient)(1);
        done();
    }));
    afterAll(() => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.afterAllCleanUp)();
    }));
    it('should enable or disable a master key', () => __awaiter(this, void 0, void 0, function* () {
        const mk1 = yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey('111111'));
        const mk2 = yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey('111111'));
        (0, syncInfoUtils_1.setMasterKeyEnabled)(mk2.id, false);
        expect((0, syncInfoUtils_1.masterKeyEnabled)(yield MasterKey_1.default.load(mk1.id))).toBe(true);
        expect((0, syncInfoUtils_1.masterKeyEnabled)(yield MasterKey_1.default.load(mk2.id))).toBe(false);
        (0, syncInfoUtils_1.setMasterKeyEnabled)(mk1.id, false);
        expect((0, syncInfoUtils_1.masterKeyEnabled)(yield MasterKey_1.default.load(mk1.id))).toBe(false);
        expect((0, syncInfoUtils_1.masterKeyEnabled)(yield MasterKey_1.default.load(mk2.id))).toBe(false);
        (0, syncInfoUtils_1.setMasterKeyEnabled)(mk1.id, true);
        expect((0, syncInfoUtils_1.masterKeyEnabled)(yield MasterKey_1.default.load(mk1.id))).toBe(true);
        expect((0, syncInfoUtils_1.masterKeyEnabled)(yield MasterKey_1.default.load(mk2.id))).toBe(false);
    }));
    it('should tell if two sync info are equal', () => __awaiter(this, void 0, void 0, function* () {
        {
            const syncInfo1 = new syncInfoUtils_1.SyncInfo();
            const syncInfo2 = new syncInfoUtils_1.SyncInfo();
            expect((0, syncInfoUtils_1.syncInfoEquals)(syncInfo1, syncInfo2)).toBe(true);
        }
        {
            const syncInfo1 = new syncInfoUtils_1.SyncInfo();
            syncInfo1.masterKeys = [{
                    id: 'id',
                    content: 'content',
                }];
            const syncInfo2 = new syncInfoUtils_1.SyncInfo();
            syncInfo2.masterKeys = [{
                    id: 'id',
                    content: 'different',
                }];
            expect((0, syncInfoUtils_1.syncInfoEquals)(syncInfo1, syncInfo2)).toBe(false);
        }
        {
            const syncInfo1 = new syncInfoUtils_1.SyncInfo();
            syncInfo1.masterKeys = [{
                    id: 'id',
                    content: 'content',
                }];
            const syncInfo2 = new syncInfoUtils_1.SyncInfo();
            syncInfo2.masterKeys = [{
                    id: 'id',
                    content: 'content',
                }];
            expect((0, syncInfoUtils_1.syncInfoEquals)(syncInfo1, syncInfo2)).toBe(true);
        }
        {
            // Should disregard object key order
            const syncInfo1 = new syncInfoUtils_1.SyncInfo();
            syncInfo1.masterKeys = [{
                    content: 'content',
                    id: 'id',
                }];
            const syncInfo2 = new syncInfoUtils_1.SyncInfo();
            syncInfo2.masterKeys = [{
                    id: 'id',
                    content: 'content',
                }];
            expect((0, syncInfoUtils_1.syncInfoEquals)(syncInfo1, syncInfo2)).toBe(true);
        }
    }));
    it('should merge sync target info and takes into account usage of master key - 1', () => __awaiter(this, void 0, void 0, function* () {
        const syncInfo1 = new syncInfoUtils_1.SyncInfo();
        syncInfo1.masterKeys = [{
                id: '1',
                content: 'content1',
                hasBeenUsed: true,
            }];
        syncInfo1.activeMasterKeyId = '1';
        yield (0, test_utils_1.msleep)(1);
        const syncInfo2 = new syncInfoUtils_1.SyncInfo();
        syncInfo2.masterKeys = [{
                id: '2',
                content: 'content2',
                hasBeenUsed: false,
            }];
        syncInfo2.activeMasterKeyId = '2';
        // If one master key has been used and the other not, it should select
        // the one that's been used regardless of timestamps.
        expect((0, syncInfoUtils_1.mergeSyncInfos)(syncInfo1, syncInfo2).activeMasterKeyId).toBe('1');
        // If both master keys have been used it should rely on timestamp
        // (latest modified is picked).
        syncInfo2.masterKeys[0].hasBeenUsed = true;
        expect((0, syncInfoUtils_1.mergeSyncInfos)(syncInfo1, syncInfo2).activeMasterKeyId).toBe('2');
    }));
});
//# sourceMappingURL=syncInfoUtils.test.js.map