"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const time_1 = require("../../time");
const shim_1 = require("../../shim");
const Setting_1 = require("../../models/Setting");
const test_utils_1 = require("../../testing/test-utils");
const Folder_1 = require("../../models/Folder");
const Note_1 = require("../../models/Note");
const Resource_1 = require("../../models/Resource");
const ResourceFetcher_1 = require("../../services/ResourceFetcher");
const MasterKey_1 = require("../../models/MasterKey");
const BaseItem_1 = require("../../models/BaseItem");
const syncInfoUtils_1 = require("../synchronizer/syncInfoUtils");
const utils_1 = require("../e2ee/utils");
let insideBeforeEach = false;
function newResourceFetcher(synchronizer) {
    return new ResourceFetcher_1.default(() => { return synchronizer.api(); });
}
describe('Synchronizer.e2ee', function () {
    beforeEach((done) => __awaiter(this, void 0, void 0, function* () {
        insideBeforeEach = true;
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(2);
        yield (0, test_utils_1.switchClient)(1);
        done();
        insideBeforeEach = false;
    }));
    it('notes and folders should get encrypted when encryption is enabled', (() => __awaiter(this, void 0, void 0, function* () {
        (0, syncInfoUtils_1.setEncryptionEnabled)(true);
        const masterKey = yield (0, test_utils_1.loadEncryptionMasterKey)();
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        let note1 = yield Note_1.default.save({ title: 'un', body: 'to be encrypted', parent_id: folder1.id });
        yield (0, test_utils_1.synchronizerStart)();
        // After synchronisation, remote items should be encrypted but local ones remain plain text
        note1 = yield Note_1.default.load(note1.id);
        expect(note1.title).toBe('un');
        yield (0, test_utils_1.switchClient)(2);
        yield (0, test_utils_1.synchronizerStart)();
        let folder1_2 = yield Folder_1.default.load(folder1.id);
        let note1_2 = yield Note_1.default.load(note1.id);
        const masterKey_2 = yield MasterKey_1.default.load(masterKey.id);
        // On this side however it should be received encrypted
        expect(!note1_2.title).toBe(true);
        expect(!folder1_2.title).toBe(true);
        expect(!!note1_2.encryption_cipher_text).toBe(true);
        expect(!!folder1_2.encryption_cipher_text).toBe(true);
        // Master key is already encrypted so it does not get re-encrypted during sync
        expect(masterKey_2.content).toBe(masterKey.content);
        expect(masterKey_2.checksum).toBe(masterKey.checksum);
        // Now load the master key we got from client 1 and try to decrypt
        yield (0, test_utils_1.encryptionService)().loadMasterKey(masterKey_2, '123456', true);
        // Get the decrypted items back
        yield Folder_1.default.decrypt(folder1_2);
        yield Note_1.default.decrypt(note1_2);
        folder1_2 = yield Folder_1.default.load(folder1.id);
        note1_2 = yield Note_1.default.load(note1.id);
        // Check that properties match the original items. Also check
        // the encryption did not affect the updated_time timestamp.
        expect(note1_2.title).toBe(note1.title);
        expect(note1_2.body).toBe(note1.body);
        expect(note1_2.updated_time).toBe(note1.updated_time);
        expect(!note1_2.encryption_cipher_text).toBe(true);
        expect(folder1_2.title).toBe(folder1.title);
        expect(folder1_2.updated_time).toBe(folder1.updated_time);
        expect(!folder1_2.encryption_cipher_text).toBe(true);
    })));
    it('should mark the key has having been used when synchronising the first time', (() => __awaiter(this, void 0, void 0, function* () {
        (0, syncInfoUtils_1.setEncryptionEnabled)(true);
        yield (0, test_utils_1.loadEncryptionMasterKey)();
        yield Folder_1.default.save({ title: 'folder1' });
        yield (0, test_utils_1.synchronizerStart)();
        const localInfo = (0, syncInfoUtils_1.localSyncInfo)();
        const remoteInfo = yield (0, syncInfoUtils_1.fetchSyncInfo)((0, test_utils_1.fileApi)());
        expect(localInfo.masterKeys[0].hasBeenUsed).toBe(true);
        expect(remoteInfo.masterKeys[0].hasBeenUsed).toBe(true);
    })));
    it('should mark the key has having been used when synchronising after enabling encryption', (() => __awaiter(this, void 0, void 0, function* () {
        yield Folder_1.default.save({ title: 'folder1' });
        yield (0, test_utils_1.synchronizerStart)();
        (0, syncInfoUtils_1.setEncryptionEnabled)(true);
        yield (0, test_utils_1.loadEncryptionMasterKey)();
        yield (0, test_utils_1.synchronizerStart)();
        const localInfo = (0, syncInfoUtils_1.localSyncInfo)();
        const remoteInfo = yield (0, syncInfoUtils_1.fetchSyncInfo)((0, test_utils_1.fileApi)());
        expect(localInfo.masterKeys[0].hasBeenUsed).toBe(true);
        expect(remoteInfo.masterKeys[0].hasBeenUsed).toBe(true);
    })));
    it('should enable encryption automatically when downloading new master key (and none was previously available)', (() => __awaiter(this, void 0, void 0, function* () {
        // Enable encryption on client 1 and sync an item
        (0, syncInfoUtils_1.setEncryptionEnabled)(true);
        yield (0, test_utils_1.loadEncryptionMasterKey)();
        let folder1 = yield Folder_1.default.save({ title: 'folder1' });
        yield (0, test_utils_1.synchronizerStart)();
        yield (0, test_utils_1.switchClient)(2);
        // Synchronising should enable encryption since we're going to get a master key
        expect((0, syncInfoUtils_1.getEncryptionEnabled)()).toBe(false);
        yield (0, test_utils_1.synchronizerStart)();
        expect((0, syncInfoUtils_1.getEncryptionEnabled)()).toBe(true);
        // Check that we got the master key from client 1
        const masterKey = (yield MasterKey_1.default.all())[0];
        expect(!!masterKey).toBe(true);
        // Since client 2 hasn't supplied a password yet, no master key is currently loaded
        expect((0, test_utils_1.encryptionService)().loadedMasterKeyIds().length).toBe(0);
        // If we sync now, nothing should be sent to target since we don't have a password.
        // Technically it's incorrect to set the property of an encrypted variable but it allows confirming
        // that encryption doesn't work if user hasn't supplied a password.
        yield BaseItem_1.default.forceSync(folder1.id);
        yield (0, test_utils_1.synchronizerStart)();
        yield (0, test_utils_1.switchClient)(1);
        yield (0, test_utils_1.synchronizerStart)();
        folder1 = yield Folder_1.default.load(folder1.id);
        expect(folder1.title).toBe('folder1'); // Still at old value
        yield (0, test_utils_1.switchClient)(2);
        // Now client 2 set the master key password
        Setting_1.default.setObjectValue('encryption.passwordCache', masterKey.id, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        // Now that master key should be loaded
        expect((0, test_utils_1.encryptionService)().loadedMasterKeyIds()[0]).toBe(masterKey.id);
        // Decrypt all the data. Now change the title and sync again - this time the changes should be transmitted
        yield (0, test_utils_1.decryptionWorker)().start();
        yield Folder_1.default.save({ id: folder1.id, title: 'change test' });
        // If we sync now, this time client 1 should get the changes we did earlier
        yield (0, test_utils_1.synchronizerStart)();
        yield (0, test_utils_1.switchClient)(1);
        yield (0, test_utils_1.synchronizerStart)();
        // Decrypt the data we just got
        yield (0, test_utils_1.decryptionWorker)().start();
        folder1 = yield Folder_1.default.load(folder1.id);
        expect(folder1.title).toBe('change test'); // Got title from client 2
    })));
    it('should encrypt existing notes too when enabling E2EE', (() => __awaiter(this, void 0, void 0, function* () {
        // First create a folder, without encryption enabled, and sync it
        yield Folder_1.default.save({ title: 'folder1' });
        yield (0, test_utils_1.synchronizerStart)();
        let files = yield (0, test_utils_1.fileApi)().list('', { includeDirs: false, syncItemsOnly: true });
        let content = yield (0, test_utils_1.fileApi)().get(files.items[0].path);
        expect(content.indexOf('folder1') >= 0).toBe(true);
        // Then enable encryption and sync again
        let masterKey = yield (0, test_utils_1.encryptionService)().generateMasterKey('123456');
        masterKey = yield MasterKey_1.default.save(masterKey);
        yield (0, utils_1.setupAndEnableEncryption)((0, test_utils_1.encryptionService)(), masterKey, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        yield (0, test_utils_1.synchronizerStart)();
        // Even though the folder has not been changed it should have been synced again so that
        // an encrypted version of it replaces the decrypted version.
        files = yield (0, test_utils_1.fileApi)().list('', { includeDirs: false, syncItemsOnly: true });
        expect(files.items.length).toBe(1);
        // By checking that the folder title is not present, we can confirm that the item has indeed been encrypted
        content = yield (0, test_utils_1.fileApi)().get(files.items[0].path);
        expect(content.indexOf('folder1') < 0).toBe(true);
    })));
    it('should upload decrypted items to sync target after encryption disabled', (() => __awaiter(this, void 0, void 0, function* () {
        (0, syncInfoUtils_1.setEncryptionEnabled)(true);
        yield (0, test_utils_1.loadEncryptionMasterKey)();
        yield Folder_1.default.save({ title: 'folder1' });
        yield (0, test_utils_1.synchronizerStart)();
        let allEncrypted = yield (0, test_utils_1.allSyncTargetItemsEncrypted)();
        expect(allEncrypted).toBe(true);
        yield (0, utils_1.setupAndDisableEncryption)((0, test_utils_1.encryptionService)());
        yield (0, test_utils_1.synchronizerStart)();
        allEncrypted = yield (0, test_utils_1.allSyncTargetItemsEncrypted)();
        expect(allEncrypted).toBe(false);
    })));
    it('should not upload any item if encryption was enabled, and items have not been decrypted, and then encryption disabled', (() => __awaiter(this, void 0, void 0, function* () {
        // For some reason I can't explain, this test is sometimes executed before beforeEach is finished
        // which means it's going to fail in unexpected way. So the loop below wait for beforeEach to be done.
        while (insideBeforeEach)
            yield time_1.default.msleep(100);
        (0, syncInfoUtils_1.setEncryptionEnabled)(true);
        const masterKey = yield (0, test_utils_1.loadEncryptionMasterKey)();
        yield Folder_1.default.save({ title: 'folder1' });
        yield (0, test_utils_1.synchronizerStart)();
        yield (0, test_utils_1.switchClient)(2);
        yield (0, test_utils_1.synchronizerStart)();
        expect((0, syncInfoUtils_1.getEncryptionEnabled)()).toBe(true);
        // If we try to disable encryption now, it should throw an error because some items are
        // currently encrypted. They must be decrypted first so that they can be sent as
        // plain text to the sync target.
        // let hasThrown = await checkThrowAsync(async () => await setupAndDisableEncryption(encryptionService()));
        // expect(hasThrown).toBe(true);
        // Now supply the password, and decrypt the items
        Setting_1.default.setObjectValue('encryption.passwordCache', masterKey.id, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        yield (0, test_utils_1.decryptionWorker)().start();
        // Try to disable encryption again
        const hasThrown = yield (0, test_utils_1.checkThrowAsync)(() => __awaiter(this, void 0, void 0, function* () { return yield (0, utils_1.setupAndDisableEncryption)((0, test_utils_1.encryptionService)()); }));
        expect(hasThrown).toBe(false);
        // If we sync now the target should receive the decrypted items
        yield (0, test_utils_1.synchronizerStart)();
        const allEncrypted = yield (0, test_utils_1.allSyncTargetItemsEncrypted)();
        expect(allEncrypted).toBe(false);
    })));
    it('should set the resource file size after decryption', (() => __awaiter(this, void 0, void 0, function* () {
        (0, syncInfoUtils_1.setEncryptionEnabled)(true);
        const masterKey = yield (0, test_utils_1.loadEncryptionMasterKey)();
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        const note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        yield shim_1.default.attachFileToNote(note1, `${test_utils_1.supportDir}/photo.jpg`);
        const resource1 = (yield Resource_1.default.all())[0];
        yield Resource_1.default.setFileSizeOnly(resource1.id, -1);
        Resource_1.default.fullPath(resource1);
        yield (0, test_utils_1.synchronizerStart)();
        yield (0, test_utils_1.switchClient)(2);
        yield (0, test_utils_1.synchronizerStart)();
        Setting_1.default.setObjectValue('encryption.passwordCache', masterKey.id, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        const fetcher = newResourceFetcher((0, test_utils_1.synchronizer)());
        fetcher.queueDownload_(resource1.id);
        yield fetcher.waitForAllFinished();
        yield (0, test_utils_1.decryptionWorker)().start();
        const resource1_2 = yield Resource_1.default.load(resource1.id);
        expect(resource1_2.size).toBe(2720);
    })));
    it('should encrypt remote resources after encryption has been enabled', (() => __awaiter(this, void 0, void 0, function* () {
        while (insideBeforeEach)
            yield time_1.default.msleep(100);
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        const note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        yield shim_1.default.attachFileToNote(note1, `${test_utils_1.supportDir}/photo.jpg`);
        yield (0, test_utils_1.synchronizerStart)();
        expect(yield (0, test_utils_1.allSyncTargetItemsEncrypted)()).toBe(false);
        const masterKey = yield (0, test_utils_1.loadEncryptionMasterKey)();
        yield (0, utils_1.setupAndEnableEncryption)((0, test_utils_1.encryptionService)(), masterKey, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        yield (0, test_utils_1.synchronizerStart)();
        expect(yield (0, test_utils_1.allSyncTargetItemsEncrypted)()).toBe(true);
    })));
    it('should upload encrypted resource, but it should not mark the blob as encrypted locally', (() => __awaiter(this, void 0, void 0, function* () {
        while (insideBeforeEach)
            yield time_1.default.msleep(100);
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        const note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        yield shim_1.default.attachFileToNote(note1, `${test_utils_1.supportDir}/photo.jpg`);
        const masterKey = yield (0, test_utils_1.loadEncryptionMasterKey)();
        yield (0, utils_1.setupAndEnableEncryption)((0, test_utils_1.encryptionService)(), masterKey, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        // await synchronizerStart();
        // const resource1 = (await Resource.all())[0];
        // expect(resource1.encryption_blob_encrypted).toBe(0);
    })));
    it('should decrypt the resource metadata, but not try to decrypt the file, if it is not present', (() => __awaiter(this, void 0, void 0, function* () {
        const note1 = yield Note_1.default.save({ title: 'note' });
        yield shim_1.default.attachFileToNote(note1, `${test_utils_1.supportDir}/photo.jpg`);
        const masterKey = yield (0, test_utils_1.loadEncryptionMasterKey)();
        yield (0, utils_1.setupAndEnableEncryption)((0, test_utils_1.encryptionService)(), masterKey, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        yield (0, test_utils_1.synchronizerStart)();
        expect(yield (0, test_utils_1.allSyncTargetItemsEncrypted)()).toBe(true);
        yield (0, test_utils_1.switchClient)(2);
        yield (0, test_utils_1.synchronizerStart)();
        Setting_1.default.setObjectValue('encryption.passwordCache', masterKey.id, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        yield (0, test_utils_1.decryptionWorker)().start();
        let resource = (yield Resource_1.default.all())[0];
        expect(!!resource.encryption_applied).toBe(false);
        expect(!!resource.encryption_blob_encrypted).toBe(true);
        const resourceFetcher = newResourceFetcher((0, test_utils_1.synchronizer)());
        yield resourceFetcher.start();
        yield resourceFetcher.waitForAllFinished();
        const ls = yield Resource_1.default.localState(resource);
        expect(ls.fetch_status).toBe(Resource_1.default.FETCH_STATUS_DONE);
        yield (0, test_utils_1.decryptionWorker)().start();
        resource = (yield Resource_1.default.all())[0];
        expect(!!resource.encryption_blob_encrypted).toBe(false);
    })));
    it('should stop trying to decrypt item after a few attempts', (() => __awaiter(this, void 0, void 0, function* () {
        let hasThrown;
        const note = yield Note_1.default.save({ title: 'ma note' });
        const masterKey = yield (0, test_utils_1.loadEncryptionMasterKey)();
        yield (0, utils_1.setupAndEnableEncryption)((0, test_utils_1.encryptionService)(), masterKey, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        yield (0, test_utils_1.synchronizerStart)();
        yield (0, test_utils_1.switchClient)(2);
        yield (0, test_utils_1.synchronizerStart)();
        // First, simulate a broken note and check that the decryption worker
        // gives up decrypting after a number of tries. This is mainly relevant
        // for data that crashes the mobile application - we don't want to keep
        // decrypting these.
        const encryptedNote = yield Note_1.default.load(note.id);
        const goodCipherText = encryptedNote.encryption_cipher_text;
        yield Note_1.default.save({ id: note.id, encryption_cipher_text: 'doesntlookright' });
        Setting_1.default.setObjectValue('encryption.passwordCache', masterKey.id, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        hasThrown = yield (0, test_utils_1.checkThrowAsync)(() => __awaiter(this, void 0, void 0, function* () { return yield (0, test_utils_1.decryptionWorker)().start({ errorHandler: 'throw' }); }));
        expect(hasThrown).toBe(true);
        hasThrown = yield (0, test_utils_1.checkThrowAsync)(() => __awaiter(this, void 0, void 0, function* () { return yield (0, test_utils_1.decryptionWorker)().start({ errorHandler: 'throw' }); }));
        expect(hasThrown).toBe(true);
        // Third time, an error is logged and no error is thrown
        hasThrown = yield (0, test_utils_1.checkThrowAsync)(() => __awaiter(this, void 0, void 0, function* () { return yield (0, test_utils_1.decryptionWorker)().start({ errorHandler: 'throw' }); }));
        expect(hasThrown).toBe(false);
        const disabledItems = yield (0, test_utils_1.decryptionWorker)().decryptionDisabledItems();
        expect(disabledItems.length).toBe(1);
        expect(disabledItems[0].id).toBe(note.id);
        expect((yield (0, test_utils_1.kvStore)().all()).length).toBe(1);
        yield (0, test_utils_1.kvStore)().clear();
        // Now check that if it fails once but succeed the second time, the note
        // is correctly decrypted and the counters are cleared.
        hasThrown = yield (0, test_utils_1.checkThrowAsync)(() => __awaiter(this, void 0, void 0, function* () { return yield (0, test_utils_1.decryptionWorker)().start({ errorHandler: 'throw' }); }));
        expect(hasThrown).toBe(true);
        yield Note_1.default.save({ id: note.id, encryption_cipher_text: goodCipherText });
        hasThrown = yield (0, test_utils_1.checkThrowAsync)(() => __awaiter(this, void 0, void 0, function* () { return yield (0, test_utils_1.decryptionWorker)().start({ errorHandler: 'throw' }); }));
        expect(hasThrown).toBe(false);
        const decryptedNote = yield Note_1.default.load(note.id);
        expect(decryptedNote.title).toBe('ma note');
        expect((yield (0, test_utils_1.kvStore)().all()).length).toBe(0);
        expect((yield (0, test_utils_1.decryptionWorker)().decryptionDisabledItems()).length).toBe(0);
    })));
    // it('should not encrypt notes that are shared by link', (async () => {
    // 	setEncryptionEnabled(true);
    // 	await loadEncryptionMasterKey();
    // 	await createFolderTree('', [
    // 		{
    // 			title: 'folder1',
    // 			children: [
    // 				{
    // 					title: 'un',
    // 				},
    // 				{
    // 					title: 'deux',
    // 				},
    // 			],
    // 		},
    // 	]);
    // 	let note1 = await Note.loadByTitle('un');
    // 	let note2 = await Note.loadByTitle('deux');
    // 	await shim.attachFileToNote(note1, `${supportDir}/photo.jpg`);
    // 	await shim.attachFileToNote(note2, `${supportDir}/photo.jpg`);
    // 	note1 = await Note.loadByTitle('un');
    // 	note2 = await Note.loadByTitle('deux');
    // 	const resourceId1 = (await Note.linkedResourceIds(note1.body))[0];
    // 	const resourceId2 = (await Note.linkedResourceIds(note2.body))[0];
    // 	await synchronizerStart();
    // 	await switchClient(2);
    // 	await synchronizerStart();
    // 	await switchClient(1);
    // 	const origNote2 = Object.assign({}, note2);
    // 	await BaseItem.updateShareStatus(note2, true);
    // 	note2 = await Note.load(note2.id);
    // 	// Sharing a note should not modify the timestamps
    // 	expect(note2.user_updated_time).toBe(origNote2.user_updated_time);
    // 	expect(note2.user_created_time).toBe(origNote2.user_created_time);
    // 	await synchronizerStart();
    // 	await switchClient(2);
    // 	await synchronizerStart();
    // 	// The shared note should be decrypted
    // 	const note2_2 = await Note.load(note2.id);
    // 	expect(note2_2.title).toBe('deux');
    // 	expect(note2_2.encryption_applied).toBe(0);
    // 	expect(note2_2.is_shared).toBe(1);
    // 	// The resource linked to the shared note should also be decrypted
    // 	const resource2: ResourceEntity = await Resource.load(resourceId2);
    // 	expect(resource2.is_shared).toBe(1);
    // 	expect(resource2.encryption_applied).toBe(0);
    // 	const fetcher = newResourceFetcher(synchronizer());
    // 	await fetcher.start();
    // 	await fetcher.waitForAllFinished();
    // 	// Because the resource is decrypted, the encrypted blob file should not
    // 	// exist, but the plain text one should.
    // 	expect(await shim.fsDriver().exists(Resource.fullPath(resource2, true))).toBe(false);
    // 	expect(await shim.fsDriver().exists(Resource.fullPath(resource2))).toBe(true);
    // 	// The non-shared note should be encrypted
    // 	const note1_2 = await Note.load(note1.id);
    // 	expect(note1_2.title).toBe('');
    // 	// The linked resource should also be encrypted
    // 	const resource1: ResourceEntity = await Resource.load(resourceId1);
    // 	expect(resource1.is_shared).toBe(0);
    // 	expect(resource1.encryption_applied).toBe(1);
    // 	// And the plain text blob should not be present. The encrypted one
    // 	// shouldn't either because it can only be downloaded once the metadata
    // 	// has been decrypted.
    // 	expect(await shim.fsDriver().exists(Resource.fullPath(resource1, true))).toBe(false);
    // 	expect(await shim.fsDriver().exists(Resource.fullPath(resource1))).toBe(false);
    // }));
    // it('should not encrypt items that are shared by folder', (async () => {
    // 	// We skip this test for Joplin Server because it's going to check if
    // 	// the share_id refers to an existing share.
    // 	if (syncTargetName() === 'joplinServer') {
    // 		expect(true).toBe(true);
    // 		return;
    // 	}
    // 	setEncryptionEnabled(true);
    // 	await loadEncryptionMasterKey();
    // 	const folder1 = await createFolderTree('', [
    // 		{
    // 			title: 'folder1',
    // 			children: [
    // 				{
    // 					title: 'note1',
    // 				},
    // 			],
    // 		},
    // 		{
    // 			title: 'folder2',
    // 			children: [
    // 				{
    // 					title: 'note2',
    // 				},
    // 			],
    // 		},
    // 	]);
    // 	await synchronizerStart();
    // 	await switchClient(2);
    // 	await synchronizerStart();
    // 	await switchClient(1);
    // 	// Simulate that the folder has been shared
    // 	await Folder.save({ id: folder1.id, share_id: 'abcd' });
    // 	await synchronizerStart();
    // 	await switchClient(2);
    // 	await synchronizerStart();
    // 	// The shared items should be decrypted
    // 	{
    // 		const folder1 = await Folder.loadByTitle('folder1');
    // 		const note1 = await Note.loadByTitle('note1');
    // 		expect(folder1.title).toBe('folder1');
    // 		expect(note1.title).toBe('note1');
    // 	}
    // 	// The non-shared items should be encrypted
    // 	{
    // 		const folder2 = await Folder.loadByTitle('folder2');
    // 		const note2 = await Note.loadByTitle('note2');
    // 		expect(folder2).toBeFalsy();
    // 		expect(note2).toBeFalsy();
    // 	}
    // }));
});
//# sourceMappingURL=Synchronizer.e2ee.test.js.map