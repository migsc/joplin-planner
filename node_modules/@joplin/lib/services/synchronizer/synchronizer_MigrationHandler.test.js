"use strict";
// To create a sync target snapshot for the current syncVersion:
// - In test-utils, set syncTargetName_ to "filesystem"
// - Then run:
// node tests/support/createSyncTargetSnapshot.js normal && node tests/support/createSyncTargetSnapshot.js e2ee
//
// These tests work by a taking a sync target snapshot at a version n and upgrading it to n+1.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const LockHandler_1 = require("./LockHandler");
const MigrationHandler_1 = require("./MigrationHandler");
const types_1 = require("./utils/types");
const test_utils_1 = require("../../testing/test-utils");
const syncTargetUtils_1 = require("../../testing/syncTargetUtils");
const Setting_1 = require("../../models/Setting");
const MasterKey_1 = require("../../models/MasterKey");
const utils_1 = require("../e2ee/utils");
const syncInfoUtils_1 = require("./syncInfoUtils");
const specTimeout = 60000 * 10; // Nextcloud tests can be slow
let lockHandler_ = null;
let migrationHandler_ = null;
function lockHandler() {
    if (lockHandler_)
        return lockHandler_;
    lockHandler_ = new LockHandler_1.default((0, test_utils_1.fileApi)());
    return lockHandler_;
}
function migrationHandler(clientId = 'abcd') {
    if (migrationHandler_)
        return migrationHandler_;
    migrationHandler_ = new MigrationHandler_1.default((0, test_utils_1.fileApi)(), (0, test_utils_1.db)(), lockHandler(), LockHandler_1.LockClientType.Desktop, clientId);
    return migrationHandler_;
}
const migrationTests = {
    2: function () {
        return __awaiter(this, void 0, void 0, function* () {
            const items = (yield (0, test_utils_1.fileApi)().list('', { includeHidden: true })).items;
            expect(items.filter((i) => i.path === '.resource' && i.isDir).length).toBe(1);
            expect(items.filter((i) => i.path === 'locks' && i.isDir).length).toBe(1);
            expect(items.filter((i) => i.path === 'temp' && i.isDir).length).toBe(1);
            expect(items.filter((i) => i.path === 'info.json' && !i.isDir).length).toBe(1);
            const versionForOldClients = yield (0, test_utils_1.fileApi)().get('.sync/version.txt');
            expect(versionForOldClients).toBe('2');
        });
    },
    3: function () {
        return __awaiter(this, void 0, void 0, function* () {
            const items = (yield (0, test_utils_1.fileApi)().list('', { includeHidden: true })).items;
            expect(items.filter((i) => i.path === '.resource' && i.isDir).length).toBe(1);
            expect(items.filter((i) => i.path === 'locks' && i.isDir).length).toBe(1);
            expect(items.filter((i) => i.path === 'temp' && i.isDir).length).toBe(1);
            expect(items.filter((i) => i.path === 'info.json' && !i.isDir).length).toBe(1);
            const versionForOldClients = yield (0, test_utils_1.fileApi)().get('.sync/version.txt');
            expect(versionForOldClients).toBe('2');
        });
    },
};
const maxSyncVersion = Number(Object.keys(migrationTests).sort().pop());
function testMigration(migrationVersion, maxSyncVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, syncTargetUtils_1.deploySyncTargetSnapshot)('normal', migrationVersion - 1);
        const info = yield (0, syncInfoUtils_1.fetchSyncInfo)((0, test_utils_1.fileApi)());
        expect(info.version).toBe(migrationVersion - 1);
        // Now, migrate to the new version
        Setting_1.default.setConstant('syncVersion', migrationVersion);
        yield migrationHandler().upgrade(migrationVersion);
        // Verify that it has been upgraded
        const newInfo = yield (0, syncInfoUtils_1.fetchSyncInfo)((0, test_utils_1.fileApi)());
        expect(newInfo.version).toBe(migrationVersion);
        yield migrationTests[migrationVersion]();
        // If we're not on the latest version, we exit here, because although the
        // synchronizer can run the migration from one version to another, it cannot
        // sync the data on an older version (since the code has been changed to
        // work with the latest version).
        if (migrationVersion !== maxSyncVersion)
            return;
        // Now sync with that upgraded target
        yield (0, test_utils_1.synchronizer)().start();
        // Check that the data has not been altered
        yield (0, test_utils_1.expectNotThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield (0, syncTargetUtils_1.checkTestData)(syncTargetUtils_1.testData); }));
        // Check what happens if we switch to a different client and sync
        yield (0, test_utils_1.switchClient)(2);
        Setting_1.default.setConstant('syncVersion', migrationVersion);
        yield (0, test_utils_1.synchronizer)().start();
        yield (0, test_utils_1.expectNotThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield (0, syncTargetUtils_1.checkTestData)(syncTargetUtils_1.testData); }));
    });
}
function testMigrationE2EE(migrationVersion, maxSyncVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        // First create some test data that will be used to validate
        // that the migration didn't alter any data.
        yield (0, syncTargetUtils_1.deploySyncTargetSnapshot)('e2ee', migrationVersion - 1);
        // Now, migrate to the new version
        Setting_1.default.setConstant('syncVersion', migrationVersion);
        yield migrationHandler().upgrade(migrationVersion);
        // Verify that it has been upgraded
        const newInfo = yield (0, syncInfoUtils_1.fetchSyncInfo)((0, test_utils_1.fileApi)());
        expect(newInfo.version).toBe(migrationVersion);
        yield migrationTests[migrationVersion]();
        if (migrationVersion !== maxSyncVersion)
            return;
        // Now sync with that upgraded target
        yield (0, test_utils_1.synchronizer)().start();
        // Decrypt the data
        const masterKey = (yield MasterKey_1.default.all())[0];
        Setting_1.default.setObjectValue('encryption.passwordCache', masterKey.id, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        yield (0, test_utils_1.decryptionWorker)().start();
        // Check that the data has not been altered
        yield (0, test_utils_1.expectNotThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield (0, syncTargetUtils_1.checkTestData)(syncTargetUtils_1.testData); }));
        // Check what happens if we switch to a different client and sync
        yield (0, test_utils_1.switchClient)(2);
        Setting_1.default.setConstant('syncVersion', migrationVersion);
        yield (0, test_utils_1.synchronizer)().start();
        // Should throw because data hasn't been decrypted yet
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield (0, syncTargetUtils_1.checkTestData)(syncTargetUtils_1.testData); }));
        // Enable E2EE and decrypt
        Setting_1.default.setObjectValue('encryption.passwordCache', masterKey.id, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        yield (0, test_utils_1.decryptionWorker)().start();
        // Should not throw because data is decrypted
        yield (0, test_utils_1.expectNotThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield (0, syncTargetUtils_1.checkTestData)(syncTargetUtils_1.testData); }));
    });
}
let previousSyncTargetName = '';
describe('MigrationHandler', function () {
    beforeEach((done) => __awaiter(this, void 0, void 0, function* () {
        // Note that, for undocumented reasons, the timeout argument passed
        // to `test()` (or `it()`) is ignored if it is higher than the
        // global Jest timeout. So we need to set it globally.
        //
        // https://github.com/facebook/jest/issues/5055#issuecomment-513585906
        jest.setTimeout(specTimeout);
        // To test the migrations, we have to use the filesystem sync target
        // because the sync target snapshots are plain files. Eventually
        // it should be possible to copy a filesystem target to memory
        // but for now that will do.
        previousSyncTargetName = (0, test_utils_1.setSyncTargetName)('filesystem');
        lockHandler_ = null;
        migrationHandler_ = null;
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(2);
        yield (0, test_utils_1.switchClient)(1);
        done();
    }));
    afterEach((done) => __awaiter(this, void 0, void 0, function* () {
        (0, test_utils_1.setSyncTargetName)(previousSyncTargetName);
        done();
    }));
    it('should init a new sync target', (() => __awaiter(this, void 0, void 0, function* () {
        // Check that basic folders "locks" and "temp" are created for new sync targets.
        yield migrationHandler().upgrade(1);
        const result = yield (0, test_utils_1.fileApi)().list();
        expect(result.items.filter((i) => i.path === types_1.Dirnames.Locks).length).toBe(1);
        expect(result.items.filter((i) => i.path === types_1.Dirnames.Temp).length).toBe(1);
    })), specTimeout);
    it('should not allow syncing if the sync target is out-dated', (() => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.synchronizer)().start();
        yield (0, test_utils_1.fileApi)().put('info.json', `{"version":${Setting_1.default.value('syncVersion') - 1}}`);
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield migrationHandler().checkCanSync(); }), 'outdatedSyncTarget');
    })), specTimeout);
    it('should not allow syncing if the client is out-dated', (() => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.synchronizer)().start();
        yield (0, test_utils_1.fileApi)().put('info.json', `{"version":${Setting_1.default.value('syncVersion') + 1}}`);
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield migrationHandler().checkCanSync(); }), 'outdatedClient');
    })), specTimeout);
    it('should apply migration 2 normal', () => __awaiter(this, void 0, void 0, function* () {
        yield testMigration(2, maxSyncVersion);
    }), specTimeout);
    it('should apply migration 2 E2EE', () => __awaiter(this, void 0, void 0, function* () {
        yield testMigrationE2EE(2, maxSyncVersion);
    }), specTimeout);
    it('should apply migration 3 normal', () => __awaiter(this, void 0, void 0, function* () {
        yield testMigration(3, maxSyncVersion);
    }), specTimeout);
    it('should apply migration 3 E2EE', () => __awaiter(this, void 0, void 0, function* () {
        yield testMigrationE2EE(3, maxSyncVersion);
    }), specTimeout);
});
//# sourceMappingURL=synchronizer_MigrationHandler.test.js.map