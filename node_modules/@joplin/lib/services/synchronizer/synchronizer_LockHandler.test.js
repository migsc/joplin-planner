"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const LockHandler_1 = require("../../services/synchronizer/LockHandler");
const test_utils_1 = require("../../testing/test-utils");
// For tests with memory of file system we can use low intervals to make the tests faster.
// However if we use such low values with network sync targets, some calls might randomly fail with
// ECONNRESET and similar errors (Dropbox or OneDrive migth also throttle). Also we can't use a
// low lock TTL value because the lock might expire between the time it's written and the time it's checked.
// For that reason we add this multiplier for non-memory sync targets.
const timeoutMultipler = (0, test_utils_1.isNetworkSyncTarget)() ? 100 : 1;
let lockHandler_ = null;
function newLockHandler(options = null) {
    return new LockHandler_1.default((0, test_utils_1.fileApi)(), options);
}
function lockHandler() {
    if (lockHandler_)
        return lockHandler_;
    lockHandler_ = new LockHandler_1.default((0, test_utils_1.fileApi)());
    return lockHandler_;
}
describe('synchronizer_LockHandler', function () {
    beforeEach((done) => __awaiter(this, void 0, void 0, function* () {
        // logger.setLevel(Logger.LEVEL_WARN);
        lockHandler_ = null;
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(2);
        yield (0, test_utils_1.switchClient)(1);
        yield (0, test_utils_1.synchronizer)().start(); // Need to sync once to setup the sync target and allow locks to work
        // logger.setLevel(Logger.LEVEL_DEBUG);
        done();
    }));
    it('should acquire and release a sync lock', (() => __awaiter(this, void 0, void 0, function* () {
        yield lockHandler().acquireLock(LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Mobile, '123456');
        const locks = yield lockHandler().locks(LockHandler_1.LockType.Sync);
        expect(locks.length).toBe(1);
        expect(locks[0].type).toBe(LockHandler_1.LockType.Sync);
        expect(locks[0].clientId).toBe('123456');
        expect(locks[0].clientType).toBe(LockHandler_1.LockClientType.Mobile);
        yield lockHandler().releaseLock(LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Mobile, '123456');
        expect((yield lockHandler().locks(LockHandler_1.LockType.Sync)).length).toBe(0);
    })));
    it('should not use files that are not locks', (() => __awaiter(this, void 0, void 0, function* () {
        if (lockHandler().useBuiltInLocks)
            return; // Doesn't make sense with built-in locks
        yield (0, test_utils_1.fileApi)().put('locks/desktop.ini', 'a');
        yield (0, test_utils_1.fileApi)().put('locks/exclusive.json', 'a');
        yield (0, test_utils_1.fileApi)().put('locks/garbage.json', 'a');
        yield (0, test_utils_1.fileApi)().put('locks/1_2_72c4d1b7253a4475bfb2f977117d26ed.json', 'a');
        // Check that it doesn't cause an error if it fetches an old style lock
        yield (0, test_utils_1.fileApi)().put('locks/sync_desktop_82c4d1b7253a4475bfb2f977117d26ed.json', 'a');
        const locks = yield lockHandler().locks(LockHandler_1.LockType.Sync);
        expect(locks.length).toBe(1);
        expect(locks[0].type).toBe(LockHandler_1.LockType.Sync);
        expect(locks[0].clientType).toBe(LockHandler_1.LockClientType.Mobile);
        expect(locks[0].clientId).toBe('72c4d1b7253a4475bfb2f977117d26ed');
    })));
    it('should allow multiple sync locks', (() => __awaiter(this, void 0, void 0, function* () {
        yield lockHandler().acquireLock(LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Mobile, '111');
        yield (0, test_utils_1.switchClient)(2);
        yield lockHandler().acquireLock(LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Mobile, '222');
        expect((yield lockHandler().locks(LockHandler_1.LockType.Sync)).length).toBe(2);
        {
            yield lockHandler().releaseLock(LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Mobile, '222');
            const locks = yield lockHandler().locks(LockHandler_1.LockType.Sync);
            expect(locks.length).toBe(1);
            expect(locks[0].clientId).toBe('111');
        }
    })));
    it('should auto-refresh a lock', (() => __awaiter(this, void 0, void 0, function* () {
        const handler = newLockHandler({ autoRefreshInterval: 100 * timeoutMultipler });
        const lock = yield handler.acquireLock(LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Desktop, '111');
        const lockBefore = (0, LockHandler_1.activeLock)(yield handler.locks(), new Date(), handler.lockTtl, LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Desktop, '111');
        handler.startAutoLockRefresh(lock, () => { });
        yield (0, test_utils_1.msleep)(500 * timeoutMultipler);
        const lockAfter = (0, LockHandler_1.activeLock)(yield handler.locks(), new Date(), handler.lockTtl, LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Desktop, '111');
        expect(lockAfter.updatedTime).toBeGreaterThan(lockBefore.updatedTime);
        handler.stopAutoLockRefresh(lock);
    })));
    it('should call the error handler when lock has expired while being auto-refreshed', (() => __awaiter(this, void 0, void 0, function* () {
        const handler = newLockHandler({
            lockTtl: 50 * timeoutMultipler,
            autoRefreshInterval: 200 * timeoutMultipler,
        });
        const lock = yield handler.acquireLock(LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Desktop, '111');
        let autoLockError = null;
        handler.startAutoLockRefresh(lock, (error) => {
            autoLockError = error;
        });
        try {
            yield (0, test_utils_1.msleep)(250 * timeoutMultipler);
            expect(autoLockError).toBeTruthy();
            expect(autoLockError.code).toBe('lockExpired');
        }
        finally {
            handler.stopAutoLockRefresh(lock);
        }
    })));
    it('should not allow sync locks if there is an exclusive lock', (() => __awaiter(this, void 0, void 0, function* () {
        yield lockHandler().acquireLock(LockHandler_1.LockType.Exclusive, LockHandler_1.LockClientType.Desktop, '111');
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () {
            yield lockHandler().acquireLock(LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Mobile, '222');
        }), 'hasExclusiveLock');
    })));
    it('should not allow exclusive lock if there are sync locks', (() => __awaiter(this, void 0, void 0, function* () {
        const lockHandler = newLockHandler({ lockTtl: 1000 * 60 * 60 });
        if (lockHandler.useBuiltInLocks)
            return; // Tested server side
        yield lockHandler.acquireLock(LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Mobile, '111');
        yield lockHandler.acquireLock(LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Mobile, '222');
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () {
            yield lockHandler.acquireLock(LockHandler_1.LockType.Exclusive, LockHandler_1.LockClientType.Desktop, '333');
        }), 'hasSyncLock');
    })));
    it('should allow exclusive lock if the sync locks have expired', (() => __awaiter(this, void 0, void 0, function* () {
        const lockHandler = newLockHandler({ lockTtl: 500 * timeoutMultipler });
        if (lockHandler.useBuiltInLocks)
            return; // Tested server side
        yield lockHandler.acquireLock(LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Mobile, '111');
        yield lockHandler.acquireLock(LockHandler_1.LockType.Sync, LockHandler_1.LockClientType.Mobile, '222');
        yield (0, test_utils_1.msleep)(600 * timeoutMultipler);
        yield (0, test_utils_1.expectNotThrow)(() => __awaiter(this, void 0, void 0, function* () {
            yield lockHandler.acquireLock(LockHandler_1.LockType.Exclusive, LockHandler_1.LockClientType.Desktop, '333');
        }));
    })));
    it('should decide what is the active exclusive lock', (() => __awaiter(this, void 0, void 0, function* () {
        const lockHandler = newLockHandler();
        {
            const locks = [
                {
                    type: LockHandler_1.LockType.Exclusive,
                    clientId: '1',
                    clientType: LockHandler_1.LockClientType.Desktop,
                    updatedTime: Date.now(),
                },
            ];
            yield (0, test_utils_1.msleep)(100);
            locks.push({
                type: LockHandler_1.LockType.Exclusive,
                clientId: '2',
                clientType: LockHandler_1.LockClientType.Desktop,
                updatedTime: Date.now(),
            });
            const lock = (0, LockHandler_1.activeLock)(locks, new Date(), lockHandler.lockTtl, LockHandler_1.LockType.Exclusive);
            expect(lock.clientId).toBe('1');
        }
    })));
    // it('should ignore locks by same client when trying to acquire exclusive lock', (async () => {
    // 	const lockHandler = newLockHandler();
    // 	await lockHandler.acquireLock(LockType.Sync, LockClientType.Desktop, '111');
    // 	await expectThrow(async () => {
    // 		await lockHandler.acquireLock(LockType.Exclusive, LockClientType.Desktop, '111', { clearExistingSyncLocksFromTheSameClient: false });
    // 	}, 'hasSyncLock');
    // 	await expectNotThrow(async () => {
    // 		await lockHandler.acquireLock(LockType.Exclusive, LockClientType.Desktop, '111', { clearExistingSyncLocksFromTheSameClient: true });
    // 	});
    // 	const lock = activeLock(await lockHandler.locks(), new Date(), lockHandler.lockTtl, LockType.Exclusive);
    // 	expect(lock.clientId).toBe('111');
    // }));
});
//# sourceMappingURL=synchronizer_LockHandler.test.js.map