"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const locale_1 = require("../../locale");
const InteropService_Importer_Base_1 = require("./InteropService_Importer_Base");
const Folder_1 = require("../../models/Folder");
const Note_1 = require("../../models/Note");
const path_utils_1 = require("../../path-utils");
const shim_1 = require("../../shim");
const markdownUtils_1 = require("../../markdownUtils");
const htmlUtils_1 = require("../../htmlUtils");
const ArrayUtils_1 = require("../../ArrayUtils");
const { pregQuote } = require('../../string-utils-common');
const renderer_1 = require("@joplin/renderer");
class InteropService_Importer_Md extends InteropService_Importer_Base_1.default {
    constructor() {
        super(...arguments);
        this.importedNotes = {};
    }
    exec(result) {
        return __awaiter(this, void 0, void 0, function* () {
            let parentFolderId = null;
            const sourcePath = (0, path_utils_1.rtrimSlashes)(this.sourcePath_);
            const filePaths = [];
            if (yield shim_1.default.fsDriver().isDirectory(sourcePath)) {
                if (!this.options_.destinationFolder) {
                    const folderTitle = yield Folder_1.default.findUniqueItemTitle((0, path_utils_1.basename)(sourcePath));
                    const folder = yield Folder_1.default.save({ title: folderTitle });
                    parentFolderId = folder.id;
                }
                else {
                    parentFolderId = this.options_.destinationFolder.id;
                }
                yield this.importDirectory(sourcePath, parentFolderId);
            }
            else {
                if (!this.options_.destinationFolder)
                    throw new Error((0, locale_1._)('Please specify the notebook where the notes should be imported to.'));
                parentFolderId = this.options_.destinationFolder.id;
                filePaths.push(sourcePath);
            }
            for (let i = 0; i < filePaths.length; i++) {
                yield this.importFile(filePaths[i], parentFolderId);
            }
            return result;
        });
    }
    importDirectory(dirPath, parentFolderId) {
        return __awaiter(this, void 0, void 0, function* () {
            const supportedFileExtension = this.metadata().fileExtensions;
            const stats = yield shim_1.default.fsDriver().readDirStats(dirPath);
            for (let i = 0; i < stats.length; i++) {
                const stat = stats[i];
                if (stat.isDirectory()) {
                    if (yield this.isDirectoryEmpty(`${dirPath}/${stat.path}`)) {
                        continue;
                    }
                    const folderTitle = yield Folder_1.default.findUniqueItemTitle((0, path_utils_1.basename)(stat.path));
                    const folder = yield Folder_1.default.save({ title: folderTitle, parent_id: parentFolderId });
                    yield this.importDirectory(`${dirPath}/${(0, path_utils_1.basename)(stat.path)}`, folder.id);
                }
                else if (supportedFileExtension.indexOf((0, path_utils_1.fileExtension)(stat.path).toLowerCase()) >= 0) {
                    yield this.importFile(`${dirPath}/${stat.path}`, parentFolderId);
                }
            }
        });
    }
    isDirectoryEmpty(dirPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const supportedFileExtension = this.metadata().fileExtensions;
            const innerStats = yield shim_1.default.fsDriver().readDirStats(dirPath);
            for (let i = 0; i < innerStats.length; i++) {
                const innerStat = innerStats[i];
                if (innerStat.isDirectory()) {
                    if (!(yield this.isDirectoryEmpty(`${dirPath}/${innerStat.path}`))) {
                        return false;
                    }
                }
                else if (supportedFileExtension.indexOf((0, path_utils_1.fileExtension)(innerStat.path).toLowerCase()) >= 0) {
                    return false;
                }
            }
            return true;
        });
    }
    trimAnchorLink(link) {
        if (link.indexOf('#') <= 0)
            return link;
        const splitted = link.split('#');
        splitted.pop();
        return splitted.join('#');
    }
    /**
     * Parse text for links, attempt to find local file, if found create Joplin resource
     * and update link accordingly.
     */
    importLocalFiles(filePath, md, parentFolderId) {
        return __awaiter(this, void 0, void 0, function* () {
            let updated = md;
            const markdownLinks = markdownUtils_1.default.extractFileUrls(md);
            const htmlLinks = htmlUtils_1.default.extractFileUrls(md);
            const fileLinks = (0, ArrayUtils_1.unique)(markdownLinks.concat(htmlLinks));
            yield Promise.all(fileLinks.map((encodedLink) => __awaiter(this, void 0, void 0, function* () {
                const link = decodeURI(encodedLink);
                // Handle anchor links appropriately
                const trimmedLink = this.trimAnchorLink(link);
                const attachmentPath = (0, path_utils_1.filename)(`${(0, path_utils_1.dirname)(filePath)}/${trimmedLink}`, true);
                const pathWithExtension = `${attachmentPath}.${(0, path_utils_1.fileExtension)(trimmedLink)}`;
                const stat = yield shim_1.default.fsDriver().stat(pathWithExtension);
                const isDir = stat ? stat.isDirectory() : false;
                if (stat && !isDir) {
                    const supportedFileExtension = this.metadata().fileExtensions;
                    const resolvedPath = shim_1.default.fsDriver().resolve(pathWithExtension);
                    let id = '';
                    // If the link looks like a note, then import it
                    if (supportedFileExtension.indexOf((0, path_utils_1.fileExtension)(trimmedLink).toLowerCase()) >= 0) {
                        // If the note hasn't been imported yet, do so now
                        if (!this.importedNotes[resolvedPath]) {
                            yield this.importFile(resolvedPath, parentFolderId);
                        }
                        id = this.importedNotes[resolvedPath].id;
                    }
                    else {
                        const resource = yield shim_1.default.createResourceFromPath(pathWithExtension);
                        id = resource.id;
                    }
                    // The first is a normal link, the second is supports the <link> and [](<link with spaces>) syntax
                    // Only opening patterns are consider in order to cover all occurances
                    // We need to use the encoded link as well because some links (link's with spaces)
                    // will appear encoded in the source. Other links (unicode chars) will not
                    const linksToReplace = [this.trimAnchorLink(link), this.trimAnchorLink(encodedLink)];
                    for (let j = 0; j < linksToReplace.length; j++) {
                        const linkToReplace = pregQuote(linksToReplace[j]);
                        // Markdown links
                        updated = markdownUtils_1.default.replaceResourceUrl(updated, linkToReplace, id);
                        // HTML links
                        updated = htmlUtils_1.default.replaceResourceUrl(updated, linkToReplace, id);
                    }
                }
            })));
            return updated;
        });
    }
    importFile(filePath, parentFolderId) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolvedPath = shim_1.default.fsDriver().resolve(filePath);
            if (this.importedNotes[resolvedPath])
                return this.importedNotes[resolvedPath];
            const stat = yield shim_1.default.fsDriver().stat(resolvedPath);
            if (!stat)
                throw new Error(`Cannot read ${resolvedPath}`);
            const ext = (0, path_utils_1.fileExtension)(resolvedPath);
            const title = (0, path_utils_1.filename)(resolvedPath);
            const body = yield shim_1.default.fsDriver().readFile(resolvedPath);
            const note = {
                parent_id: parentFolderId,
                title: title,
                body: body,
                updated_time: stat.mtime.getTime(),
                created_time: stat.birthtime.getTime(),
                user_updated_time: stat.mtime.getTime(),
                user_created_time: stat.birthtime.getTime(),
                markup_language: ext === 'html' ? renderer_1.MarkupToHtml.MARKUP_LANGUAGE_HTML : renderer_1.MarkupToHtml.MARKUP_LANGUAGE_MARKDOWN,
            };
            this.importedNotes[resolvedPath] = yield Note_1.default.save(note, { autoTimestamp: false });
            try {
                const updatedBody = yield this.importLocalFiles(resolvedPath, body, parentFolderId);
                const updatedNote = Object.assign(Object.assign({}, this.importedNotes[resolvedPath]), { body: updatedBody || body });
                this.importedNotes[resolvedPath] = yield Note_1.default.save(updatedNote, { isNew: false });
            }
            catch (error) {
                // console.error(`Problem importing links for file ${resolvedPath}, error:\n ${error}`);
            }
            return this.importedNotes[resolvedPath];
        });
    }
}
exports.default = InteropService_Importer_Md;
//# sourceMappingURL=InteropService_Importer_Md.js.map