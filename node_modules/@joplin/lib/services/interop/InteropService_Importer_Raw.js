"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const InteropService_Importer_Base_1 = require("./InteropService_Importer_Base");
const BaseItem_1 = require("../../models/BaseItem");
const BaseModel_1 = require("../../BaseModel");
const Resource_1 = require("../../models/Resource");
const Folder_1 = require("../../models/Folder");
const NoteTag_1 = require("../../models/NoteTag");
const Note_1 = require("../../models/Note");
const Tag_1 = require("../../models/Tag");
const { sprintf } = require('sprintf-js');
const shim_1 = require("../../shim");
const { fileExtension } = require('../../path-utils');
const uuid_1 = require("../../uuid");
class InteropService_Importer_Raw extends InteropService_Importer_Base_1.default {
    exec(result) {
        return __awaiter(this, void 0, void 0, function* () {
            const itemIdMap = {};
            const createdResources = {};
            const noteTagsToCreate = [];
            const destinationFolderId = this.options_.destinationFolderId;
            const replaceLinkedItemIds = (noteBody) => __awaiter(this, void 0, void 0, function* () {
                let output = noteBody;
                const itemIds = Note_1.default.linkedItemIds(noteBody);
                for (let i = 0; i < itemIds.length; i++) {
                    const id = itemIds[i];
                    if (!itemIdMap[id])
                        itemIdMap[id] = uuid_1.default.create();
                    output = output.replace(new RegExp(id, 'gi'), itemIdMap[id]);
                }
                return output;
            });
            const stats = yield shim_1.default.fsDriver().readDirStats(this.sourcePath_);
            const folderExists = function (stats, folderId) {
                folderId = folderId.toLowerCase();
                for (let i = 0; i < stats.length; i++) {
                    const stat = stats[i];
                    const statId = BaseItem_1.default.pathToId(stat.path);
                    if (statId.toLowerCase() === folderId)
                        return true;
                }
                return false;
            };
            let defaultFolder_ = null;
            const defaultFolder = () => __awaiter(this, void 0, void 0, function* () {
                if (defaultFolder_)
                    return defaultFolder_;
                const folderTitle = yield Folder_1.default.findUniqueItemTitle(this.options_.defaultFolderTitle ? this.options_.defaultFolderTitle : 'Imported', '');
                // eslint-disable-next-line require-atomic-updates
                defaultFolder_ = yield Folder_1.default.save({ title: folderTitle });
                return defaultFolder_;
            });
            const setFolderToImportTo = (itemParentId) => __awaiter(this, void 0, void 0, function* () {
                // Logic is a bit complex here:
                // - If a destination folder was specified, move the note to it.
                // - Otherwise, if the associated folder exists, use this.
                // - If it doesn't exist, use the default folder. This is the case for example when importing JEX archives that contain only one or more notes, but no folder.
                const itemParentExists = folderExists(stats, itemParentId);
                if (!itemIdMap[itemParentId]) {
                    if (destinationFolderId) {
                        itemIdMap[itemParentId] = destinationFolderId;
                    }
                    else if (!itemParentExists) {
                        const parentFolder = yield defaultFolder();
                        // eslint-disable-next-line require-atomic-updates
                        itemIdMap[itemParentId] = parentFolder.id;
                    }
                    else {
                        itemIdMap[itemParentId] = uuid_1.default.create();
                    }
                }
            });
            for (let i = 0; i < stats.length; i++) {
                const stat = stats[i];
                if (stat.isDirectory())
                    continue;
                if (fileExtension(stat.path).toLowerCase() !== 'md')
                    continue;
                const content = yield shim_1.default.fsDriver().readFile(`${this.sourcePath_}/${stat.path}`);
                const item = yield BaseItem_1.default.unserialize(content);
                const itemType = item.type_;
                const ItemClass = BaseItem_1.default.itemClass(item);
                delete item.type_;
                if (itemType === BaseModel_1.default.TYPE_NOTE) {
                    yield setFolderToImportTo(item.parent_id);
                    if (!itemIdMap[item.id])
                        itemIdMap[item.id] = uuid_1.default.create();
                    item.id = itemIdMap[item.id];
                    item.parent_id = itemIdMap[item.parent_id];
                    item.body = yield replaceLinkedItemIds(item.body);
                }
                else if (itemType === BaseModel_1.default.TYPE_FOLDER) {
                    if (destinationFolderId)
                        continue;
                    if (!itemIdMap[item.id])
                        itemIdMap[item.id] = uuid_1.default.create();
                    item.id = itemIdMap[item.id];
                    if (item.parent_id) {
                        yield setFolderToImportTo(item.parent_id);
                        item.parent_id = itemIdMap[item.parent_id];
                    }
                    item.title = yield Folder_1.default.findUniqueItemTitle(item.title, item.parent_id);
                }
                else if (itemType === BaseModel_1.default.TYPE_RESOURCE) {
                    if (!itemIdMap[item.id])
                        itemIdMap[item.id] = uuid_1.default.create();
                    item.id = itemIdMap[item.id];
                    createdResources[item.id] = item;
                }
                else if (itemType === BaseModel_1.default.TYPE_TAG) {
                    const tag = yield Tag_1.default.loadByTitle(item.title);
                    if (tag) {
                        itemIdMap[item.id] = tag.id;
                        continue;
                    }
                    const tagId = uuid_1.default.create();
                    itemIdMap[item.id] = tagId;
                    item.id = tagId;
                }
                else if (itemType === BaseModel_1.default.TYPE_NOTE_TAG) {
                    noteTagsToCreate.push(item);
                    continue;
                }
                yield ItemClass.save(item, { isNew: true, autoTimestamp: false });
            }
            for (let i = 0; i < noteTagsToCreate.length; i++) {
                const noteTag = noteTagsToCreate[i];
                const newNoteId = itemIdMap[noteTag.note_id];
                const newTagId = itemIdMap[noteTag.tag_id];
                if (!newNoteId) {
                    result.warnings.push(sprintf('Non-existent note %s referenced in tag %s', noteTag.note_id, noteTag.tag_id));
                    continue;
                }
                if (!newTagId) {
                    result.warnings.push(sprintf('Non-existent tag %s for note %s', noteTag.tag_id, noteTag.note_id));
                    continue;
                }
                noteTag.id = uuid_1.default.create();
                noteTag.note_id = newNoteId;
                noteTag.tag_id = newTagId;
                yield NoteTag_1.default.save(noteTag, { isNew: true });
            }
            if (yield shim_1.default.fsDriver().isDirectory(`${this.sourcePath_}/resources`)) {
                const resourceStats = yield shim_1.default.fsDriver().readDirStats(`${this.sourcePath_}/resources`);
                for (let i = 0; i < resourceStats.length; i++) {
                    const resourceFilePath = `${this.sourcePath_}/resources/${resourceStats[i].path}`;
                    const oldId = Resource_1.default.pathToId(resourceFilePath);
                    const newId = itemIdMap[oldId];
                    if (!newId) {
                        result.warnings.push(sprintf('Resource file is not referenced in any note and so was not imported: %s', oldId));
                        continue;
                    }
                    const resource = createdResources[newId];
                    const destPath = Resource_1.default.fullPath(resource);
                    yield shim_1.default.fsDriver().copy(resourceFilePath, destPath);
                }
            }
            return result;
        });
    }
}
exports.default = InteropService_Importer_Raw;
//# sourceMappingURL=InteropService_Importer_Raw.js.map