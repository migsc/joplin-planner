"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const InteropService_Exporter_Base_1 = require("./InteropService_Exporter_Base");
const BaseModel_1 = require("../../BaseModel");
const shim_1 = require("../../shim");
const markupLanguageUtils_1 = require("../../markupLanguageUtils");
const Folder_1 = require("../../models/Folder");
const Note_1 = require("../../models/Note");
const Setting_1 = require("../../models/Setting");
const loadContentScripts_1 = require("../plugins/utils/loadContentScripts");
const path_utils_1 = require("../../path-utils");
const htmlpack_1 = require("@joplin/htmlpack");
const { themeStyle } = require('../../theme');
const { escapeHtml } = require('../../string-utils.js');
const { assetsToHeaders } = require('@joplin/renderer');
class InteropService_Exporter_Html extends InteropService_Exporter_Base_1.default {
    constructor() {
        super(...arguments);
        this.createdDirs_ = [];
        this.resources_ = [];
        this.packIntoSingleFile_ = false;
    }
    init(path, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.customCss_ = options.customCss ? options.customCss : '';
            if (this.metadata().target === 'file') {
                this.destDir_ = (0, path_utils_1.dirname)(path);
                this.filePath_ = path;
                this.packIntoSingleFile_ = 'packIntoSingleFile' in options ? options.packIntoSingleFile : true;
            }
            else {
                this.destDir_ = path;
                this.filePath_ = null;
            }
            this.resourceDir_ = this.destDir_ ? `${this.destDir_}/_resources` : null;
            yield shim_1.default.fsDriver().mkdir(this.destDir_);
            this.markupToHtml_ = markupLanguageUtils_1.default.newMarkupToHtml(null, {
                extraRendererRules: (0, loadContentScripts_1.contentScriptsToRendererRules)(options.plugins),
                customCss: this.customCss_ || '',
            });
            this.style_ = themeStyle(Setting_1.default.THEME_LIGHT);
        });
    }
    makeDirPath_(item, pathPart = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let output = '';
            while (true) {
                if (item.type_ === BaseModel_1.default.TYPE_FOLDER) {
                    if (pathPart) {
                        output = `${pathPart}/${output}`;
                    }
                    else {
                        output = `${(0, path_utils_1.friendlySafeFilename)(item.title)}/${output}`;
                        output = yield shim_1.default.fsDriver().findUniqueFilename(output);
                    }
                }
                if (!item.parent_id)
                    return output;
                item = yield Folder_1.default.load(item.parent_id);
            }
        });
    }
    processNoteResources_(item) {
        return __awaiter(this, void 0, void 0, function* () {
            const target = this.metadata().target;
            const linkedResourceIds = yield Note_1.default.linkedResourceIds(item.body);
            const relativePath = target === 'directory' ? (0, path_utils_1.rtrimSlashes)(yield this.makeDirPath_(item, '..')) : '';
            const resourcePaths = this.context() && this.context().resourcePaths ? this.context().resourcePaths : {};
            let newBody = item.body;
            for (let i = 0; i < linkedResourceIds.length; i++) {
                const id = linkedResourceIds[i];
                const resourceContent = `${relativePath ? `${relativePath}/` : ''}_resources/${(0, path_utils_1.basename)(resourcePaths[id])}`;
                newBody = newBody.replace(new RegExp(`:/${id}`, 'g'), resourceContent);
            }
            return newBody;
        });
    }
    processItem(_itemType, item) {
        return __awaiter(this, void 0, void 0, function* () {
            if ([BaseModel_1.default.TYPE_NOTE, BaseModel_1.default.TYPE_FOLDER].indexOf(item.type_) < 0)
                return;
            let dirPath = '';
            if (!this.filePath_) {
                dirPath = `${this.destDir_}/${yield this.makeDirPath_(item)}`;
                if (this.createdDirs_.indexOf(dirPath) < 0) {
                    yield shim_1.default.fsDriver().mkdir(dirPath);
                    this.createdDirs_.push(dirPath);
                }
            }
            if (item.type_ === BaseModel_1.default.TYPE_NOTE) {
                let noteFilePath = '';
                if (this.filePath_) {
                    noteFilePath = this.filePath_;
                }
                else {
                    noteFilePath = `${dirPath}/${(0, path_utils_1.friendlySafeFilename)(item.title)}.html`;
                    noteFilePath = yield shim_1.default.fsDriver().findUniqueFilename(noteFilePath);
                }
                const bodyMd = yield this.processNoteResources_(item);
                const result = yield this.markupToHtml_.render(item.markup_language, bodyMd, this.style_, {
                    resources: this.resources_,
                    plainResourceRendering: true,
                });
                const noteContent = [];
                if (item.title)
                    noteContent.push(`<div class="exported-note-title">${escapeHtml(item.title)}</div>`);
                if (result.html)
                    noteContent.push(result.html);
                const libRootPath = (0, path_utils_1.dirname)((0, path_utils_1.dirname)(__dirname));
                // We need to export all the plugin assets too and refer them from the header
                // The source path is a bit hard-coded but shouldn't change.
                for (let i = 0; i < result.pluginAssets.length; i++) {
                    const asset = result.pluginAssets[i];
                    const filePath = asset.pathIsAbsolute ? asset.path : `${libRootPath}/node_modules/@joplin/renderer/assets/${asset.name}`;
                    const destPath = `${(0, path_utils_1.dirname)(noteFilePath)}/pluginAssets/${asset.name}`;
                    const dir = (0, path_utils_1.dirname)(destPath);
                    yield shim_1.default.fsDriver().mkdir(dir);
                    this.createdDirs_.push(dir);
                    yield shim_1.default.fsDriver().copy(filePath, destPath);
                }
                const fullHtml = `
				<!DOCTYPE html>
				<html>
					<head>
						<meta charset="UTF-8">
						<meta name="viewport" content="width=device-width, initial-scale=1" />
						${assetsToHeaders(result.pluginAssets, { asHtml: true })}
						<title>${escapeHtml(item.title)}</title>
					</head>
					<body>
						<div class="exported-note">${noteContent.join('\n\n')}</div>
					</body>
				</html>
			`;
                yield shim_1.default.fsDriver().writeFile(noteFilePath, fullHtml, 'utf-8');
            }
        });
    }
    processResource(resource, filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const destResourcePath = `${this.resourceDir_}/${(0, path_utils_1.basename)(filePath)}`;
            yield shim_1.default.fsDriver().copy(filePath, destResourcePath);
            this.resources_.push(resource);
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.packIntoSingleFile_) {
                const tempFilePath = `${this.filePath_}.tmp`;
                yield shim_1.default.fsDriver().move(this.filePath_, tempFilePath);
                yield (0, htmlpack_1.default)(tempFilePath, this.filePath_);
                yield shim_1.default.fsDriver().remove(tempFilePath);
                for (const d of this.createdDirs_) {
                    yield shim_1.default.fsDriver().remove(d);
                }
                yield shim_1.default.fsDriver().remove(this.resourceDir_);
                yield shim_1.default.fsDriver().remove(`${this.destDir_}/pluginAssets`);
            }
        });
    }
}
exports.default = InteropService_Exporter_Html;
//# sourceMappingURL=InteropService_Exporter_Html.js.map