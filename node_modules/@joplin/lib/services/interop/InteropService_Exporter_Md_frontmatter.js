"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fieldOrder = void 0;
const InteropService_Exporter_Md_1 = require("./InteropService_Exporter_Md");
const BaseModel_1 = require("../../BaseModel");
const Note_1 = require("../../models/Note");
const NoteTag_1 = require("../../models/NoteTag");
const Tag_1 = require("../../models/Tag");
const time_1 = require("../../time");
const yaml = require("js-yaml");
// There is a special case (negative numbers) where the yaml library will force quotations
// These need to be stripped
function trimQuotes(rawOutput) {
    return rawOutput.split('\n').map(line => {
        const index = line.indexOf(': \'-');
        if (index >= 0) {
            // The plus 2 eats the : and space characters
            const start = line.substring(0, index + 2);
            //  The plus 3 eats the quote character
            const end = line.substring(index + 3, line.length - 1);
            return start + end;
        }
        return line;
    }).join('\n');
}
exports.fieldOrder = ['title', 'updated', 'created', 'source', 'author', 'latitude', 'longitude', 'altitude', 'completed?', 'due', 'tags'];
class InteropService_Exporter_Md_frontmatter extends InteropService_Exporter_Md_1.default {
    prepareForProcessingItemType(itemType, itemsToExport) {
        const _super = Object.create(null, {
            prepareForProcessingItemType: { get: () => super.prepareForProcessingItemType }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.prepareForProcessingItemType.call(this, itemType, itemsToExport);
            if (itemType === BaseModel_1.default.TYPE_NOTE_TAG) {
                // Get tag list for each note
                const context = {
                    noteTags: {},
                };
                for (let i = 0; i < itemsToExport.length; i++) {
                    const it = itemsToExport[i].type;
                    if (it !== itemType)
                        continue;
                    const itemOrId = itemsToExport[i].itemOrId;
                    const noteTag = typeof itemOrId === 'object' ? itemOrId : yield NoteTag_1.default.load(itemOrId);
                    if (!noteTag)
                        continue;
                    if (!context.noteTags[noteTag.note_id])
                        context.noteTags[noteTag.note_id] = [];
                    context.noteTags[noteTag.note_id].push(noteTag.tag_id);
                }
                this.updateContext(context);
            }
            else if (itemType === BaseModel_1.default.TYPE_TAG) {
                // Map tag ID to title
                const context = {
                    tagTitles: {},
                };
                for (let i = 0; i < itemsToExport.length; i++) {
                    const it = itemsToExport[i].type;
                    if (it !== itemType)
                        continue;
                    const itemOrId = itemsToExport[i].itemOrId;
                    const tag = typeof itemOrId === 'object' ? itemOrId : yield Tag_1.default.load(itemOrId);
                    if (!tag)
                        continue;
                    context.tagTitles[tag.id] = tag.title;
                }
                this.updateContext(context);
            }
        });
    }
    convertDate(datetime) {
        return time_1.default.unixMsToRfc3339Sec(datetime);
    }
    extractMetadata(note) {
        const md = {};
        // Every variable needs to be converted seperately, so they will be handles in groups
        //
        // title
        if (note.title) {
            md['title'] = note.title;
        }
        // source, author
        if (note.source_url) {
            md['source'] = note.source_url;
        }
        if (note.author) {
            md['author'] = note.author;
        }
        // locations
        // non-strict inequality is used here to interpret the location strings
        // as numbers i.e 0.000000 is the same as 0.
        // This is necessary because these fields are officially numbers, but often
        // contain strings.
        // eslint-disable-next-line eqeqeq
        if (note.latitude != 0 || note.longitude != 0 || note.altitude != 0) {
            md['latitude'] = note.latitude;
            md['longitude'] = note.longitude;
            md['altitude'] = note.altitude;
        }
        // todo
        if (note.is_todo) {
            // boolean is not support by the yaml FAILSAFE_SCHEMA
            md['completed?'] = note.todo_completed ? 'yes' : 'no';
        }
        if (note.todo_due) {
            md['due'] = this.convertDate(note.todo_due);
        }
        // time
        if (note.user_updated_time) {
            md['updated'] = this.convertDate(note.user_updated_time);
        }
        if (note.user_created_time) {
            md['created'] = this.convertDate(note.user_created_time);
        }
        // tags
        const context = this.context();
        if (context.noteTags[note.id]) {
            const tagIds = context.noteTags[note.id];
            const tags = tagIds.map((id) => context.tagTitles[id]).sort();
            md['tags'] = tags;
        }
        // This guarentees that fields will always be ordered the same way
        // which can be useful if users are using this for generating diffs
        const sort = (a, b) => {
            return exports.fieldOrder.indexOf(a) - exports.fieldOrder.indexOf(b);
        };
        // The FAILSAFE_SCHEMA along with noCompatMode allows this to export strings that look
        // like numbers (or yes/no) without the added '' quotes around the text
        const rawOutput = yaml.dump(md, { sortKeys: sort, noCompatMode: true, schema: yaml.FAILSAFE_SCHEMA });
        // The additional trimming is the unfortunate result of the yaml library insisting on
        // quoting negative numbers.
        // For now the trimQuotes function only trims quotes associated with a negative number
        // but it can be extended to support more special cases in the future if necessary.
        return trimQuotes(rawOutput);
    }
    getNoteExportContent_(modNote) {
        return __awaiter(this, void 0, void 0, function* () {
            const noteContent = yield Note_1.default.replaceResourceInternalToExternalLinks(yield Note_1.default.serialize(modNote, ['body']));
            const metadata = this.extractMetadata(modNote);
            return `---\n${metadata}---\n\n${noteContent}`;
        });
    }
}
exports.default = InteropService_Exporter_Md_frontmatter;
//# sourceMappingURL=InteropService_Exporter_Md_frontmatter.js.map