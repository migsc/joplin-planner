"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const InteropService_Importer_Custom_1 = require("./InteropService_Importer_Custom");
const InteropService_Exporter_Custom_1 = require("./InteropService_Exporter_Custom");
const shim_1 = require("../../shim");
const locale_1 = require("../../locale");
const BaseItem_1 = require("../../models/BaseItem");
const BaseModel_1 = require("../../BaseModel");
const Resource_1 = require("../../models/Resource");
const Folder_1 = require("../../models/Folder");
const NoteTag_1 = require("../../models/NoteTag");
const Note_1 = require("../../models/Note");
const ArrayUtils = require("../../ArrayUtils");
const { sprintf } = require('sprintf-js');
const { fileExtension } = require('../../path-utils');
const { toTitleCase } = require('../../string-utils');
const EventEmitter = require('events');
class InteropService {
    constructor() {
        this.userModules_ = [];
        this.eventEmitter_ = null;
        this.eventEmitter_ = new EventEmitter();
    }
    static instance() {
        if (!this.instance_)
            this.instance_ = new InteropService();
        return this.instance_;
    }
    on(eventName, callback) {
        return this.eventEmitter_.on(eventName, callback);
    }
    off(eventName, callback) {
        return this.eventEmitter_.removeListener(eventName, callback);
    }
    modules() {
        if (!this.defaultModules_) {
            const importModules = [
                Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(types_1.ModuleType.Importer)), { format: 'jex', fileExtensions: ['jex'], sources: [types_1.FileSystemItem.File], description: (0, locale_1._)('Joplin Export File') }),
                Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(types_1.ModuleType.Importer)), { format: 'md', fileExtensions: ['md', 'markdown', 'txt', 'html'], sources: [types_1.FileSystemItem.File, types_1.FileSystemItem.Directory], isNoteArchive: false, description: (0, locale_1._)('Markdown') }),
                Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(types_1.ModuleType.Importer)), { format: 'md_frontmatter', fileExtensions: ['md', 'markdown', 'txt', 'html'], sources: [types_1.FileSystemItem.File, types_1.FileSystemItem.Directory], isNoteArchive: false, description: (0, locale_1._)('Markdown + Front Matter') }),
                Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(types_1.ModuleType.Importer)), { format: 'raw', sources: [types_1.FileSystemItem.Directory], description: (0, locale_1._)('Joplin Export Directory') }),
                Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(types_1.ModuleType.Importer)), { format: 'enex', fileExtensions: ['enex'], sources: [types_1.FileSystemItem.File], description: (0, locale_1._)('Evernote Export File (as Markdown)'), importerClass: 'InteropService_Importer_EnexToMd', isDefault: true }),
                Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(types_1.ModuleType.Importer)), { format: 'enex', fileExtensions: ['enex'], sources: [types_1.FileSystemItem.File], description: (0, locale_1._)('Evernote Export File (as HTML)'), 
                    // TODO: Consider doing this the same way as the multiple `md` importers are handled
                    importerClass: 'InteropService_Importer_EnexToHtml', outputFormat: types_1.ImportModuleOutputFormat.Html }),
            ];
            const exportModules = [
                Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(types_1.ModuleType.Exporter)), { format: 'jex', fileExtensions: ['jex'], target: types_1.FileSystemItem.File, description: (0, locale_1._)('Joplin Export File') }),
                Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(types_1.ModuleType.Exporter)), { format: 'raw', target: types_1.FileSystemItem.Directory, description: (0, locale_1._)('Joplin Export Directory') }),
                Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(types_1.ModuleType.Exporter)), { format: 'md', target: types_1.FileSystemItem.Directory, description: (0, locale_1._)('Markdown') }),
                Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(types_1.ModuleType.Exporter)), { format: 'md_frontmatter', target: types_1.FileSystemItem.Directory, description: (0, locale_1._)('Markdown + Front Matter') }),
                Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(types_1.ModuleType.Exporter)), { format: 'html', fileExtensions: ['html', 'htm'], target: types_1.FileSystemItem.File, isNoteArchive: false, description: (0, locale_1._)('HTML File') }),
                Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(types_1.ModuleType.Exporter)), { format: 'html', target: types_1.FileSystemItem.Directory, description: (0, locale_1._)('HTML Directory') }),
            ];
            this.defaultModules_ = importModules.concat(exportModules);
        }
        return this.defaultModules_.concat(this.userModules_);
    }
    registerModule(module) {
        module = Object.assign(Object.assign({}, (0, types_1.defaultImportExportModule)(module.type)), module);
        this.userModules_.push(module);
        this.eventEmitter_.emit('modulesChanged');
    }
    // Find the module that matches the given type ("importer" or "exporter")
    // and the given format. Some formats can have multiple assocated importers
    // or exporters, such as ENEX. In this case, the one marked as "isDefault"
    // is returned. This is useful to auto-detect the module based on the format.
    // For more precise matching, newModuleFromPath_ should be used.
    findModuleByFormat_(type, format, target = null, outputFormat = null) {
        const modules = this.modules();
        const matches = [];
        for (let i = 0; i < modules.length; i++) {
            const m = modules[i];
            if (m.format === format && m.type === type) {
                if (!target && !outputFormat) {
                    matches.push(m);
                }
                else if (target && target === m.target) {
                    matches.push(m);
                }
                else if (outputFormat && outputFormat === m.outputFormat) {
                    matches.push(m);
                }
            }
        }
        const output = matches.find(m => !!m.isDefault);
        if (output)
            return output;
        return matches.length ? matches[0] : null;
    }
    modulePath(module) {
        let className = '';
        if (module.type === types_1.ModuleType.Importer) {
            className = module.importerClass || `InteropService_Importer_${toTitleCase(module.format)}`;
        }
        else {
            className = `InteropService_Exporter_${toTitleCase(module.format)}`;
        }
        return `./${className}`;
    }
    newModuleFromCustomFactory(module) {
        if (module.type === types_1.ModuleType.Importer) {
            return new InteropService_Importer_Custom_1.default(module);
        }
        else {
            return new InteropService_Exporter_Custom_1.default(module);
        }
    }
    /**
     * NOTE TO FUTURE SELF: It might make sense to simply move all the existing
     * formatters to the `newModuleFromPath_` approach, so that there's only one way
     * to do this mapping. This isn't a priority right now (per the convo in:
     * https://github.com/laurent22/joplin/pull/1795#discussion_r322379121) but
     * we can do it if it ever becomes necessary.
     */
    newModuleByFormat_(type, format, outputFormat = types_1.ImportModuleOutputFormat.Markdown) {
        const moduleMetadata = this.findModuleByFormat_(type, format, null, outputFormat);
        if (!moduleMetadata)
            throw new Error((0, locale_1._)('Cannot load "%s" module for format "%s" and output "%s"', type, format, outputFormat));
        let output = null;
        if (moduleMetadata.isCustom) {
            output = this.newModuleFromCustomFactory(moduleMetadata);
        }
        else {
            const ModuleClass = shim_1.default.requireDynamic(this.modulePath(moduleMetadata)).default;
            output = new ModuleClass();
        }
        output.setMetadata(moduleMetadata);
        return output;
    }
    /**
     * The existing `newModuleByFormat_` fn would load by the input format. This
     * was fine when there was a 1-1 mapping of input formats to output formats,
     * but now that we have 2 possible outputs for an `enex` input, we need to be
     * explicit with which importer we want to use.
     *
     * https://github.com/laurent22/joplin/pull/1795#pullrequestreview-281574417
     */
    newModuleFromPath_(type, options) {
        const moduleMetadata = this.findModuleByFormat_(type, options.format, options.target);
        if (!moduleMetadata)
            throw new Error((0, locale_1._)('Cannot load "%s" module for format "%s" and target "%s"', type, options.format, options.target));
        let output = null;
        if (moduleMetadata.isCustom) {
            output = this.newModuleFromCustomFactory(moduleMetadata);
        }
        else {
            const modulePath = this.modulePath(moduleMetadata);
            const ModuleClass = shim_1.default.requireDynamic(modulePath).default;
            output = new ModuleClass();
        }
        output.setMetadata(Object.assign({ options }, moduleMetadata));
        return output;
    }
    moduleByFileExtension_(type, ext) {
        ext = ext.toLowerCase();
        const modules = this.modules();
        for (let i = 0; i < modules.length; i++) {
            const m = modules[i];
            if (type !== m.type)
                continue;
            if (m.fileExtensions && m.fileExtensions.indexOf(ext) >= 0)
                return m;
        }
        return null;
    }
    import(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield shim_1.default.fsDriver().exists(options.path)))
                throw new Error((0, locale_1._)('Cannot find "%s".', options.path));
            options = Object.assign({ format: 'auto', destinationFolderId: null, destinationFolder: null }, options);
            if (options.format === 'auto') {
                const module = this.moduleByFileExtension_(types_1.ModuleType.Importer, fileExtension(options.path));
                if (!module)
                    throw new Error((0, locale_1._)('Please specify import format for %s', options.path));
                // eslint-disable-next-line require-atomic-updates
                options.format = module.format;
            }
            if (options.destinationFolderId) {
                const folder = yield Folder_1.default.load(options.destinationFolderId);
                if (!folder)
                    throw new Error((0, locale_1._)('Cannot find "%s".', options.destinationFolderId));
                // eslint-disable-next-line require-atomic-updates
                options.destinationFolder = folder;
            }
            let result = { warnings: [] };
            const importer = this.newModuleByFormat_(types_1.ModuleType.Importer, options.format, options.outputFormat);
            yield importer.init(options.path, options);
            result = yield importer.exec(result);
            return result;
        });
    }
    normalizeItemForExport(_itemType, item) {
        const override = {};
        if ('is_shared' in item)
            override.is_shared = 0;
        if ('share_id' in item)
            override.share_id = '';
        if (Object.keys(override).length) {
            return Object.assign(Object.assign({}, item), override);
        }
        else {
            return item;
        }
    }
    export(options) {
        return __awaiter(this, void 0, void 0, function* () {
            options = Object.assign({ format: 'jex' }, options);
            const exportPath = options.path ? options.path : null;
            let sourceFolderIds = options.sourceFolderIds ? options.sourceFolderIds : [];
            const sourceNoteIds = options.sourceNoteIds ? options.sourceNoteIds : [];
            const result = { warnings: [] };
            const itemsToExport = [];
            const queueExportItem = (itemType, itemOrId) => {
                itemsToExport.push({
                    type: itemType,
                    itemOrId: itemOrId,
                });
            };
            const exportedNoteIds = [];
            let resourceIds = [];
            // Recursively get all the folders that have valid parents
            const folderIds = yield Folder_1.default.childrenIds('');
            if (options.includeConflicts)
                folderIds.push(Folder_1.default.conflictFolderId());
            let fullSourceFolderIds = sourceFolderIds.slice();
            for (let i = 0; i < sourceFolderIds.length; i++) {
                const id = sourceFolderIds[i];
                const childrenIds = yield Folder_1.default.childrenIds(id);
                fullSourceFolderIds = fullSourceFolderIds.concat(childrenIds);
            }
            sourceFolderIds = fullSourceFolderIds;
            for (let folderIndex = 0; folderIndex < folderIds.length; folderIndex++) {
                const folderId = folderIds[folderIndex];
                if (sourceFolderIds.length && sourceFolderIds.indexOf(folderId) < 0)
                    continue;
                if (!sourceNoteIds.length)
                    yield queueExportItem(BaseModel_1.default.TYPE_FOLDER, folderId);
                const noteIds = yield Folder_1.default.noteIds(folderId, { includeConflicts: !!options.includeConflicts });
                for (let noteIndex = 0; noteIndex < noteIds.length; noteIndex++) {
                    const noteId = noteIds[noteIndex];
                    if (sourceNoteIds.length && sourceNoteIds.indexOf(noteId) < 0)
                        continue;
                    const note = yield Note_1.default.load(noteId);
                    yield queueExportItem(BaseModel_1.default.TYPE_NOTE, note);
                    exportedNoteIds.push(noteId);
                    const rids = yield Note_1.default.linkedResourceIds(note.body);
                    resourceIds = resourceIds.concat(rids);
                }
            }
            resourceIds = ArrayUtils.unique(resourceIds);
            for (let i = 0; i < resourceIds.length; i++) {
                yield queueExportItem(BaseModel_1.default.TYPE_RESOURCE, resourceIds[i]);
            }
            const noteTags = yield NoteTag_1.default.all();
            const exportedTagIds = [];
            for (let i = 0; i < noteTags.length; i++) {
                const noteTag = noteTags[i];
                if (exportedNoteIds.indexOf(noteTag.note_id) < 0)
                    continue;
                yield queueExportItem(BaseModel_1.default.TYPE_NOTE_TAG, noteTag.id);
                exportedTagIds.push(noteTag.tag_id);
            }
            for (let i = 0; i < exportedTagIds.length; i++) {
                yield queueExportItem(BaseModel_1.default.TYPE_TAG, exportedTagIds[i]);
            }
            const exporter = this.newModuleFromPath_(types_1.ModuleType.Exporter, options);
            yield exporter.init(exportPath, options);
            const typeOrder = [BaseModel_1.default.TYPE_FOLDER, BaseModel_1.default.TYPE_RESOURCE, BaseModel_1.default.TYPE_NOTE, BaseModel_1.default.TYPE_TAG, BaseModel_1.default.TYPE_NOTE_TAG];
            const context = {
                resourcePaths: {},
            };
            // Prepare to process each type before starting any
            // This will allow exporters to operate on the full context
            for (let typeOrderIndex = 0; typeOrderIndex < typeOrder.length; typeOrderIndex++) {
                const type = typeOrder[typeOrderIndex];
                yield exporter.prepareForProcessingItemType(type, itemsToExport);
            }
            for (let typeOrderIndex = 0; typeOrderIndex < typeOrder.length; typeOrderIndex++) {
                const type = typeOrder[typeOrderIndex];
                for (let i = 0; i < itemsToExport.length; i++) {
                    const itemType = itemsToExport[i].type;
                    if (itemType !== type)
                        continue;
                    const ItemClass = BaseItem_1.default.getClassByItemType(itemType);
                    const itemOrId = itemsToExport[i].itemOrId;
                    const rawItem = typeof itemOrId === 'object' ? itemOrId : yield ItemClass.load(itemOrId);
                    if (!rawItem) {
                        if (itemType === BaseModel_1.default.TYPE_RESOURCE) {
                            result.warnings.push(sprintf('A resource that does not exist is referenced in a note. The resource was skipped. Resource ID: %s', itemOrId));
                        }
                        else {
                            result.warnings.push(sprintf('Cannot find item with type "%s" and ID %s. Item was skipped.', ItemClass.tableName(), JSON.stringify(itemOrId)));
                        }
                        continue;
                    }
                    const item = this.normalizeItemForExport(itemType, rawItem);
                    if (item.encryption_applied || item.encryption_blob_encrypted) {
                        result.warnings.push(sprintf('This item is currently encrypted: %s "%s" (%s) and was not exported. You may wait for it to be decrypted and try again.', BaseModel_1.default.modelTypeToName(itemType), item.title ? item.title : item.id, item.id));
                        continue;
                    }
                    try {
                        if (itemType === BaseModel_1.default.TYPE_RESOURCE) {
                            const resourcePath = Resource_1.default.fullPath(item);
                            context.resourcePaths[item.id] = resourcePath;
                            exporter.updateContext(context);
                            yield exporter.processResource(item, resourcePath);
                        }
                        yield exporter.processItem(itemType, item);
                    }
                    catch (error) {
                        console.error(error);
                        result.warnings.push(error.message);
                    }
                }
            }
            yield exporter.close();
            return result;
        });
    }
}
exports.default = InteropService;
//# sourceMappingURL=InteropService.js.map