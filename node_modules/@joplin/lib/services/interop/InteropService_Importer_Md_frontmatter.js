"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const InteropService_Importer_Md_1 = require("./InteropService_Importer_Md");
const Note_1 = require("../../models/Note");
const Tag_1 = require("../../models/Tag");
const time_1 = require("../../time");
const yaml = require("js-yaml");
function isTruthy(str) {
    return str.toLowerCase() in ['true', 'yes'];
}
// Enforces exactly 2 spaces in front of list items
function normalizeYamlWhitespace(yaml) {
    return yaml.map(line => {
        const l = line.trimStart();
        if (l.startsWith('-')) {
            return `  ${l}`;
        }
        return line;
    });
}
// This is a helper functon to convert an arbitrary author variable into a string
// the use case is for loading from r-markdown/pandoc style notes
// references:
// https://pandoc.org/MANUAL.html#extension-yaml_metadata_block
// https://github.com/hao203/rmarkdown-YAML
function extractAuthor(author) {
    if (!author)
        return '';
    if (typeof (author) === 'string') {
        return author;
    }
    else if (Array.isArray(author)) {
        // Joplin only supports a single author, so we take the first one
        return extractAuthor(author[0]);
    }
    else if (typeof (author) === 'object') {
        if ('name' in author) {
            return author['name'];
        }
    }
    return '';
}
class InteropService_Importer_Md_frontmatter extends InteropService_Importer_Md_1.default {
    getNoteHeader(note) {
        // Ignore the leading `---`
        const lines = note.split('\n').slice(1);
        let inHeader = true;
        const headerLines = [];
        const bodyLines = [];
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (inHeader && line.startsWith('---')) {
                inHeader = false;
                i++; // Need to eat the extra newline after the yaml block
                continue;
            }
            if (inHeader) {
                headerLines.push(line);
            }
            else {
                bodyLines.push(line);
            }
        }
        const normalizedHeaderLines = normalizeYamlWhitespace(headerLines);
        const header = normalizedHeaderLines.join('\n');
        const body = bodyLines.join('\n');
        return { header, body };
    }
    toLowerCase(obj) {
        const newObj = {};
        for (const key of Object.keys(obj)) {
            newObj[key.toLowerCase()] = obj[key];
        }
        return newObj;
    }
    parseYamlNote(note) {
        if (!note.startsWith('---'))
            return { metadata: { body: note }, tags: [] };
        const { header, body } = this.getNoteHeader(note);
        const md = this.toLowerCase(yaml.load(header, { schema: yaml.FAILSAFE_SCHEMA }));
        const metadata = {
            title: md['title'] || '',
            source_url: md['source'] || '',
            is_todo: ('completed?' in md) ? 1 : 0,
        };
        if ('author' in md) {
            metadata['author'] = extractAuthor(md['author']);
        }
        // The date fallback gives support for MultiMarkdown format, r-markdown, and pandoc formats
        if ('created' in md) {
            metadata['user_created_time'] = time_1.default.anythingToMs(md['created'], Date.now());
        }
        else if ('date' in md) {
            metadata['user_created_time'] = time_1.default.anythingToMs(md['date'], Date.now());
        }
        if ('updated' in md) {
            metadata['user_updated_time'] = time_1.default.anythingToMs(md['updated'], Date.now());
        }
        else if ('lastmod' in md) {
            // Add support for hugo
            metadata['user_updated_time'] = time_1.default.anythingToMs(md['lastmod'], Date.now());
        }
        else if ('date' in md) {
            metadata['user_updated_time'] = time_1.default.anythingToMs(md['date'], Date.now());
        }
        if ('latitude' in md) {
            metadata['latitude'] = md['latitude'];
        }
        if ('longitude' in md) {
            metadata['longitude'] = md['longitude'];
        }
        if ('altitude' in md) {
            metadata['altitude'] = md['altitude'];
        }
        if (metadata.is_todo) {
            if (isTruthy(md['completed?'])) {
                // Completed time isn't preserved, so we use a sane choice here
                metadata['todo_completed'] = metadata['user_updated_time'];
            }
            if ('due' in md) {
                const due_date = time_1.default.anythingToMs(md['due'], null);
                if (due_date) {
                    metadata['todo_due'] = due_date;
                }
            }
        }
        // Tags are handled seperately from typical metadata
        let tags = [];
        if ('tags' in md) {
            // Only create unique tags
            tags = md['tags'];
        }
        else if ('keywords' in md) {
            // Adding support for r-markdown/pandoc
            tags = tags.concat(md['keywords']);
        }
        // Only create unique tags
        tags = [...new Set(tags)];
        metadata['body'] = body;
        return { metadata, tags };
    }
    importFile(filePath, parentFolderId) {
        const _super = Object.create(null, {
            importFile: { get: () => super.importFile }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const note = yield _super.importFile.call(this, filePath, parentFolderId);
            const { metadata, tags } = this.parseYamlNote(note.body);
            const updatedNote = Object.assign({}, note, metadata);
            const noteItem = yield Note_1.default.save(updatedNote, { isNew: false, autoTimestamp: false });
            for (const tag of tags) {
                yield Tag_1.default.addNoteTagByTitle(noteItem.id, tag);
            }
            return noteItem;
        });
    }
}
exports.default = InteropService_Importer_Md_frontmatter;
//# sourceMappingURL=InteropService_Importer_Md_frontmatter.js.map