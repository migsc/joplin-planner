"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const InteropService_Exporter_Base_1 = require("./InteropService_Exporter_Base");
const BaseModel_1 = require("../../BaseModel");
const shim_1 = require("../../shim");
const markdownUtils_1 = require("../../markdownUtils");
const Folder_1 = require("../../models/Folder");
const Note_1 = require("../../models/Note");
const path_utils_1 = require("../../path-utils");
const renderer_1 = require("@joplin/renderer");
class InteropService_Exporter_Md extends InteropService_Exporter_Base_1.default {
    init(destDir) {
        return __awaiter(this, void 0, void 0, function* () {
            this.destDir_ = destDir;
            this.resourceDir_ = destDir ? `${destDir}/_resources` : null;
            this.createdDirs_ = [];
            yield shim_1.default.fsDriver().mkdir(this.destDir_);
            yield shim_1.default.fsDriver().mkdir(this.resourceDir_);
        });
    }
    makeDirPath_(item, pathPart = null, findUniqueFilename = true) {
        return __awaiter(this, void 0, void 0, function* () {
            let output = '';
            while (true) {
                if (item.type_ === BaseModel_1.default.TYPE_FOLDER) {
                    if (pathPart) {
                        output = `${pathPart}/${output}`;
                    }
                    else {
                        output = `${(0, path_utils_1.friendlySafeFilename)(item.title, null)}/${output}`;
                        if (findUniqueFilename)
                            output = yield shim_1.default.fsDriver().findUniqueFilename(output, null, true);
                    }
                }
                if (!item.parent_id)
                    return output;
                item = yield Folder_1.default.load(item.parent_id);
            }
        });
    }
    relaceLinkedItemIdsByRelativePaths_(item) {
        return __awaiter(this, void 0, void 0, function* () {
            const relativePathToRoot = yield this.makeDirPath_(item, '..');
            const newBody = yield this.replaceResourceIdsByRelativePaths_(item.body, relativePathToRoot);
            return yield this.replaceNoteIdsByRelativePaths_(newBody, relativePathToRoot);
        });
    }
    replaceResourceIdsByRelativePaths_(noteBody, relativePathToRoot) {
        return __awaiter(this, void 0, void 0, function* () {
            const linkedResourceIds = yield Note_1.default.linkedResourceIds(noteBody);
            const resourcePaths = this.context() && this.context().destResourcePaths ? this.context().destResourcePaths : {};
            const createRelativePath = function (resourcePath) {
                return `${relativePathToRoot}_resources/${(0, path_utils_1.basename)(resourcePath)}`;
            };
            return yield this.replaceItemIdsByRelativePaths_(noteBody, linkedResourceIds, resourcePaths, createRelativePath);
        });
    }
    replaceNoteIdsByRelativePaths_(noteBody, relativePathToRoot) {
        return __awaiter(this, void 0, void 0, function* () {
            const linkedNoteIds = yield Note_1.default.linkedNoteIds(noteBody);
            const notePaths = this.context() && this.context().notePaths ? this.context().notePaths : {};
            const createRelativePath = function (notePath) {
                return markdownUtils_1.default.escapeLinkUrl(`${relativePathToRoot}${notePath}`.trim());
            };
            return yield this.replaceItemIdsByRelativePaths_(noteBody, linkedNoteIds, notePaths, createRelativePath);
        });
    }
    replaceItemIdsByRelativePaths_(noteBody, linkedItemIds, paths, fn_createRelativePath) {
        return __awaiter(this, void 0, void 0, function* () {
            let newBody = noteBody;
            for (let i = 0; i < linkedItemIds.length; i++) {
                const id = linkedItemIds[i];
                const itemPath = fn_createRelativePath(paths[id]);
                newBody = newBody.replace(new RegExp(`:/${id}`, 'g'), itemPath);
            }
            return newBody;
        });
    }
    prepareForProcessingItemType(itemType, itemsToExport) {
        return __awaiter(this, void 0, void 0, function* () {
            if (itemType === BaseModel_1.default.TYPE_NOTE) {
                // Create unique file path for the note
                const context = {
                    notePaths: {},
                };
                for (let i = 0; i < itemsToExport.length; i++) {
                    const it = itemsToExport[i].type;
                    if (it !== itemType)
                        continue;
                    const itemOrId = itemsToExport[i].itemOrId;
                    const note = typeof itemOrId === 'object' ? itemOrId : yield Note_1.default.load(itemOrId);
                    if (!note)
                        continue;
                    const ext = note.markup_language === renderer_1.MarkupToHtml.MARKUP_LANGUAGE_HTML ? 'html' : 'md';
                    let notePath = `${yield this.makeDirPath_(note, null, false)}${(0, path_utils_1.friendlySafeFilename)(note.title, null)}.${ext}`;
                    notePath = yield shim_1.default.fsDriver().findUniqueFilename(`${this.destDir_}/${notePath}`, Object.values(context.notePaths), true);
                    context.notePaths[note.id] = notePath;
                }
                // Strip the absolute path to export dir and keep only the relative paths
                const destDir = this.destDir_;
                Object.keys(context.notePaths).map(function (id) {
                    context.notePaths[id] = context.notePaths[id].substr(destDir.length + 1);
                });
                this.updateContext(context);
            }
        });
    }
    getNoteExportContent_(modNote) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield Note_1.default.replaceResourceInternalToExternalLinks(yield Note_1.default.serialize(modNote, ['body']));
        });
    }
    processItem(_itemType, item) {
        return __awaiter(this, void 0, void 0, function* () {
            if ([BaseModel_1.default.TYPE_NOTE, BaseModel_1.default.TYPE_FOLDER].indexOf(item.type_) < 0)
                return;
            if (item.type_ === BaseModel_1.default.TYPE_FOLDER) {
                const dirPath = `${this.destDir_}/${yield this.makeDirPath_(item)}`;
                if (this.createdDirs_.indexOf(dirPath) < 0) {
                    yield shim_1.default.fsDriver().mkdir(dirPath);
                    this.createdDirs_.push(dirPath);
                }
            }
            else if (item.type_ === BaseModel_1.default.TYPE_NOTE) {
                const notePaths = this.context() && this.context().notePaths ? this.context().notePaths : {};
                const noteFilePath = `${this.destDir_}/${notePaths[item.id]}`;
                const noteBody = yield this.relaceLinkedItemIdsByRelativePaths_(item);
                const modNote = Object.assign({}, item, { body: noteBody });
                const noteContent = yield this.getNoteExportContent_(modNote);
                yield shim_1.default.fsDriver().mkdir((0, path_utils_1.dirname)(noteFilePath));
                yield shim_1.default.fsDriver().writeFile(noteFilePath, noteContent, 'utf-8');
            }
        });
    }
    findReasonableFilename(resource, filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            let fileName = (0, path_utils_1.basename)(filePath);
            if (resource.filename) {
                fileName = resource.filename;
            }
            else if (resource.title) {
                fileName = (0, path_utils_1.friendlySafeFilename)(resource.title, null, true);
            }
            // Fall back on the resource filename saved in the users resource folder
            return fileName;
        });
    }
    processResource(resource, filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = this.context();
            if (!context.destResourcePaths)
                context.destResourcePaths = {};
            const fileName = yield this.findReasonableFilename(resource, filePath);
            let destResourcePath = `${this.resourceDir_}/${fileName}`;
            destResourcePath = yield shim_1.default.fsDriver().findUniqueFilename(destResourcePath, Object.values(context.destResourcePaths), true);
            yield shim_1.default.fsDriver().copy(filePath, destResourcePath);
            context.destResourcePaths[resource.id] = destResourcePath;
            this.updateContext(context);
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
}
exports.default = InteropService_Exporter_Md;
//# sourceMappingURL=InteropService_Exporter_Md.js.map