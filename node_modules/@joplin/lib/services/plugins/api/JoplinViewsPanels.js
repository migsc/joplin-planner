"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const createViewHandle_1 = require("../utils/createViewHandle");
const WebviewController_1 = require("../WebviewController");
/**
 * Allows creating and managing view panels. View panels currently are
 * displayed at the right of the sidebar and allows displaying any HTML
 * content (within a webview) and update it in real-time. For example it
 * could be used to display a table of content for the active note, or
 * display various metadata or graph.
 *
 * [View the demo plugin](https://github.com/laurent22/joplin/tree/dev/packages/app-cli/tests/support/plugins/toc)
 */
class JoplinViewsPanels {
    constructor(plugin, store) {
        this.store = store;
        this.plugin = plugin;
    }
    controller(handle) {
        return this.plugin.viewController(handle);
    }
    /**
     * Creates a new panel
     */
    create(id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!id) {
                this.plugin.deprecationNotice('1.5', 'Creating a view without an ID is deprecated. To fix it, change your call to `joplin.views.panels.create("my-unique-id")`', true);
                id = `${this.plugin.viewCount}`;
            }
            const handle = (0, createViewHandle_1.default)(this.plugin, id);
            const controller = new WebviewController_1.default(handle, this.plugin.id, this.store, this.plugin.baseDir, WebviewController_1.ContainerType.Panel);
            this.plugin.addViewController(controller);
            return handle;
        });
    }
    /**
     * Sets the panel webview HTML
     */
    setHtml(handle, html) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.controller(handle).html = html;
        });
    }
    /**
     * Adds and loads a new JS or CSS files into the panel.
     */
    addScript(handle, scriptPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.controller(handle).addScript(scriptPath);
        });
    }
    /**
     * Called when a message is sent from the webview (using postMessage).
     *
     * To post a message from the webview to the plugin use:
     *
     * ```javascript
     * const response = await webviewApi.postMessage(message);
     * ```
     *
     * - `message` can be any JavaScript object, string or number
     * - `response` is whatever was returned by the `onMessage` handler
     *
     * Using this mechanism, you can have two-way communication between the
     * plugin and webview.
     *
     * See the [postMessage
     * demo](https://github.com/laurent22/joplin/tree/dev/packages/app-cli/tests/support/plugins/post_messages) for more details.
     *
     */
    onMessage(handle, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.controller(handle).onMessage(callback);
        });
    }
    /**
     * Sends a message to the webview.
     *
     * The webview must have registered a message handler prior, otherwise the message is ignored. Use;
     *
     * ```javascript
     * webviewApi.onMessage((message) => { ... });
     * ```
     *
     *  - `message` can be any JavaScript object, string or number
     *
     * The view API may have only one onMessage handler defined.
     * This method is fire and forget so no response is returned.
     *
     * It is particularly useful when the webview needs to react to events emitted by the plugin or the joplin api.
     */
    postMessage(handle, message) {
        return this.controller(handle).postMessage(message);
    }
    /**
     * Shows the panel
     */
    show(handle, show = true) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.controller(handle).show(show);
        });
    }
    /**
     * Hides the panel
     */
    hide(handle) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.show(handle, false);
        });
    }
    /**
     * Tells whether the panel is visible or not
     */
    visible(handle) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.controller(handle).visible;
        });
    }
}
exports.default = JoplinViewsPanels;
//# sourceMappingURL=JoplinViewsPanels.js.map