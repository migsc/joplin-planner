"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseModel_1 = require("../../../BaseModel");
const eventManager_1 = require("../../../eventManager");
const Setting_1 = require("../../../models/Setting");
const makeListener_1 = require("../utils/makeListener");
/**
 * @ignore
 */
const Note_1 = require("../../../models/Note");
/**
 * @ignore
 */
const Folder_1 = require("../../../models/Folder");
var ItemChangeEventType;
(function (ItemChangeEventType) {
    ItemChangeEventType[ItemChangeEventType["Create"] = 1] = "Create";
    ItemChangeEventType[ItemChangeEventType["Update"] = 2] = "Update";
    ItemChangeEventType[ItemChangeEventType["Delete"] = 3] = "Delete";
})(ItemChangeEventType || (ItemChangeEventType = {}));
/**
 * The workspace service provides access to all the parts of Joplin that
 * are being worked on - i.e. the currently selected notes or notebooks as
 * well as various related events, such as when a new note is selected, or
 * when the note content changes.
 *
 * [View the demo plugin](https://github.com/laurent22/joplin/tree/dev/packages/app-cli/tests/support/plugins)
 */
class JoplinWorkspace {
    constructor(store) {
        this.store = store;
    }
    /**
     * Called when a new note or notes are selected.
     */
    onNoteSelectionChange(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            eventManager_1.default.appStateOn('selectedNoteIds', callback);
            return {};
            // return {
            // 	dispose: () => {
            // 		eventManager.appStateOff('selectedNoteIds', callback);
            // 	}
            // };
        });
    }
    /**
     * Called when the content of a note changes.
     * @deprecated Use `onNoteChange()` instead, which is reliably triggered whenever the note content, or any note property changes.
     */
    onNoteContentChange(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            eventManager_1.default.on('noteContentChange', callback);
        });
    }
    /**
     * Called when the content of the current note changes.
     */
    onNoteChange(handler) {
        return __awaiter(this, void 0, void 0, function* () {
            const wrapperHandler = (event) => {
                if (event.itemType !== BaseModel_1.ModelType.Note)
                    return;
                if (!this.store.getState().selectedNoteIds.includes(event.itemId))
                    return;
                handler({
                    id: event.itemId,
                    event: event.eventType,
                });
            };
            return (0, makeListener_1.default)(eventManager_1.default, 'itemChange', wrapperHandler);
        });
    }
    /**
     * Called when a resource is changed. Currently this handled will not be
     * called when a resource is added or deleted.
     */
    onResourceChange(handler) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, makeListener_1.default)(eventManager_1.default, 'resourceChange', handler);
        });
    }
    /**
     * Called when an alarm associated with a to-do is triggered.
     */
    onNoteAlarmTrigger(handler) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, makeListener_1.default)(eventManager_1.default, 'noteAlarmTrigger', handler);
        });
    }
    /**
     * Called when the synchronisation process is starting.
     */
    onSyncStart(handler) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, makeListener_1.default)(eventManager_1.default, 'syncStart', handler);
        });
    }
    /**
     * Called when the synchronisation process has finished.
     */
    onSyncComplete(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, makeListener_1.default)(eventManager_1.default, 'syncComplete', callback);
        });
    }
    /**
     * Called just before the editor context menu is about to open. Allows
     * adding items to it.
     */
    filterEditorContextMenu(handler) {
        eventManager_1.default.filterOn('editorContextMenu', handler);
    }
    /**
     * Gets the currently selected note
     */
    selectedNote() {
        return __awaiter(this, void 0, void 0, function* () {
            const noteIds = this.store.getState().selectedNoteIds;
            if (noteIds.length !== 1) {
                return null;
            }
            return Note_1.default.load(noteIds[0]);
        });
    }
    /**
     * Gets the currently selected folder. In some cases, for example during
     * search or when viewing a tag, no folder is actually selected in the user
     * interface. In that case, that function would return the last selected
     * folder.
     */
    selectedFolder() {
        return __awaiter(this, void 0, void 0, function* () {
            const folderId = Setting_1.default.value('activeFolderId');
            return folderId ? yield Folder_1.default.load(folderId) : null;
        });
    }
    /**
     * Gets the IDs of the selected notes (can be zero, one, or many). Use the data API to retrieve information about these notes.
     */
    selectedNoteIds() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.store.getState().selectedNoteIds.slice();
        });
    }
}
exports.default = JoplinWorkspace;
//# sourceMappingURL=JoplinWorkspace.js.map