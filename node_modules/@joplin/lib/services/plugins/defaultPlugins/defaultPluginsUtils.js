"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateDefaultPluginsInstallState = exports.getDefaultPluginsInstallState = exports.setSettingsForDefaultPlugins = exports.installDefaultPlugins = exports.checkPreInstalledDefaultPlugins = void 0;
const immer_1 = require("immer");
const path = require("path");
const Setting_1 = require("../../../models/Setting");
const shim_1 = require("../../../shim");
const PluginService_1 = require("../PluginService");
const Logger_1 = require("@joplin/lib/Logger");
const shared = require('@joplin/lib/components/shared/config-shared.js');
const logger = Logger_1.default.create('defaultPluginsUtils');
function checkPreInstalledDefaultPlugins(defaultPluginsId, pluginSettings) {
    const installedDefaultPlugins = Setting_1.default.value('installedDefaultPlugins');
    for (const pluginId of defaultPluginsId) {
        // if pluginId is present in pluginSettings and not in installedDefaultPlugins array,
        // then its either pre-installed by user or just uninstalled
        if (pluginSettings[pluginId] && !installedDefaultPlugins.includes(pluginId))
            Setting_1.default.setArrayValue('installedDefaultPlugins', pluginId);
    }
}
exports.checkPreInstalledDefaultPlugins = checkPreInstalledDefaultPlugins;
function installDefaultPlugins(service, defaultPluginsDir, defaultPluginsId, pluginSettings) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(yield shim_1.default.fsDriver().exists(defaultPluginsDir))) {
            logger.info(`Could not find default plugins' directory: ${defaultPluginsDir} - skipping installation.`);
            return pluginSettings;
        }
        const defaultPluginsPaths = yield shim_1.default.fsDriver().readDirStats(defaultPluginsDir);
        if (defaultPluginsPaths.length <= 0) {
            logger.info(`Default plugins' directory is empty: ${defaultPluginsDir} - skipping installation.`);
            return pluginSettings;
        }
        const installedPlugins = Setting_1.default.value('installedDefaultPlugins');
        for (let pluginId of defaultPluginsPaths) {
            pluginId = pluginId.path;
            // if pluginId is present in 'installedDefaultPlugins' array or it doesn't have default plugin ID, then we won't install it again as default plugin
            if (installedPlugins.includes(pluginId) || !defaultPluginsId.includes(pluginId))
                continue;
            const defaultPluginPath = path.join(defaultPluginsDir, pluginId, 'plugin.jpl');
            yield service.installPlugin(defaultPluginPath, false);
            pluginSettings = (0, immer_1.default)(pluginSettings, (draft) => {
                draft[pluginId] = (0, PluginService_1.defaultPluginSetting)();
            });
        }
        return pluginSettings;
    });
}
exports.installDefaultPlugins = installDefaultPlugins;
function setSettingsForDefaultPlugins(defaultPluginsInfo) {
    const installedDefaultPlugins = Setting_1.default.value('installedDefaultPlugins');
    // only set initial settings if the plugin is not present in installedDefaultPlugins array
    for (const pluginId of Object.keys(defaultPluginsInfo)) {
        if (!defaultPluginsInfo[pluginId].settings)
            continue;
        for (const settingName of Object.keys(defaultPluginsInfo[pluginId].settings)) {
            if (!installedDefaultPlugins.includes(pluginId) && Setting_1.default.keyExists(`plugin-${pluginId}.${settingName}`)) {
                Setting_1.default.setValue(`plugin-${pluginId}.${settingName}`, defaultPluginsInfo[pluginId].settings[settingName]);
            }
        }
    }
}
exports.setSettingsForDefaultPlugins = setSettingsForDefaultPlugins;
function getDefaultPluginsInstallState(service, defaultPluginsId) {
    const settings = {};
    for (const pluginId of defaultPluginsId) {
        if (!service.pluginIds.includes(pluginId))
            continue;
        if (!Setting_1.default.setArrayValue('installedDefaultPlugins', pluginId)) {
            settings[pluginId] = (0, PluginService_1.defaultPluginSetting)();
        }
    }
    return settings;
}
exports.getDefaultPluginsInstallState = getDefaultPluginsInstallState;
function updateDefaultPluginsInstallState(newPluginStates, ConfigScreen) {
    if (Object.keys(newPluginStates).length === 0)
        return;
    const key = 'plugins.states';
    const md = Setting_1.default.settingMetadata(key);
    let newValue = Setting_1.default.value('plugins.states');
    newValue = Object.assign(Object.assign({}, newValue), newPluginStates);
    shared.updateSettingValue(ConfigScreen, key, newValue);
    if (md.autoSave) {
        shared.scheduleSaveSettings(ConfigScreen);
    }
}
exports.updateDefaultPluginsInstallState = updateDefaultPluginsInstallState;
//# sourceMappingURL=defaultPluginsUtils.js.map