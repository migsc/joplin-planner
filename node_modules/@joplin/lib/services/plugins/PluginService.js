"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultPluginSetting = void 0;
const Plugin_1 = require("./Plugin");
const manifestFromObject_1 = require("./utils/manifestFromObject");
const Global_1 = require("./api/Global");
const BaseService_1 = require("../BaseService");
const shim_1 = require("../../shim");
const path_utils_1 = require("../../path-utils");
const Setting_1 = require("../../models/Setting");
const Logger_1 = require("../../Logger");
const immer_1 = require("immer");
const compareVersions = require('compare-versions');
const uslug = require('@joplin/fork-uslug');
const logger = Logger_1.default.create('PluginService');
function defaultPluginSetting() {
    return {
        enabled: true,
        deleted: false,
        hasBeenUpdated: false,
    };
}
exports.defaultPluginSetting = defaultPluginSetting;
function makePluginId(source) {
    // https://www.npmjs.com/package/slug#options
    return uslug(source).substr(0, 32);
}
class PluginService extends BaseService_1.default {
    constructor() {
        super(...arguments);
        this.store_ = null;
        this.platformImplementation_ = null;
        this.plugins_ = {};
        this.runner_ = null;
        this.startedPlugins_ = {};
        this.isSafeMode_ = false;
    }
    static instance() {
        if (!this.instance_) {
            this.instance_ = new PluginService();
        }
        return this.instance_;
    }
    initialize(appVersion, platformImplementation, runner, store) {
        this.appVersion_ = appVersion;
        this.store_ = store;
        this.runner_ = runner;
        this.platformImplementation_ = platformImplementation;
    }
    get plugins() {
        return this.plugins_;
    }
    get pluginIds() {
        return Object.keys(this.plugins_);
    }
    get isSafeMode() {
        return this.isSafeMode_;
    }
    set isSafeMode(v) {
        this.isSafeMode_ = v;
    }
    setPluginAt(pluginId, plugin) {
        this.plugins_ = Object.assign(Object.assign({}, this.plugins_), { [pluginId]: plugin });
    }
    deletePluginAt(pluginId) {
        if (!this.plugins_[pluginId])
            return;
        this.plugins_ = Object.assign({}, this.plugins_);
        delete this.plugins_[pluginId];
    }
    deletePluginFiles(plugin) {
        return __awaiter(this, void 0, void 0, function* () {
            yield shim_1.default.fsDriver().remove(plugin.baseDir);
        });
    }
    pluginById(id) {
        if (!this.plugins_[id])
            throw new Error(`Plugin not found: ${id}`);
        return this.plugins_[id];
    }
    unserializePluginSettings(settings) {
        const output = Object.assign({}, settings);
        for (const pluginId in output) {
            output[pluginId] = Object.assign(Object.assign({}, defaultPluginSetting()), output[pluginId]);
        }
        return output;
    }
    serializePluginSettings(settings) {
        return JSON.stringify(settings);
    }
    pluginIdByContentScriptId(contentScriptId) {
        for (const pluginId in this.plugins_) {
            const plugin = this.plugins_[pluginId];
            const contentScript = plugin.contentScriptById(contentScriptId);
            if (contentScript)
                return pluginId;
        }
        return null;
    }
    parsePluginJsBundle(jsBundleString) {
        return __awaiter(this, void 0, void 0, function* () {
            const scriptText = jsBundleString;
            const lines = scriptText.split('\n');
            const manifestText = [];
            const StateStarted = 1;
            const StateInManifest = 2;
            let state = StateStarted;
            for (let line of lines) {
                line = line.trim();
                if (state !== StateInManifest) {
                    if (line === '/* joplin-manifest:') {
                        state = StateInManifest;
                    }
                    continue;
                }
                if (state === StateInManifest) {
                    if (line.indexOf('*/') === 0) {
                        break;
                    }
                    else {
                        manifestText.push(line);
                    }
                }
            }
            if (!manifestText.length)
                throw new Error('Could not find manifest');
            return {
                scriptText: scriptText,
                manifestText: manifestText.join('\n'),
            };
        });
    }
    loadPluginFromJsBundle(baseDir, jsBundleString, pluginIdIfNotSpecified = '') {
        return __awaiter(this, void 0, void 0, function* () {
            baseDir = (0, path_utils_1.rtrimSlashes)(baseDir);
            const r = yield this.parsePluginJsBundle(jsBundleString);
            return this.loadPlugin(baseDir, r.manifestText, r.scriptText, pluginIdIfNotSpecified);
        });
    }
    loadPluginFromPackage(baseDir, path) {
        return __awaiter(this, void 0, void 0, function* () {
            baseDir = (0, path_utils_1.rtrimSlashes)(baseDir);
            const fname = (0, path_utils_1.filename)(path);
            const hash = yield shim_1.default.fsDriver().md5File(path);
            const unpackDir = `${Setting_1.default.value('cacheDir')}/${fname}`;
            const manifestFilePath = `${unpackDir}/manifest.json`;
            let manifest = yield this.loadManifestToObject(manifestFilePath);
            if (!manifest || manifest._package_hash !== hash) {
                yield shim_1.default.fsDriver().remove(unpackDir);
                yield shim_1.default.fsDriver().mkdir(unpackDir);
                yield shim_1.default.fsDriver().tarExtract({
                    strict: true,
                    portable: true,
                    file: path,
                    cwd: unpackDir,
                });
                manifest = yield this.loadManifestToObject(manifestFilePath);
                if (!manifest)
                    throw new Error(`Missing manifest file at: ${manifestFilePath}`);
                manifest._package_hash = hash;
                yield shim_1.default.fsDriver().writeFile(manifestFilePath, JSON.stringify(manifest, null, '\t'), 'utf8');
            }
            return this.loadPluginFromPath(unpackDir);
        });
    }
    // Loads the manifest as a simple object with no validation. Used only
    // when unpacking a package.
    loadManifestToObject(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const manifestText = yield shim_1.default.fsDriver().readFile(path, 'utf8');
                return JSON.parse(manifestText);
            }
            catch (error) {
                return null;
            }
        });
    }
    loadPluginFromPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            path = (0, path_utils_1.rtrimSlashes)(path);
            const fsDriver = shim_1.default.fsDriver();
            if (path.toLowerCase().endsWith('.js')) {
                return this.loadPluginFromJsBundle((0, path_utils_1.dirname)(path), yield fsDriver.readFile(path), (0, path_utils_1.filename)(path));
            }
            else if (path.toLowerCase().endsWith('.jpl')) {
                return this.loadPluginFromPackage((0, path_utils_1.dirname)(path), path);
            }
            else {
                let distPath = path;
                if (!(yield fsDriver.exists(`${distPath}/manifest.json`))) {
                    distPath = `${path}/dist`;
                }
                logger.info(`Loading plugin from ${path}`);
                const scriptText = yield fsDriver.readFile(`${distPath}/index.js`);
                const manifestText = yield fsDriver.readFile(`${distPath}/manifest.json`);
                const pluginId = makePluginId((0, path_utils_1.filename)(path));
                return this.loadPlugin(distPath, manifestText, scriptText, pluginId);
            }
        });
    }
    loadPlugin(baseDir, manifestText, scriptText, pluginIdIfNotSpecified) {
        return __awaiter(this, void 0, void 0, function* () {
            baseDir = (0, path_utils_1.rtrimSlashes)(baseDir);
            const manifestObj = JSON.parse(manifestText);
            const deprecationNotices = [];
            if (!manifestObj.app_min_version) {
                manifestObj.app_min_version = '1.4';
                deprecationNotices.push({
                    message: 'The manifest must contain an "app_min_version" key, which should be the minimum version of the app you support.',
                    goneInVersion: '1.4',
                    isError: true,
                });
            }
            if (!manifestObj.id) {
                manifestObj.id = pluginIdIfNotSpecified;
                deprecationNotices.push({
                    message: 'The manifest must contain an "id" key, which should be a globally unique ID for your plugin, such as "com.example.MyPlugin" or a UUID.',
                    goneInVersion: '1.4',
                    isError: true,
                });
            }
            const manifest = (0, manifestFromObject_1.default)(manifestObj);
            const dataDir = `${Setting_1.default.value('pluginDataDir')}/${manifest.id}`;
            const plugin = new Plugin_1.default(baseDir, manifest, scriptText, (action) => this.store_.dispatch(action), dataDir);
            for (const notice of deprecationNotices) {
                plugin.deprecationNotice(notice.goneInVersion, notice.message, notice.isError);
            }
            // Sanity check, although at that point the plugin ID should have
            // been set, either automatically, or because it was defined in the
            // manifest.
            if (!plugin.id)
                throw new Error('Could not load plugin: ID is not set');
            return plugin;
        });
    }
    pluginEnabled(settings, pluginId) {
        if (!settings[pluginId])
            return true;
        return settings[pluginId].enabled !== false;
    }
    callStatsSummary(pluginId, duration) {
        return this.runner_.callStatsSummary(pluginId, duration);
    }
    loadAndRunPlugins(pluginDirOrPaths, settings, devMode = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let pluginPaths = [];
            if (Array.isArray(pluginDirOrPaths)) {
                pluginPaths = pluginDirOrPaths;
            }
            else {
                pluginPaths = (yield shim_1.default.fsDriver().readDirStats(pluginDirOrPaths))
                    .filter((stat) => {
                    if (stat.isDirectory())
                        return true;
                    if (stat.path.toLowerCase().endsWith('.js'))
                        return true;
                    if (stat.path.toLowerCase().endsWith('.jpl'))
                        return true;
                    return false;
                })
                    .map((stat) => `${pluginDirOrPaths}/${stat.path}`);
            }
            for (const pluginPath of pluginPaths) {
                if ((0, path_utils_1.filename)(pluginPath).indexOf('_') === 0) {
                    logger.info(`Plugin name starts with "_" and has not been loaded: ${pluginPath}`);
                    continue;
                }
                try {
                    const plugin = yield this.loadPluginFromPath(pluginPath);
                    // After transforming the plugin path to an ID, multiple plugins might end up with the same ID. For
                    // example "MyPlugin" and "myplugin" would have the same ID. Technically it's possible to have two
                    // such folders but to keep things sane we disallow it.
                    if (this.plugins_[plugin.id])
                        throw new Error(`There is already a plugin with this ID: ${plugin.id}`);
                    this.setPluginAt(plugin.id, plugin);
                    if (!this.pluginEnabled(settings, plugin.id)) {
                        logger.info(`Not running disabled plugin: "${plugin.id}"`);
                        continue;
                    }
                    plugin.devMode = devMode;
                    yield this.runPlugin(plugin);
                }
                catch (error) {
                    logger.error(`Could not load plugin: ${pluginPath}`, error);
                }
            }
        });
    }
    isCompatible(pluginVersion) {
        return compareVersions(this.appVersion_, pluginVersion) >= 0;
    }
    get allPluginsStarted() {
        for (const pluginId of Object.keys(this.startedPlugins_)) {
            if (!this.startedPlugins_[pluginId])
                return false;
        }
        return true;
    }
    runPlugin(plugin) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isSafeMode)
                throw new Error(`Plugin was not started due to safe mode: ${plugin.manifest.id}`);
            if (!this.isCompatible(plugin.manifest.app_min_version)) {
                throw new Error(`Plugin "${plugin.id}" was disabled because it requires Joplin version ${plugin.manifest.app_min_version} and current version is ${this.appVersion_}.`);
            }
            else {
                this.store_.dispatch({
                    type: 'PLUGIN_ADD',
                    plugin: {
                        id: plugin.id,
                        views: {},
                        contentScripts: {},
                    },
                });
            }
            this.startedPlugins_[plugin.id] = false;
            const onStarted = () => {
                this.startedPlugins_[plugin.id] = true;
                plugin.off('started', onStarted);
            };
            plugin.on('started', onStarted);
            const pluginApi = new Global_1.default(this.platformImplementation_, plugin, this.store_);
            return this.runner_.run(plugin, pluginApi);
        });
    }
    installPluginFromRepo(repoApi, pluginId) {
        return __awaiter(this, void 0, void 0, function* () {
            const pluginPath = yield repoApi.downloadPlugin(pluginId);
            const plugin = yield this.installPlugin(pluginPath);
            yield shim_1.default.fsDriver().remove(pluginPath);
            return plugin;
        });
    }
    updatePluginFromRepo(repoApi, pluginId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.installPluginFromRepo(repoApi, pluginId);
        });
    }
    installPlugin(jplPath, loadPlugin = true) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info(`Installing plugin: "${jplPath}"`);
            // Before moving the plugin to the profile directory, we load it
            // from where it is now to check that it is valid and to retrieve
            // the plugin ID.
            const preloadedPlugin = yield this.loadPluginFromPath(jplPath);
            yield this.deletePluginFiles(preloadedPlugin);
            const destPath = `${Setting_1.default.value('pluginDir')}/${preloadedPlugin.id}.jpl`;
            yield shim_1.default.fsDriver().copy(jplPath, destPath);
            // Now load it from the profile directory
            if (loadPlugin) {
                const plugin = yield this.loadPluginFromPath(destPath);
                if (!this.plugins_[plugin.id])
                    this.setPluginAt(plugin.id, plugin);
                return plugin;
            }
            else {
                return null;
            }
        });
    }
    pluginPath(pluginId) {
        return __awaiter(this, void 0, void 0, function* () {
            const stats = yield shim_1.default.fsDriver().readDirStats(Setting_1.default.value('pluginDir'), { recursive: false });
            for (const stat of stats) {
                if ((0, path_utils_1.filename)(stat.path) === pluginId) {
                    return `${Setting_1.default.value('pluginDir')}/${stat.path}`;
                }
            }
            return null;
        });
    }
    uninstallPlugin(pluginId) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info(`Uninstalling plugin: "${pluginId}"`);
            const path = yield this.pluginPath(pluginId);
            if (!path) {
                // Plugin might have already been deleted
                logger.error(`Could not find plugin path to uninstall - nothing will be done: ${pluginId}`);
            }
            else {
                yield shim_1.default.fsDriver().remove(path);
            }
            this.deletePluginAt(pluginId);
        });
    }
    uninstallPlugins(settings) {
        return __awaiter(this, void 0, void 0, function* () {
            let newSettings = settings;
            for (const pluginId in settings) {
                if (settings[pluginId].deleted) {
                    yield this.uninstallPlugin(pluginId);
                    newSettings = Object.assign({}, settings);
                    delete newSettings[pluginId];
                }
            }
            return newSettings;
        });
    }
    // On startup the "hasBeenUpdated" prop can be cleared since the new version
    // of the plugin has now been loaded.
    clearUpdateState(settings) {
        return (0, immer_1.default)(settings, (draft) => {
            for (const pluginId in draft) {
                if (draft[pluginId].hasBeenUpdated)
                    draft[pluginId].hasBeenUpdated = false;
            }
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.runner_.waitForSandboxCalls();
        });
    }
}
exports.default = PluginService;
PluginService.instance_ = null;
//# sourceMappingURL=PluginService.js.map