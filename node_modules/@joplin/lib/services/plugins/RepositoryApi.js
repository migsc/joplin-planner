"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = require("../../Logger");
const shim_1 = require("../../shim");
const md5 = require('md5');
const compareVersions = require('compare-versions');
const logger = Logger_1.default.create('RepositoryApi');
const findWorkingGitHubUrl = (defaultContentUrl) => __awaiter(void 0, void 0, void 0, function* () {
    // From: https://github.com/laurent22/joplin/issues/5161#issuecomment-921642721
    const mirrorUrls = [
        defaultContentUrl,
        'https://cdn.staticaly.com/gh/joplin/plugins/master',
        'https://ghproxy.com/https://raw.githubusercontent.com/joplin/plugins/master',
        'https://cdn.jsdelivr.net/gh/joplin/plugins@master',
        'https://raw.fastgit.org/joplin/plugins/master',
    ];
    for (const mirrorUrl of mirrorUrls) {
        try {
            // We try to fetch .gitignore, which is smaller than the whole manifest
            yield fetch(`${mirrorUrl}/.gitignore`);
        }
        catch (error) {
            logger.info(`findWorkingMirror: Could not connect to ${mirrorUrl}:`, error);
            continue;
        }
        logger.info(`findWorkingMirror: Using: ${mirrorUrl}`);
        return mirrorUrl;
    }
    logger.info('findWorkingMirror: Could not find any working GitHub URL');
    return defaultContentUrl;
});
class RepositoryApi {
    constructor(baseUrl, tempDir) {
        this.release_ = null;
        this.manifests_ = null;
        this.isUsingDefaultContentUrl_ = true;
        this.baseUrl_ = baseUrl;
        this.tempDir_ = tempDir;
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            // https://github.com/joplin/plugins
            // https://api.github.com/repos/joplin/plugins/releases
            this.githubApiUrl_ = this.baseUrl_.replace(/^(https:\/\/)(github\.com\/)(.*)$/, '$1api.$2repos/$3');
            const defaultContentBaseUrl = `${this.baseUrl_.replace(/github\.com/, 'raw.githubusercontent.com')}/master`;
            this.contentBaseUrl_ = yield findWorkingGitHubUrl(defaultContentBaseUrl);
            this.isUsingDefaultContentUrl_ = this.contentBaseUrl_ === defaultContentBaseUrl;
            yield this.loadManifests();
            yield this.loadRelease();
        });
    }
    loadManifests() {
        return __awaiter(this, void 0, void 0, function* () {
            const manifestsText = yield this.fetchText('manifests.json');
            try {
                const manifests = JSON.parse(manifestsText);
                if (!manifests)
                    throw new Error('Invalid or missing JSON');
                this.manifests_ = Object.keys(manifests).map(id => {
                    const m = manifests[id];
                    // If we don't control the repository, we can't recommend
                    // anything on it since it could have been modified.
                    if (!this.isUsingDefaultContentUrl)
                        m._recommended = false;
                    return m;
                });
            }
            catch (error) {
                throw new Error(`Could not parse JSON: ${error.message}`);
            }
        });
    }
    get isUsingDefaultContentUrl() {
        return this.isUsingDefaultContentUrl_;
    }
    get githubApiUrl() {
        return this.githubApiUrl_;
    }
    get contentBaseUrl() {
        if (this.isLocalRepo) {
            return this.baseUrl_;
        }
        else {
            return this.contentBaseUrl_;
        }
    }
    loadRelease() {
        return __awaiter(this, void 0, void 0, function* () {
            this.release_ = null;
            if (this.isLocalRepo)
                return;
            try {
                const response = yield fetch(`${this.githubApiUrl}/releases`);
                const releases = yield response.json();
                if (!releases.length)
                    throw new Error('No release was found');
                this.release_ = releases[0];
            }
            catch (error) {
                logger.warn('Could not load release - files will be downloaded from the repository directly:', error);
            }
        });
    }
    get isLocalRepo() {
        return this.baseUrl_.indexOf('http') !== 0;
    }
    assetFileUrl(pluginId) {
        if (this.release_) {
            const asset = this.release_.assets.find(asset => {
                const s = asset.name.split('@');
                s.pop();
                const id = s.join('@');
                return id === pluginId;
            });
            if (asset)
                return asset.browser_download_url;
            logger.warn(`Could not get plugin from release: ${pluginId}`);
        }
        // If we couldn't get the plugin file from the release, get it directly
        // from the repository instead.
        return this.repoFileUrl(`plugins/${pluginId}/plugin.jpl`);
    }
    repoFileUrl(relativePath) {
        return `${this.contentBaseUrl}/${relativePath}`;
    }
    fetchText(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isLocalRepo) {
                return shim_1.default.fsDriver().readFile(this.repoFileUrl(path), 'utf8');
            }
            else {
                return shim_1.default.fetchText(this.repoFileUrl(path));
            }
        });
    }
    search(query) {
        return __awaiter(this, void 0, void 0, function* () {
            query = query.toLowerCase().trim();
            const manifests = yield this.manifests();
            const output = [];
            for (const manifest of manifests) {
                for (const field of ['name', 'description']) {
                    const v = manifest[field];
                    if (!v)
                        continue;
                    if (v.toLowerCase().indexOf(query) >= 0) {
                        output.push(manifest);
                        break;
                    }
                }
            }
            return output;
        });
    }
    // Returns a temporary path, where the plugin has been downloaded to. Temp
    // file should be deleted by caller.
    downloadPlugin(pluginId) {
        return __awaiter(this, void 0, void 0, function* () {
            const manifests = yield this.manifests();
            const manifest = manifests.find(m => m.id === pluginId);
            if (!manifest)
                throw new Error(`No manifest for plugin ID "${pluginId}"`);
            const fileUrl = this.assetFileUrl(manifest.id); // this.repoFileUrl(`plugins/${manifest.id}/plugin.jpl`);
            const hash = md5(Date.now() + Math.random());
            const targetPath = `${this.tempDir_}/${hash}_${manifest.id}.jpl`;
            if (this.isLocalRepo) {
                yield shim_1.default.fsDriver().copy(fileUrl, targetPath);
            }
            else {
                const response = yield shim_1.default.fetchBlob(fileUrl, {
                    path: targetPath,
                });
                if (!response.ok)
                    throw new Error(`Could not download plugin "${pluginId}" from "${fileUrl}"`);
            }
            return targetPath;
        });
    }
    manifests() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.manifests_)
                throw new Error('Manifests have no been loaded!');
            return this.manifests_;
        });
    }
    canBeUpdatedPlugins(installedManifests) {
        return __awaiter(this, void 0, void 0, function* () {
            const output = [];
            for (const manifest of installedManifests) {
                const canBe = yield this.pluginCanBeUpdated(manifest.id, manifest.version);
                if (canBe)
                    output.push(manifest.id);
            }
            return output;
        });
    }
    pluginCanBeUpdated(pluginId, installedVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            const manifest = (yield this.manifests()).find(m => m.id === pluginId);
            if (!manifest)
                return false;
            return compareVersions(installedVersion, manifest.version) < 0;
        });
    }
}
exports.default = RepositoryApi;
//# sourceMappingURL=RepositoryApi.js.map