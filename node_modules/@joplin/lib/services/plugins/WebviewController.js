"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerType = void 0;
const ViewController_1 = require("./ViewController");
const shim_1 = require("../../shim");
const { toSystemSlashes } = require('../../path-utils');
const PostMessageService_1 = require("../PostMessageService");
var ContainerType;
(function (ContainerType) {
    ContainerType["Panel"] = "panel";
    ContainerType["Dialog"] = "dialog";
})(ContainerType = exports.ContainerType || (exports.ContainerType = {}));
// TODO: Copied from:
// packages/app-desktop/gui/ResizableLayout/utils/findItemByKey.ts
function findItemByKey(layout, key) {
    if (!layout)
        throw new Error('Layout cannot be null');
    function recurseFind(item) {
        if (item.key === key)
            return item;
        if (item.children) {
            for (const child of item.children) {
                const found = recurseFind(child);
                if (found)
                    return found;
            }
        }
        return null;
    }
    return recurseFind(layout);
}
class WebviewController extends ViewController_1.default {
    constructor(handle, pluginId, store, baseDir, containerType) {
        super(handle, pluginId, store);
        this.messageListener_ = null;
        this.closeResponse_ = null;
        this.baseDir_ = toSystemSlashes(baseDir, 'linux');
        this.store.dispatch({
            type: 'PLUGIN_VIEW_ADD',
            pluginId: pluginId,
            view: {
                id: this.handle,
                type: this.type,
                containerType: containerType,
                html: '',
                scripts: [],
                opened: false,
                buttons: null,
                fitToContent: true,
            },
        });
    }
    get type() {
        return 'webview';
    }
    setStoreProp(name, value) {
        this.store.dispatch({
            type: 'PLUGIN_VIEW_PROP_SET',
            pluginId: this.pluginId,
            id: this.handle,
            name: name,
            value: value,
        });
    }
    get html() {
        return this.storeView.html;
    }
    set html(html) {
        this.setStoreProp('html', html);
    }
    get containerType() {
        return this.storeView.containerType;
    }
    addScript(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const fullPath = toSystemSlashes(shim_1.default.fsDriver().resolve(`${this.baseDir_}/${path}`), 'linux');
            if (fullPath.indexOf(this.baseDir_) !== 0)
                throw new Error(`Script appears to be outside of plugin base directory: ${fullPath} (Base dir: ${this.baseDir_})`);
            this.store.dispatch({
                type: 'PLUGIN_VIEW_PROP_PUSH',
                pluginId: this.pluginId,
                id: this.handle,
                name: 'scripts',
                value: fullPath,
            });
        });
    }
    postMessage(message) {
        const messageId = `plugin_${Date.now()}${Math.random()}`;
        void PostMessageService_1.default.instance().postMessage({
            pluginId: this.pluginId,
            viewId: this.handle,
            contentScriptId: null,
            from: PostMessageService_1.MessageParticipant.Plugin,
            to: PostMessageService_1.MessageParticipant.UserWebview,
            id: messageId,
            content: message,
        });
    }
    emitMessage(event) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.messageListener_)
                return;
            return this.messageListener_(event.message);
        });
    }
    onMessage(callback) {
        this.messageListener_ = callback;
    }
    // ---------------------------------------------
    // Specific to panels
    // ---------------------------------------------
    show(show = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this.store.dispatch({
                type: 'MAIN_LAYOUT_SET_ITEM_PROP',
                itemKey: this.handle,
                propName: 'visible',
                propValue: show,
            });
        });
    }
    hide() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.show(false);
        });
    }
    get visible() {
        const mainLayout = this.store.getState().mainLayout;
        const item = findItemByKey(mainLayout, this.handle);
        return item ? item.visible : false;
    }
    // ---------------------------------------------
    // Specific to dialogs
    // ---------------------------------------------
    open() {
        return __awaiter(this, void 0, void 0, function* () {
            this.store.dispatch({
                type: 'VISIBLE_DIALOGS_ADD',
                name: this.handle,
            });
            this.setStoreProp('opened', true);
            return new Promise((resolve, reject) => {
                this.closeResponse_ = { resolve, reject };
            });
        });
    }
    close() {
        this.store.dispatch({
            type: 'VISIBLE_DIALOGS_REMOVE',
            name: this.handle,
        });
        this.setStoreProp('opened', false);
    }
    closeWithResponse(result) {
        this.close();
        this.closeResponse_.resolve(result);
    }
    get buttons() {
        return this.storeView.buttons;
    }
    set buttons(buttons) {
        this.setStoreProp('buttons', buttons);
    }
    get fitToContent() {
        return this.storeView.fitToContent;
    }
    set fitToContent(fitToContent) {
        this.setStoreProp('fitToContent', fitToContent);
    }
}
exports.default = WebviewController;
//# sourceMappingURL=WebviewController.js.map