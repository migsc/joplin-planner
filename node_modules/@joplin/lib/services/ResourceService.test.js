"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const time_1 = require("../time");
const NoteResource_1 = require("../models/NoteResource");
const ResourceService_1 = require("../services/ResourceService");
const shim_1 = require("../shim");
const test_utils_1 = require("../testing/test-utils");
const Folder_1 = require("../models/Folder");
const Note_1 = require("../models/Note");
const Resource_1 = require("../models/Resource");
const SearchEngine_1 = require("../services/searchengine/SearchEngine");
const utils_1 = require("./e2ee/utils");
describe('services/ResourceService', function () {
    beforeEach((done) => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(2);
        yield (0, test_utils_1.switchClient)(1);
        done();
    }));
    it('should delete orphaned resources', (() => __awaiter(this, void 0, void 0, function* () {
        const service = new ResourceService_1.default();
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        let note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        note1 = yield shim_1.default.attachFileToNote(note1, `${test_utils_1.supportDir}/photo.jpg`);
        const resource1 = (yield Resource_1.default.all())[0];
        const resourcePath = Resource_1.default.fullPath(resource1);
        yield service.indexNoteResources();
        yield service.deleteOrphanResources(0);
        expect(!!(yield Resource_1.default.load(resource1.id))).toBe(true);
        yield Note_1.default.delete(note1.id);
        yield service.deleteOrphanResources(0);
        expect(!!(yield Resource_1.default.load(resource1.id))).toBe(true);
        yield service.indexNoteResources();
        yield service.deleteOrphanResources(1000 * 60);
        expect(!!(yield Resource_1.default.load(resource1.id))).toBe(true);
        yield service.deleteOrphanResources(0);
        expect(!!(yield Resource_1.default.load(resource1.id))).toBe(false);
        expect(yield shim_1.default.fsDriver().exists(resourcePath)).toBe(false);
        expect(!(yield NoteResource_1.default.all()).length).toBe(true);
    })));
    it('should not delete resource if still associated with at least one note', (() => __awaiter(this, void 0, void 0, function* () {
        const service = new ResourceService_1.default();
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        let note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        const note2 = yield Note_1.default.save({ title: 'ma deuxiÃ¨me note', parent_id: folder1.id });
        note1 = yield shim_1.default.attachFileToNote(note1, `${test_utils_1.supportDir}/photo.jpg`);
        const resource1 = (yield Resource_1.default.all())[0];
        yield service.indexNoteResources();
        yield Note_1.default.delete(note1.id);
        yield service.indexNoteResources();
        yield Note_1.default.save({ id: note2.id, body: Resource_1.default.markdownTag(resource1) });
        yield service.indexNoteResources();
        yield service.deleteOrphanResources(0);
        expect(!!(yield Resource_1.default.load(resource1.id))).toBe(true);
    })));
    // This is now handled below by more correct tests
    //
    // it('should not delete a resource that has never been associated with any note, because it probably means the resource came via sync, and associated note has not arrived yet', (async () => {
    // 	const service = new ResourceService();
    // 	await shim.createResourceFromPath(`${supportDir}/photo.jpg`);
    // 	await service.indexNoteResources();
    // 	await service.deleteOrphanResources(0);
    // 	expect((await Resource.all()).length).toBe(1);
    // }));
    it('should not delete resource if it is used in an IMG tag', (() => __awaiter(this, void 0, void 0, function* () {
        const service = new ResourceService_1.default();
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        let note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        note1 = yield shim_1.default.attachFileToNote(note1, `${test_utils_1.supportDir}/photo.jpg`);
        const resource1 = (yield Resource_1.default.all())[0];
        yield service.indexNoteResources();
        yield Note_1.default.save({ id: note1.id, body: `This is HTML: <img src=":/${resource1.id}"/>` });
        yield service.indexNoteResources();
        yield service.deleteOrphanResources(0);
        expect(!!(yield Resource_1.default.load(resource1.id))).toBe(true);
    })));
    it('should not process twice the same change', (() => __awaiter(this, void 0, void 0, function* () {
        const service = new ResourceService_1.default();
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        const note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        yield shim_1.default.attachFileToNote(note1, `${test_utils_1.supportDir}/photo.jpg`);
        yield service.indexNoteResources();
        const before = (yield NoteResource_1.default.all())[0];
        yield time_1.default.sleep(0.1);
        yield service.indexNoteResources();
        const after = (yield NoteResource_1.default.all())[0];
        expect(before.last_seen_time).toBe(after.last_seen_time);
    })));
    it('should not delete resources that are associated with an encrypted note', (() => __awaiter(this, void 0, void 0, function* () {
        // https://github.com/laurent22/joplin/issues/1433
        //
        // Client 1 and client 2 have E2EE setup.
        //
        // - Client 1 creates note N1 and add resource R1 to it
        // - Client 1 syncs
        // - Client 2 syncs and get N1
        // - Client 2 add resource R2 to N1
        // - Client 2 syncs
        // - Client 1 syncs
        // - Client 1 runs resource indexer - but because N1 hasn't been decrypted yet, it found that R1 is no longer associated with any note
        // - Client 1 decrypts notes, but too late
        //
        // Eventually R1 is deleted because service thinks that it was at some point associated with a note, but no longer.
        const masterKey = yield (0, test_utils_1.loadEncryptionMasterKey)();
        yield (0, utils_1.setupAndEnableEncryption)((0, test_utils_1.encryptionService)(), masterKey, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        const note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        yield shim_1.default.attachFileToNote(note1, `${test_utils_1.supportDir}/photo.jpg`); // R1
        yield (0, test_utils_1.resourceService)().indexNoteResources();
        yield (0, test_utils_1.synchronizer)().start();
        expect(yield (0, test_utils_1.allSyncTargetItemsEncrypted)()).toBe(true);
        yield (0, test_utils_1.switchClient)(2);
        yield (0, test_utils_1.synchronizer)().start();
        yield (0, utils_1.setupAndEnableEncryption)((0, test_utils_1.encryptionService)(), masterKey, '123456');
        yield (0, utils_1.loadMasterKeysFromSettings)((0, test_utils_1.encryptionService)());
        yield (0, test_utils_1.decryptionWorker)().start();
        {
            const n1 = yield Note_1.default.load(note1.id);
            yield shim_1.default.attachFileToNote(n1, `${test_utils_1.supportDir}/photo.jpg`); // R2
        }
        yield (0, test_utils_1.synchronizer)().start();
        yield (0, test_utils_1.switchClient)(1);
        yield (0, test_utils_1.synchronizer)().start();
        yield (0, test_utils_1.resourceService)().indexNoteResources();
        yield (0, test_utils_1.resourceService)().deleteOrphanResources(0); // Previously, R1 would be deleted here because it's not indexed
        expect((yield Resource_1.default.all()).length).toBe(2);
    })));
    it('should double-check if the resource is still linked before deleting it', (() => __awaiter(this, void 0, void 0, function* () {
        SearchEngine_1.default.instance().setDb((0, test_utils_1.db)()); // /!\ Note that we use the global search engine here, which we shouldn't but will work for now
        const folder1 = yield Folder_1.default.save({ title: 'folder1' });
        let note1 = yield Note_1.default.save({ title: 'ma note', parent_id: folder1.id });
        note1 = yield shim_1.default.attachFileToNote(note1, `${test_utils_1.supportDir}/photo.jpg`);
        yield (0, test_utils_1.resourceService)().indexNoteResources();
        const bodyWithResource = note1.body;
        yield Note_1.default.save({ id: note1.id, body: '' });
        yield (0, test_utils_1.resourceService)().indexNoteResources();
        yield Note_1.default.save({ id: note1.id, body: bodyWithResource });
        yield SearchEngine_1.default.instance().syncTables();
        yield (0, test_utils_1.resourceService)().deleteOrphanResources(0);
        expect((yield Resource_1.default.all()).length).toBe(1); // It should not have deleted the resource
        const nr = (yield NoteResource_1.default.all())[0];
        expect(!!nr.is_associated).toBe(true); // And it should have fixed the situation by re-indexing the note content
    })));
    it('should delete a resource if it is not associated with any note and has never been synced', (() => __awaiter(this, void 0, void 0, function* () {
        // - User creates a note and attaches a resource
        // - User deletes the note
        // - NoteResource service runs - the resource can be deleted
        //
        // This is because, since the resource didn't come via sync, it's
        // guaranteed that it is orphaned, which means it can be safely deleted.
        // See related test below to handle case where the resource actually
        // comes via sync.
        const note = yield Note_1.default.save({});
        yield shim_1.default.attachFileToNote(note, `${test_utils_1.supportDir}/photo.jpg`);
        yield Note_1.default.delete(note.id);
        const resource = (yield Resource_1.default.all())[0];
        yield (0, test_utils_1.resourceService)().indexNoteResources();
        yield (0, test_utils_1.resourceService)().deleteOrphanResources(-10);
        expect(yield Resource_1.default.load(resource.id)).toBeFalsy();
    })));
    it('should NOT delete a resource if it arrived via synced, even if it is not associated with any note', (() => __awaiter(this, void 0, void 0, function* () {
        // - C1 creates Resource 1
        // - C1 sync
        // - C2 sync
        // - NoteResource service runs - should find an orphan resource, but not
        //   delete it because the associated note might come later from U1.
        //
        // At this point, C1 has the knowledge about Resource 1 so whether it's
        // eventually deleted or not will come from there. If it's an orphaned
        // resource, it will be deleted on C1 first, then the deletion will be
        // synced to other clients.
        const note = yield Note_1.default.save({});
        yield shim_1.default.attachFileToNote(note, `${test_utils_1.supportDir}/photo.jpg`);
        yield Note_1.default.delete(note.id);
        const resource = (yield Resource_1.default.all())[0];
        yield (0, test_utils_1.synchronizer)().start();
        yield (0, test_utils_1.switchClient)(2);
        yield (0, test_utils_1.synchronizer)().start();
        yield (0, test_utils_1.resourceService)().indexNoteResources();
        yield (0, test_utils_1.resourceService)().deleteOrphanResources(0);
        expect(yield Resource_1.default.load(resource.id)).toBeTruthy();
    })));
    // it('should auto-delete resource even if the associated note was deleted immediately', (async () => {
    // 	// Previoulsy, when a resource was be attached to a note, then the
    // 	// note was immediately deleted, the ResourceService would not have
    // 	// time to quick in an index the resource/note relation. It means
    // 	// that when doing the orphan resource deletion job, those
    // 	// resources would permanently stay behing.
    // 	// https://github.com/laurent22/joplin/issues/932
    // 	const service = new ResourceService();
    // 	let note = await Note.save({});
    // 	note = await shim.attachFileToNote(note, `${supportDir}/photo.jpg`);
    // 	const resource = (await Resource.all())[0];
    // 	const noteIds = await NoteResource.associatedNoteIds(resource.id);
    // 	expect(noteIds[0]).toBe(note.id);
    // 	await Note.save({ id: note.id, body: '' });
    // 	await resourceService().indexNoteResources();
    // 	await service.deleteOrphanResources(0);
    // 	expect((await Resource.all()).length).toBe(0);
    // }));
});
//# sourceMappingURL=ResourceService.test.js.map