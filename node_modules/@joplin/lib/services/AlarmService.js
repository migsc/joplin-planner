"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Alarm_1 = require("../models/Alarm");
const Note_1 = require("../models/Note");
class AlarmService {
    // private static inAppNotificationHandler_:any;
    static setDriver(v) {
        this.driver_ = v;
        if (this.driver_.setService)
            this.driver_.setService(this);
    }
    static driver() {
        if (!this.driver_)
            throw new Error('AlarmService driver not set!');
        return this.driver_;
    }
    static setLogger(v) {
        this.logger_ = v;
    }
    static logger() {
        return this.logger_;
    }
    static setInAppNotificationHandler(v) {
        // this.inAppNotificationHandler_ = v;
        if (this.driver_.setInAppNotificationHandler)
            this.driver_.setInAppNotificationHandler(v);
    }
    static garbageCollect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger().info('Garbage collecting alarms...');
            // Delete alarms that have already been triggered
            yield Alarm_1.default.deleteExpiredAlarms();
            // Delete alarms that correspond to non-existent notes
            const alarmIds = yield Alarm_1.default.alarmIdsWithoutNotes();
            for (let i = 0; i < alarmIds.length; i++) {
                this.logger().info(`Clearing notification for non-existing note. Alarm ${alarmIds[i]}`);
                yield this.driver().clearNotification(alarmIds[i]);
            }
            yield Alarm_1.default.batchDelete(alarmIds);
        });
    }
    // When passing a note, make sure it has all the required properties
    // (better to pass a complete note or else just the ID)
    static updateNoteNotification(noteOrId, isDeleted = false) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let note = null;
                let noteId = null;
                if (typeof noteOrId === 'object') {
                    note = noteOrId;
                    noteId = note.id;
                }
                else {
                    note = yield Note_1.default.load(noteOrId);
                    noteId = note ? note.id : null;
                }
                if (!note && !isDeleted)
                    return;
                const driver = this.driver();
                let alarm = noteId ? yield Alarm_1.default.byNoteId(noteId) : null;
                let clearAlarm = false;
                if (isDeleted || !Note_1.default.needAlarm(note) || (alarm && alarm.trigger_time !== note.todo_due)) {
                    clearAlarm = !!alarm;
                }
                if (!clearAlarm && alarm) {
                    // Alarm already exists and set at the right time
                    // For persistent notifications (those that stay active after the app has been closed, like on mobile), if we have
                    // an alarm object we can be sure that the notification has already been set, so there's nothing to do.
                    // For non-persistent notifications however we need to check that the notification has been set because, for example,
                    // if the app has just started the notifications need to be set again. so we do this below.
                    if (!driver.hasPersistentNotifications() && !driver.notificationIsSet(alarm.id)) {
                        const notification = yield Alarm_1.default.makeNotification(alarm, note);
                        this.logger().info(`Scheduling (non-persistent) notification for note ${note.id}`, notification);
                        driver.scheduleNotification(notification);
                    }
                    return;
                }
                if (clearAlarm) {
                    this.logger().info(`Clearing notification for note ${noteId}`);
                    yield driver.clearNotification(alarm.id);
                    yield Alarm_1.default.delete(alarm.id);
                }
                if (isDeleted || !Note_1.default.needAlarm(note))
                    return;
                yield Alarm_1.default.save({
                    note_id: note.id,
                    trigger_time: note.todo_due,
                });
                // Reload alarm to get its ID
                alarm = yield Alarm_1.default.byNoteId(note.id);
                const notification = yield Alarm_1.default.makeNotification(alarm, note);
                this.logger().info(`Scheduling notification for note ${note.id}`, notification);
                yield driver.scheduleNotification(notification);
            }
            catch (error) {
                this.logger().error('Could not update notification', error);
            }
        });
    }
    static updateAllNotifications() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger().info('Updating all notifications...');
            yield this.garbageCollect();
            const dueNotes = yield Note_1.default.dueNotes();
            for (let i = 0; i < dueNotes.length; i++) {
                yield this.updateNoteNotification(dueNotes[i]);
            }
        });
    }
}
exports.default = AlarmService;
//# sourceMappingURL=AlarmService.js.map