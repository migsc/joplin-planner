"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const test_utils_1 = require("../../testing/test-utils");
const Folder_1 = require("../../models/Folder");
const Note_1 = require("../../models/Note");
const Setting_1 = require("../../models/Setting");
const BaseItem_1 = require("../../models/BaseItem");
const MasterKey_1 = require("../../models/MasterKey");
const EncryptionService_1 = require("./EncryptionService");
const syncInfoUtils_1 = require("../synchronizer/syncInfoUtils");
let service = null;
describe('services_EncryptionService', function () {
    beforeEach((done) => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.switchClient)(1);
        service = new EncryptionService_1.default();
        BaseItem_1.default.encryptionService_ = service;
        (0, syncInfoUtils_1.setEncryptionEnabled)(true);
        done();
    }));
    it('should encode and decode header', (() => __awaiter(this, void 0, void 0, function* () {
        const header = {
            encryptionMethod: EncryptionService_1.EncryptionMethod.SJCL,
            masterKeyId: '01234568abcdefgh01234568abcdefgh',
        };
        const encodedHeader = service.encodeHeader_(header);
        const decodedHeader = service.decodeHeaderBytes_(encodedHeader);
        delete decodedHeader.length;
        expect((0, test_utils_1.objectsEqual)(header, decodedHeader)).toBe(true);
    })));
    it('should generate and decrypt a master key', (() => __awaiter(this, void 0, void 0, function* () {
        const masterKey = yield service.generateMasterKey('123456');
        expect(!!masterKey.content).toBe(true);
        let hasThrown = false;
        try {
            yield service.decryptMasterKeyContent(masterKey, 'wrongpassword');
        }
        catch (error) {
            hasThrown = true;
        }
        expect(hasThrown).toBe(true);
        const decryptedMasterKey = yield service.decryptMasterKeyContent(masterKey, '123456');
        expect(decryptedMasterKey.length).toBe(512);
    })));
    it('should upgrade a master key', (() => __awaiter(this, void 0, void 0, function* () {
        // Create an old style master key
        let masterKey = yield service.generateMasterKey('123456', {
            encryptionMethod: EncryptionService_1.EncryptionMethod.SJCL2,
        });
        masterKey = yield MasterKey_1.default.save(masterKey);
        let upgradedMasterKey = yield service.reencryptMasterKey(masterKey, '123456', '123456');
        upgradedMasterKey = yield MasterKey_1.default.save(upgradedMasterKey);
        // Check that master key has been upgraded (different ciphertext)
        expect(masterKey.content).not.toBe(upgradedMasterKey.content);
        // Check that master key plain text is still the same
        const plainTextOld = yield service.decryptMasterKeyContent(masterKey, '123456');
        const plainTextNew = yield service.decryptMasterKeyContent(upgradedMasterKey, '123456');
        expect(plainTextOld).toBe(plainTextNew);
        // Check that old content can be decrypted with new master key
        yield service.loadMasterKey(masterKey, '123456', true);
        const cipherText = yield service.encryptString('some secret');
        const plainTextFromOld = yield service.decryptString(cipherText);
        yield service.loadMasterKey(upgradedMasterKey, '123456', true);
        const plainTextFromNew = yield service.decryptString(cipherText);
        expect(plainTextFromOld).toBe(plainTextFromNew);
    })));
    it('should not upgrade master key if invalid password', (() => __awaiter(this, void 0, void 0, function* () {
        const masterKey = yield service.generateMasterKey('123456', {
            encryptionMethod: EncryptionService_1.EncryptionMethod.SJCL2,
        });
        yield (0, test_utils_1.checkThrowAsync)(() => __awaiter(this, void 0, void 0, function* () { return yield service.reencryptMasterKey(masterKey, '777', '777'); }));
    })));
    it('should require a checksum only for old master keys', (() => __awaiter(this, void 0, void 0, function* () {
        const masterKey = yield service.generateMasterKey('123456', {
            encryptionMethod: EncryptionService_1.EncryptionMethod.SJCL2,
        });
        expect(!!masterKey.checksum).toBe(true);
        expect(!!masterKey.content).toBe(true);
    })));
    it('should not require a checksum for new master keys', (() => __awaiter(this, void 0, void 0, function* () {
        const masterKey = yield service.generateMasterKey('123456', {
            encryptionMethod: EncryptionService_1.EncryptionMethod.SJCL4,
        });
        expect(!masterKey.checksum).toBe(true);
        expect(!!masterKey.content).toBe(true);
        const decryptedMasterKey = yield service.decryptMasterKeyContent(masterKey, '123456');
        expect(decryptedMasterKey.length).toBe(512);
    })));
    it('should throw an error if master key decryption fails', (() => __awaiter(this, void 0, void 0, function* () {
        const masterKey = yield service.generateMasterKey('123456', {
            encryptionMethod: EncryptionService_1.EncryptionMethod.SJCL4,
        });
        const hasThrown = yield (0, test_utils_1.checkThrowAsync)(() => __awaiter(this, void 0, void 0, function* () { return yield service.decryptMasterKeyContent(masterKey, 'wrong'); }));
        expect(hasThrown).toBe(true);
    })));
    it('should return the master keys that need an upgrade', (() => __awaiter(this, void 0, void 0, function* () {
        const masterKey1 = yield MasterKey_1.default.save(yield service.generateMasterKey('123456', {
            encryptionMethod: EncryptionService_1.EncryptionMethod.SJCL2,
        }));
        const masterKey2 = yield MasterKey_1.default.save(yield service.generateMasterKey('123456', {
            encryptionMethod: EncryptionService_1.EncryptionMethod.SJCL,
        }));
        yield MasterKey_1.default.save(yield service.generateMasterKey('123456'));
        const needUpgrade = service.masterKeysThatNeedUpgrading(yield MasterKey_1.default.all());
        expect(needUpgrade.length).toBe(2);
        expect(needUpgrade.map(k => k.id).sort()).toEqual([masterKey1.id, masterKey2.id].sort());
    })));
    it('should encrypt and decrypt with a master key', (() => __awaiter(this, void 0, void 0, function* () {
        let masterKey = yield service.generateMasterKey('123456');
        masterKey = yield MasterKey_1.default.save(masterKey);
        yield service.loadMasterKey(masterKey, '123456', true);
        const cipherText = yield service.encryptString('some secret');
        const plainText = yield service.decryptString(cipherText);
        expect(plainText).toBe('some secret');
        // Test that a long string, that is going to be split into multiple chunks, encrypt
        // and decrypt properly too.
        let veryLongSecret = '';
        for (let i = 0; i < service.chunkSize() * 3; i++)
            veryLongSecret += Math.floor(Math.random() * 9);
        const cipherText2 = yield service.encryptString(veryLongSecret);
        const plainText2 = yield service.decryptString(cipherText2);
        expect(plainText2 === veryLongSecret).toBe(true);
    })));
    it('should decrypt various encryption methods', (() => __awaiter(this, void 0, void 0, function* () {
        let masterKey = yield service.generateMasterKey('123456');
        masterKey = yield MasterKey_1.default.save(masterKey);
        yield service.loadMasterKey(masterKey, '123456', true);
        {
            const cipherText = yield service.encryptString('some secret', {
                encryptionMethod: EncryptionService_1.EncryptionMethod.SJCL2,
            });
            const plainText = yield service.decryptString(cipherText);
            expect(plainText).toBe('some secret');
            const header = yield service.decodeHeaderString(cipherText);
            expect(header.encryptionMethod).toBe(EncryptionService_1.EncryptionMethod.SJCL2);
        }
        {
            const cipherText = yield service.encryptString('some secret', {
                encryptionMethod: EncryptionService_1.EncryptionMethod.SJCL3,
            });
            const plainText = yield service.decryptString(cipherText);
            expect(plainText).toBe('some secret');
            const header = yield service.decodeHeaderString(cipherText);
            expect(header.encryptionMethod).toBe(EncryptionService_1.EncryptionMethod.SJCL3);
        }
    })));
    it('should fail to decrypt if master key not present', (() => __awaiter(this, void 0, void 0, function* () {
        let masterKey = yield service.generateMasterKey('123456');
        masterKey = yield MasterKey_1.default.save(masterKey);
        yield service.loadMasterKey(masterKey, '123456', true);
        const cipherText = yield service.encryptString('some secret');
        yield service.unloadMasterKey(masterKey);
        const hasThrown = yield (0, test_utils_1.checkThrowAsync)(() => __awaiter(this, void 0, void 0, function* () { return yield service.decryptString(cipherText); }));
        expect(hasThrown).toBe(true);
    })));
    it('should fail to decrypt if data tampered with', (() => __awaiter(this, void 0, void 0, function* () {
        let masterKey = yield service.generateMasterKey('123456');
        masterKey = yield MasterKey_1.default.save(masterKey);
        yield service.loadMasterKey(masterKey, '123456', true);
        let cipherText = yield service.encryptString('some secret');
        cipherText += 'ABCDEFGHIJ';
        const hasThrown = yield (0, test_utils_1.checkThrowAsync)(() => __awaiter(this, void 0, void 0, function* () { return yield service.decryptString(cipherText); }));
        expect(hasThrown).toBe(true);
    })));
    it('should encrypt and decrypt notes and folders', (() => __awaiter(this, void 0, void 0, function* () {
        let masterKey = yield service.generateMasterKey('123456');
        masterKey = yield MasterKey_1.default.save(masterKey);
        yield service.loadMasterKey(masterKey, '123456', true);
        const folder = yield Folder_1.default.save({ title: 'folder' });
        const note = yield Note_1.default.save({ title: 'encrypted note', body: 'something', parent_id: folder.id });
        const serialized = yield Note_1.default.serializeForSync(note);
        const deserialized = Note_1.default.filter(yield Note_1.default.unserialize(serialized));
        // Check that required properties are not encrypted
        expect(deserialized.id).toBe(note.id);
        expect(deserialized.parent_id).toBe(note.parent_id);
        expect(deserialized.updated_time).toBe(note.updated_time);
        // Check that at least title and body are encrypted
        expect(!deserialized.title).toBe(true);
        expect(!deserialized.body).toBe(true);
        // Check that encrypted data is there
        expect(!!deserialized.encryption_cipher_text).toBe(true);
        const encryptedNote = yield Note_1.default.save(deserialized);
        const decryptedNote = yield Note_1.default.decrypt(encryptedNote);
        expect(decryptedNote.title).toBe(note.title);
        expect(decryptedNote.body).toBe(note.body);
        expect(decryptedNote.id).toBe(note.id);
        expect(decryptedNote.parent_id).toBe(note.parent_id);
    })));
    it('should encrypt and decrypt files', (() => __awaiter(this, void 0, void 0, function* () {
        let masterKey = yield service.generateMasterKey('123456');
        masterKey = yield MasterKey_1.default.save(masterKey);
        yield service.loadMasterKey(masterKey, '123456', true);
        const sourcePath = `${test_utils_1.supportDir}/photo.jpg`;
        const encryptedPath = `${Setting_1.default.value('tempDir')}/photo.crypted`;
        const decryptedPath = `${Setting_1.default.value('tempDir')}/photo.jpg`;
        yield service.encryptFile(sourcePath, encryptedPath);
        yield service.decryptFile(encryptedPath, decryptedPath);
        expect((0, test_utils_1.fileContentEqual)(sourcePath, encryptedPath)).toBe(false);
        expect((0, test_utils_1.fileContentEqual)(sourcePath, decryptedPath)).toBe(true);
    })));
    it('should encrypt invalid UTF-8 data', (() => __awaiter(this, void 0, void 0, function* () {
        let masterKey = yield service.generateMasterKey('123456');
        masterKey = yield MasterKey_1.default.save(masterKey);
        yield service.loadMasterKey(masterKey, '123456', true);
        // First check that we can replicate the error with the old encryption method
        service.defaultEncryptionMethod_ = EncryptionService_1.EncryptionMethod.SJCL;
        const hasThrown = yield (0, test_utils_1.checkThrowAsync)(() => __awaiter(this, void 0, void 0, function* () { return yield service.encryptString('🐶🐶🐶'.substr(0, 5)); }));
        expect(hasThrown).toBe(true);
        // Now check that the new one fixes the problem
        service.defaultEncryptionMethod_ = EncryptionService_1.EncryptionMethod.SJCL1a;
        const cipherText = yield service.encryptString('🐶🐶🐶'.substr(0, 5));
        const plainText = yield service.decryptString(cipherText);
        expect(plainText).toBe('🐶🐶🐶'.substr(0, 5));
    })));
    it('should check if a master key is loaded', (() => __awaiter(this, void 0, void 0, function* () {
        let masterKey = yield service.generateMasterKey('123456');
        masterKey = yield MasterKey_1.default.save(masterKey);
        yield service.loadMasterKey(masterKey, '123456', true);
        expect(service.isMasterKeyLoaded(masterKey)).toBe(true);
        yield (0, test_utils_1.msleep)(1);
        // If the master key is modified afterwards it should report that it is
        // *not* loaded since it doesn't have this new version.
        masterKey = yield MasterKey_1.default.save(masterKey);
        expect(service.isMasterKeyLoaded(masterKey)).toBe(false);
    })));
});
//# sourceMappingURL=EncryptionService.test.js.map