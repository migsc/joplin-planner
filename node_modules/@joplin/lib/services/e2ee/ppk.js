"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mkReencryptFromPublicKeyToPassword = exports.mkReencryptFromPasswordToPublicKey = exports.ppkDecryptMasterKeyContent = exports.ppkGenerateMasterKey = exports.ppkPasswordIsValid = exports.pkReencryptPrivateKey = exports.generateKeyPair = exports.decryptPrivateKey = exports.rsa = exports.setRSA = void 0;
const uuid_1 = require("../../uuid");
const EncryptionService_1 = require("./EncryptionService");
let rsa_ = null;
const setRSA = (rsa) => {
    rsa_ = rsa;
};
exports.setRSA = setRSA;
const rsa = () => {
    if (!rsa_)
        throw new Error('RSA handler has not been set!!');
    return rsa_;
};
exports.rsa = rsa;
function encryptPrivateKey(encryptionService, password, plainText) {
    return __awaiter(this, void 0, void 0, function* () {
        return {
            encryptionMethod: EncryptionService_1.EncryptionMethod.SJCL4,
            ciphertext: yield encryptionService.encrypt(EncryptionService_1.EncryptionMethod.SJCL4, password, plainText),
        };
    });
}
function decryptPrivateKey(encryptionService, encryptedKey, password) {
    return __awaiter(this, void 0, void 0, function* () {
        return encryptionService.decrypt(encryptedKey.encryptionMethod, password, encryptedKey.ciphertext);
    });
}
exports.decryptPrivateKey = decryptPrivateKey;
function generateKeyPair(encryptionService, password) {
    return __awaiter(this, void 0, void 0, function* () {
        const keySize = 2048;
        const keyPair = yield (0, exports.rsa)().generateKeyPair(keySize);
        return {
            id: uuid_1.default.createNano(),
            keySize,
            privateKey: yield encryptPrivateKey(encryptionService, password, (0, exports.rsa)().privateKey(keyPair)),
            publicKey: (0, exports.rsa)().publicKey(keyPair),
            createdTime: Date.now(),
        };
    });
}
exports.generateKeyPair = generateKeyPair;
function pkReencryptPrivateKey(encryptionService, ppk, decryptionPassword, encryptionPassword) {
    return __awaiter(this, void 0, void 0, function* () {
        const decryptedPrivate = yield decryptPrivateKey(encryptionService, ppk.privateKey, decryptionPassword);
        return Object.assign(Object.assign({}, ppk), { privateKey: yield encryptPrivateKey(encryptionService, encryptionPassword, decryptedPrivate) });
    });
}
exports.pkReencryptPrivateKey = pkReencryptPrivateKey;
function ppkPasswordIsValid(service, ppk, password) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!ppk)
            throw new Error('PPK is undefined');
        try {
            yield loadPpk(service, ppk, password);
        }
        catch (error) {
            return false;
        }
        return true;
    });
}
exports.ppkPasswordIsValid = ppkPasswordIsValid;
function loadPpk(service, ppk, password) {
    return __awaiter(this, void 0, void 0, function* () {
        const privateKeyPlainText = yield decryptPrivateKey(service, ppk.privateKey, password);
        return (0, exports.rsa)().loadKeys(ppk.publicKey, privateKeyPlainText);
    });
}
function loadPublicKey(publicKey) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0, exports.rsa)().loadKeys(publicKey, '');
    });
}
function ppkEncryptionHandler(ppkId, rsaKeyPair) {
    return {
        context: {
            rsaKeyPair,
            ppkId,
        },
        encrypt: (context, hexaBytes, _password) => __awaiter(this, void 0, void 0, function* () {
            return JSON.stringify({
                ppkId: context.ppkId,
                ciphertext: yield (0, exports.rsa)().encrypt(hexaBytes, context.rsaKeyPair),
            });
        }),
        decrypt: (context, ciphertext, _password) => __awaiter(this, void 0, void 0, function* () {
            const parsed = JSON.parse(ciphertext);
            if (parsed.ppkId !== context.ppkId)
                throw new Error(`Needs private key ${parsed.ppkId} to decrypt, but using ${context.ppkId}`);
            return (0, exports.rsa)().decrypt(parsed.ciphertext, context.rsaKeyPair);
        }),
    };
}
// Generates a master key and encrypts it using the provided PPK
function ppkGenerateMasterKey(service, ppk, password) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodeRSA = yield loadPpk(service, ppk, password);
        const handler = ppkEncryptionHandler(ppk.id, nodeRSA);
        return service.generateMasterKey('', {
            encryptionMethod: EncryptionService_1.EncryptionMethod.Custom,
            encryptionHandler: handler,
        });
    });
}
exports.ppkGenerateMasterKey = ppkGenerateMasterKey;
// Decrypt the content of a master key that was encrypted using ppkGenerateMasterKey()
function ppkDecryptMasterKeyContent(service, masterKey, ppk, password) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodeRSA = yield loadPpk(service, ppk, password);
        const handler = ppkEncryptionHandler(ppk.id, nodeRSA);
        return service.decryptMasterKeyContent(masterKey, '', {
            encryptionHandler: handler,
        });
    });
}
exports.ppkDecryptMasterKeyContent = ppkDecryptMasterKeyContent;
function mkReencryptFromPasswordToPublicKey(service, masterKey, decryptionPassword, encryptionPublicKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const encryptionHandler = ppkEncryptionHandler(encryptionPublicKey.id, yield loadPublicKey(encryptionPublicKey.publicKey));
        const plainText = yield service.decryptMasterKeyContent(masterKey, decryptionPassword);
        const newContent = yield service.encryptMasterKeyContent(EncryptionService_1.EncryptionMethod.Custom, plainText, '', { encryptionHandler });
        return Object.assign(Object.assign({}, masterKey), newContent);
    });
}
exports.mkReencryptFromPasswordToPublicKey = mkReencryptFromPasswordToPublicKey;
function mkReencryptFromPublicKeyToPassword(service, masterKey, decryptionPpk, decryptionPassword, encryptionPassword) {
    return __awaiter(this, void 0, void 0, function* () {
        const decryptionHandler = ppkEncryptionHandler(decryptionPpk.id, yield loadPpk(service, decryptionPpk, decryptionPassword));
        const plainText = yield service.decryptMasterKeyContent(masterKey, '', { encryptionHandler: decryptionHandler });
        const newContent = yield service.encryptMasterKeyContent(null, plainText, encryptionPassword);
        return Object.assign(Object.assign({}, masterKey), newContent);
    });
}
exports.mkReencryptFromPublicKeyToPassword = mkReencryptFromPublicKeyToPassword;
//# sourceMappingURL=ppk.js.map