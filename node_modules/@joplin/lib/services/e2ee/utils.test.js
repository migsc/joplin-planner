"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const test_utils_1 = require("../../testing/test-utils");
const MasterKey_1 = require("../../models/MasterKey");
const utils_1 = require("./utils");
const syncInfoUtils_1 = require("../synchronizer/syncInfoUtils");
const Setting_1 = require("../../models/Setting");
const ppk_1 = require("./ppk");
describe('e2ee/utils', function () {
    beforeEach((done) => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.switchClient)(1);
        done();
    }));
    afterAll(() => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.afterAllCleanUp)();
    }));
    it('should tell if the missing master key message should be shown', () => __awaiter(this, void 0, void 0, function* () {
        const mk1 = yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey('111111'));
        const mk2 = yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey('111111'));
        expect((0, utils_1.showMissingMasterKeyMessage)((0, syncInfoUtils_1.localSyncInfo)(), [mk1.id])).toBe(true);
        expect((0, utils_1.showMissingMasterKeyMessage)((0, syncInfoUtils_1.localSyncInfo)(), [mk1.id, mk2.id])).toBe(true);
        expect((0, utils_1.showMissingMasterKeyMessage)((0, syncInfoUtils_1.localSyncInfo)(), [])).toBe(false);
        (0, syncInfoUtils_1.setMasterKeyEnabled)(mk1.id, false);
        expect((0, utils_1.showMissingMasterKeyMessage)((0, syncInfoUtils_1.localSyncInfo)(), [mk1.id])).toBe(false);
        expect((0, utils_1.showMissingMasterKeyMessage)((0, syncInfoUtils_1.localSyncInfo)(), [mk1.id, mk2.id])).toBe(true);
        (0, syncInfoUtils_1.setMasterKeyEnabled)(mk2.id, false);
        expect((0, utils_1.showMissingMasterKeyMessage)((0, syncInfoUtils_1.localSyncInfo)(), [mk1.id, mk2.id])).toBe(false);
        (0, syncInfoUtils_1.setMasterKeyEnabled)(mk1.id, true);
        (0, syncInfoUtils_1.setMasterKeyEnabled)(mk2.id, true);
        expect((0, utils_1.showMissingMasterKeyMessage)((0, syncInfoUtils_1.localSyncInfo)(), [mk1.id, mk2.id])).toBe(true);
        yield (0, test_utils_1.expectNotThrow)(() => __awaiter(this, void 0, void 0, function* () { return (0, utils_1.showMissingMasterKeyMessage)((0, syncInfoUtils_1.localSyncInfo)(), ['not_downloaded_yet']); }));
        const syncInfo = (0, syncInfoUtils_1.localSyncInfo)();
        syncInfo.masterKeys = [];
        expect((0, utils_1.showMissingMasterKeyMessage)(syncInfo, [mk1.id, mk2.id])).toBe(false);
    }));
    it('should do the master password migration', () => __awaiter(this, void 0, void 0, function* () {
        const mk1 = yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey('111111'));
        const mk2 = yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey('222222'));
        Setting_1.default.setValue('encryption.passwordCache', {
            [mk1.id]: '111111',
            [mk2.id]: '222222',
        });
        yield (0, utils_1.migrateMasterPassword)();
        {
            expect(Setting_1.default.value('encryption.masterPassword')).toBe('');
            const newCache = Setting_1.default.value('encryption.passwordCache');
            expect(newCache[mk1.id]).toBe('111111');
            expect(newCache[mk2.id]).toBe('222222');
        }
        (0, syncInfoUtils_1.setActiveMasterKeyId)(mk1.id);
        yield (0, utils_1.migrateMasterPassword)();
        {
            expect(Setting_1.default.value('encryption.masterPassword')).toBe('111111');
            const newCache = Setting_1.default.value('encryption.passwordCache');
            expect(newCache[mk1.id]).toBe(undefined);
            expect(newCache[mk2.id]).toBe('222222');
        }
    }));
    it('should update the master password', () => __awaiter(this, void 0, void 0, function* () {
        const masterPassword1 = '111111';
        const masterPassword2 = '222222';
        Setting_1.default.setValue('encryption.masterPassword', masterPassword1);
        const mk1 = yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey(masterPassword1));
        const mk2 = yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey(masterPassword1));
        (0, syncInfoUtils_1.setPpk)(yield (0, ppk_1.generateKeyPair)((0, test_utils_1.encryptionService)(), masterPassword1));
        yield (0, utils_1.updateMasterPassword)(masterPassword1, masterPassword2);
        expect(Setting_1.default.value('encryption.masterPassword')).toBe(masterPassword2);
        expect(yield (0, ppk_1.ppkPasswordIsValid)((0, test_utils_1.encryptionService)(), (0, syncInfoUtils_1.localSyncInfo)().ppk, masterPassword1)).toBe(false);
        expect(yield (0, ppk_1.ppkPasswordIsValid)((0, test_utils_1.encryptionService)(), (0, syncInfoUtils_1.localSyncInfo)().ppk, masterPassword2)).toBe(true);
        expect(yield (0, test_utils_1.encryptionService)().checkMasterKeyPassword(yield MasterKey_1.default.load(mk1.id), masterPassword1)).toBe(false);
        expect(yield (0, test_utils_1.encryptionService)().checkMasterKeyPassword(yield MasterKey_1.default.load(mk2.id), masterPassword1)).toBe(false);
        expect(yield (0, test_utils_1.encryptionService)().checkMasterKeyPassword(yield MasterKey_1.default.load(mk1.id), masterPassword2)).toBe(true);
        expect(yield (0, test_utils_1.encryptionService)().checkMasterKeyPassword(yield MasterKey_1.default.load(mk2.id), masterPassword2)).toBe(true);
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return (0, utils_1.updateMasterPassword)('wrong', masterPassword1); }));
    }));
    it('should set and verify master password when a data key exists', () => __awaiter(this, void 0, void 0, function* () {
        const password = '111111';
        yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey(password));
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return (0, utils_1.updateMasterPassword)('', 'wrong'); }));
        yield (0, test_utils_1.expectNotThrow)(() => __awaiter(this, void 0, void 0, function* () { return (0, utils_1.updateMasterPassword)('', password); }));
        expect(Setting_1.default.value('encryption.masterPassword')).toBe(password);
    }));
    it('should set and verify master password when a private key exists', () => __awaiter(this, void 0, void 0, function* () {
        const password = '111111';
        (0, syncInfoUtils_1.setPpk)(yield (0, ppk_1.generateKeyPair)((0, test_utils_1.encryptionService)(), password));
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return (0, utils_1.updateMasterPassword)('', 'wrong'); }));
        yield (0, test_utils_1.expectNotThrow)(() => __awaiter(this, void 0, void 0, function* () { return (0, utils_1.updateMasterPassword)('', password); }));
        expect(Setting_1.default.value('encryption.masterPassword')).toBe(password);
    }));
    it('should only set the master password if not already set', () => __awaiter(this, void 0, void 0, function* () {
        expect((0, syncInfoUtils_1.localSyncInfo)().ppk).toBeFalsy();
        yield (0, utils_1.updateMasterPassword)('', '111111');
        expect(Setting_1.default.value('encryption.masterPassword')).toBe('111111');
        expect((0, syncInfoUtils_1.localSyncInfo)().ppk).toBeFalsy();
        expect((0, syncInfoUtils_1.localSyncInfo)().masterKeys.length).toBe(0);
    }));
    it('should change the master password even if no key is present', () => __awaiter(this, void 0, void 0, function* () {
        yield (0, utils_1.updateMasterPassword)('', '111111');
        expect(Setting_1.default.value('encryption.masterPassword')).toBe('111111');
        yield (0, utils_1.updateMasterPassword)('111111', '222222');
        expect(Setting_1.default.value('encryption.masterPassword')).toBe('222222');
    }));
    it('should reset a master password', () => __awaiter(this, void 0, void 0, function* () {
        const masterPassword1 = '111111';
        const masterPassword2 = '222222';
        Setting_1.default.setValue('encryption.masterPassword', masterPassword1);
        const mk1 = yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey(masterPassword1));
        const mk2 = yield MasterKey_1.default.save(yield (0, test_utils_1.encryptionService)().generateMasterKey(masterPassword1));
        (0, syncInfoUtils_1.setPpk)(yield (0, ppk_1.generateKeyPair)((0, test_utils_1.encryptionService)(), masterPassword1));
        const previousPpk = (0, syncInfoUtils_1.localSyncInfo)().ppk;
        yield (0, utils_1.resetMasterPassword)((0, test_utils_1.encryptionService)(), (0, test_utils_1.kvStore)(), null, masterPassword2);
        expect((0, syncInfoUtils_1.masterKeyEnabled)((0, syncInfoUtils_1.masterKeyById)(mk1.id))).toBe(false);
        expect((0, syncInfoUtils_1.masterKeyEnabled)((0, syncInfoUtils_1.masterKeyById)(mk2.id))).toBe(false);
        expect((0, syncInfoUtils_1.localSyncInfo)().ppk.id).not.toBe(previousPpk.id);
        expect((0, syncInfoUtils_1.localSyncInfo)().ppk.privateKey.ciphertext).not.toBe(previousPpk.privateKey.ciphertext);
        expect((0, syncInfoUtils_1.localSyncInfo)().ppk.publicKey).not.toBe(previousPpk.publicKey);
    }));
});
//# sourceMappingURL=utils.test.js.map