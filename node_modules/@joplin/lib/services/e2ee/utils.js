"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.masterKeysWithoutPassword = exports.masterPasswordIsValid = exports.getMasterPasswordStatusMessage = exports.checkHasMasterPasswordEncryptedData = exports.getMasterPasswordStatus = exports.MasterPasswordStatus = exports.resetMasterPassword = exports.updateMasterPassword = exports.getMasterPassword = exports.getDefaultMasterKey = exports.showMissingMasterKeyMessage = exports.loadMasterKeysFromSettings = exports.findMasterKeyPassword = exports.migrateMasterPassword = exports.generateMasterKeyAndEnableEncryption = exports.toggleAndSetupEncryption = exports.setupAndDisableEncryption = exports.setupAndEnableEncryption = void 0;
const Logger_1 = require("../../Logger");
const BaseItem_1 = require("../../models/BaseItem");
const MasterKey_1 = require("../../models/MasterKey");
const Setting_1 = require("../../models/Setting");
const EncryptionService_1 = require("./EncryptionService");
const syncInfoUtils_1 = require("../synchronizer/syncInfoUtils");
const JoplinError_1 = require("../../JoplinError");
const ppk_1 = require("./ppk");
const Folder_1 = require("../../models/Folder");
const logger = Logger_1.default.create('e2ee/utils');
function setupAndEnableEncryption(service, masterKey = null, masterPassword = null) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!masterKey) {
            // May happen for example if there are master keys in info.json but none
            // of them is set as active. But in fact, unless there is a bug in the
            // application, this shouldn't happen.
            logger.warn('Setting up E2EE without a master key - user will need to either generate one or select one of the existing ones as active');
        }
        (0, syncInfoUtils_1.setEncryptionEnabled)(true, masterKey ? masterKey.id : null);
        if (masterPassword) {
            Setting_1.default.setValue('encryption.masterPassword', masterPassword);
        }
        // Mark only the non-encrypted ones for sync since, if there are encrypted ones,
        // it means they come from the sync target and are already encrypted over there.
        yield BaseItem_1.default.markAllNonEncryptedForSync();
        yield loadMasterKeysFromSettings(service);
    });
}
exports.setupAndEnableEncryption = setupAndEnableEncryption;
function setupAndDisableEncryption(service) {
    return __awaiter(this, void 0, void 0, function* () {
        // Allow disabling encryption even if some items are still encrypted, because whether E2EE is enabled or disabled
        // should not affect whether items will enventually be decrypted or not (DecryptionWorker will still work as
        // long as there are encrypted items). Also even if decryption is disabled, it's possible that encrypted items
        // will still be received via synchronisation.
        (0, syncInfoUtils_1.setEncryptionEnabled)(false);
        // The only way to make sure everything gets decrypted on the sync target is
        // to re-sync everything.
        yield BaseItem_1.default.forceSyncAll();
        yield loadMasterKeysFromSettings(service);
    });
}
exports.setupAndDisableEncryption = setupAndDisableEncryption;
function toggleAndSetupEncryption(service, enabled, masterKey, password) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.info('toggleAndSetupEncryption: enabled:', enabled, ' Master key', masterKey);
        if (!enabled) {
            yield setupAndDisableEncryption(service);
        }
        else {
            if (masterKey) {
                yield setupAndEnableEncryption(service, masterKey, password);
            }
            else {
                yield generateMasterKeyAndEnableEncryption(EncryptionService_1.default.instance(), password);
            }
        }
        yield loadMasterKeysFromSettings(service);
    });
}
exports.toggleAndSetupEncryption = toggleAndSetupEncryption;
function generateMasterKeyAndEnableEncryption(service, password) {
    return __awaiter(this, void 0, void 0, function* () {
        let masterKey = yield service.generateMasterKey(password);
        masterKey = yield MasterKey_1.default.save(masterKey);
        yield setupAndEnableEncryption(service, masterKey, password);
        yield loadMasterKeysFromSettings(service);
        return masterKey;
    });
}
exports.generateMasterKeyAndEnableEncryption = generateMasterKeyAndEnableEncryption;
// Migration function to initialise the master password. Normally it is set when
// enabling E2EE, but previously it wasn't. So here we check if the password is
// set. If it is not, we set it from the active master key. It needs to be
// called after the settings have been initialized.
function migrateMasterPassword() {
    return __awaiter(this, void 0, void 0, function* () {
        // Already migrated
        if (Setting_1.default.value('encryption.masterPassword'))
            return;
        // If a PPK is defined it means the master password has been set at some
        // point so no need to run the migration
        if ((0, syncInfoUtils_1.localSyncInfo)().ppk)
            return;
        // If a PPK is defined it means the master password has been set at some
        // point so no need to run the migration
        if ((0, syncInfoUtils_1.localSyncInfo)().ppk)
            return;
        logger.info('Master password is not set - trying to get it from the active master key...');
        const mk = (0, syncInfoUtils_1.getActiveMasterKey)();
        if (!mk)
            return;
        const masterPassword = Setting_1.default.value('encryption.passwordCache')[mk.id];
        if (masterPassword) {
            Setting_1.default.setValue('encryption.masterPassword', masterPassword);
            logger.info('Master password is now set.');
            // Also clear the key passwords that match the master password to avoid
            // any confusion.
            const cache = Setting_1.default.value('encryption.passwordCache');
            const newCache = Object.assign({}, cache);
            for (const [mkId, password] of Object.entries(cache)) {
                if (password === masterPassword) {
                    delete newCache[mkId];
                }
            }
            Setting_1.default.setValue('encryption.passwordCache', newCache);
            yield Setting_1.default.saveAll();
        }
    });
}
exports.migrateMasterPassword = migrateMasterPassword;
// All master keys normally should be decryped with the master password, however
// previously any master key could be encrypted with any password, so to support
// this legacy case, we first check if the MK decrypts with the master password.
// If not, try with the master key specific password, if any is defined.
function findMasterKeyPassword(service, masterKey, passwordCache = null) {
    return __awaiter(this, void 0, void 0, function* () {
        const masterPassword = Setting_1.default.value('encryption.masterPassword');
        if (masterPassword && (yield service.checkMasterKeyPassword(masterKey, masterPassword))) {
            logger.info('findMasterKeyPassword: Using master password');
            return masterPassword;
        }
        logger.info('findMasterKeyPassword: No master password is defined - trying to get master key specific password');
        const passwords = passwordCache ? passwordCache : Setting_1.default.value('encryption.passwordCache');
        return passwords[masterKey.id];
    });
}
exports.findMasterKeyPassword = findMasterKeyPassword;
function loadMasterKeysFromSettings(service) {
    return __awaiter(this, void 0, void 0, function* () {
        const masterKeys = yield MasterKey_1.default.all();
        const activeMasterKeyId = (0, syncInfoUtils_1.getActiveMasterKeyId)();
        logger.info(`Trying to load ${masterKeys.length} master keys...`);
        for (let i = 0; i < masterKeys.length; i++) {
            const mk = masterKeys[i];
            if (service.isMasterKeyLoaded(mk))
                continue;
            const password = yield findMasterKeyPassword(service, mk);
            if (!password)
                continue;
            try {
                yield service.loadMasterKey(mk, password, activeMasterKeyId === mk.id);
            }
            catch (error) {
                logger.warn(`Cannot load master key ${mk.id}. Invalid password?`, error);
            }
        }
        logger.info(`Loaded master keys: ${service.loadedMasterKeysCount()}`);
    });
}
exports.loadMasterKeysFromSettings = loadMasterKeysFromSettings;
function showMissingMasterKeyMessage(syncInfo, notLoadedMasterKeys) {
    if (!syncInfo.masterKeys.length)
        return false;
    notLoadedMasterKeys = notLoadedMasterKeys.slice();
    for (let i = notLoadedMasterKeys.length - 1; i >= 0; i--) {
        const mk = syncInfo.masterKeys.find(mk => mk.id === notLoadedMasterKeys[i]);
        // A "notLoadedMasterKey" is a key that either doesn't exist or for
        // which a password hasn't been set yet. For the purpose of this
        // function, we only want to notify the user about unset passwords.
        // Master keys that haven't been downloaded yet should normally be
        // downloaded at some point.
        // https://github.com/laurent22/joplin/issues/5391
        if (!mk)
            continue;
        if (!(0, syncInfoUtils_1.masterKeyEnabled)(mk))
            notLoadedMasterKeys.pop();
    }
    return !!notLoadedMasterKeys.length;
}
exports.showMissingMasterKeyMessage = showMissingMasterKeyMessage;
function getDefaultMasterKey() {
    let mk = (0, syncInfoUtils_1.getActiveMasterKey)();
    if (!mk || (0, syncInfoUtils_1.masterKeyEnabled)(mk)) {
        mk = MasterKey_1.default.latest();
    }
    return mk && (0, syncInfoUtils_1.masterKeyEnabled)(mk) ? mk : null;
}
exports.getDefaultMasterKey = getDefaultMasterKey;
// Get the master password if set, or throw an exception. This ensures that
// things aren't accidentally encrypted with an empty string. Calling code
// should look for "undefinedMasterPassword" code and prompt for password.
function getMasterPassword(throwIfNotSet = true) {
    const password = Setting_1.default.value('encryption.masterPassword');
    if (!password && throwIfNotSet)
        throw new JoplinError_1.default('Master password is not set', 'undefinedMasterPassword');
    return password;
}
exports.getMasterPassword = getMasterPassword;
// - If both a current and new password is provided, and they are different, it
//   means the password is being changed, so all the keys are reencrypted with
//   the new password.
// - If the current password is not provided, the master password is simply set
//   according to newPassword.
function updateMasterPassword(currentPassword, newPassword) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!newPassword)
            throw new Error('New password must be set');
        if (currentPassword && !(yield masterPasswordIsValid(currentPassword)))
            throw new Error('Master password is not valid. Please try again.');
        const needToReencrypt = !!currentPassword && !!newPassword && currentPassword !== newPassword;
        if (needToReencrypt) {
            const reencryptedMasterKeys = [];
            let reencryptedPpk = null;
            for (const mk of (0, syncInfoUtils_1.localSyncInfo)().masterKeys) {
                try {
                    reencryptedMasterKeys.push(yield EncryptionService_1.default.instance().reencryptMasterKey(mk, currentPassword, newPassword));
                }
                catch (error) {
                    if (!(0, syncInfoUtils_1.masterKeyEnabled)(mk))
                        continue; // Ignore if the master key is disabled, because the password is probably forgotten
                    error.message = `Key ${mk.id} could not be reencrypted - this is most likely due to an incorrect password. Please try again. Error was: ${error.message}`;
                    throw error;
                }
            }
            if ((0, syncInfoUtils_1.localSyncInfo)().ppk) {
                try {
                    reencryptedPpk = yield (0, ppk_1.pkReencryptPrivateKey)(EncryptionService_1.default.instance(), (0, syncInfoUtils_1.localSyncInfo)().ppk, currentPassword, newPassword);
                }
                catch (error) {
                    error.message = `Private key could not be reencrypted - this is most likely due to an incorrect password. Please try again. Error was: ${error.message}`;
                    throw error;
                }
            }
            for (const mk of reencryptedMasterKeys) {
                yield MasterKey_1.default.save(mk);
            }
            if (reencryptedPpk) {
                const syncInfo = (0, syncInfoUtils_1.localSyncInfo)();
                syncInfo.ppk = reencryptedPpk;
                (0, syncInfoUtils_1.saveLocalSyncInfo)(syncInfo);
            }
        }
        else {
            if (!currentPassword && !(yield masterPasswordIsValid(newPassword)))
                throw new Error('Master password is not valid. Please try again.');
        }
        Setting_1.default.setValue('encryption.masterPassword', newPassword);
    });
}
exports.updateMasterPassword = updateMasterPassword;
const unshareEncryptedFolders = (shareService, masterKeyId) => __awaiter(void 0, void 0, void 0, function* () {
    const rootFolders = yield Folder_1.default.rootShareFoldersByKeyId(masterKeyId);
    for (const folder of rootFolders) {
        const isOwner = shareService.isSharedFolderOwner(folder.id);
        if (isOwner) {
            yield shareService.unshareFolder(folder.id);
        }
        else {
            yield shareService.leaveSharedFolder(folder.id);
        }
    }
});
function resetMasterPassword(encryptionService, kvStore, shareService, newPassword) {
    return __awaiter(this, void 0, void 0, function* () {
        // First thing we do is to unshare all shared folders. If that fails, which
        // may happen in particular if no connection is available, then we don't
        // proceed. `unshareEncryptedFolders` will throw if something cannot be
        // done.
        if (shareService) {
            for (const mk of (0, syncInfoUtils_1.localSyncInfo)().masterKeys) {
                if (!(0, syncInfoUtils_1.masterKeyEnabled)(mk))
                    continue;
                yield unshareEncryptedFolders(shareService, mk.id);
            }
        }
        for (const mk of (0, syncInfoUtils_1.localSyncInfo)().masterKeys) {
            if (!(0, syncInfoUtils_1.masterKeyEnabled)(mk))
                continue;
            mk.enabled = 0;
            yield MasterKey_1.default.save(mk);
        }
        const syncInfo = (0, syncInfoUtils_1.localSyncInfo)();
        if (syncInfo.ppk) {
            yield kvStore.setValue(`oldppk::${Date.now()}`, JSON.stringify(syncInfo.ppk));
            syncInfo.ppk = yield (0, ppk_1.generateKeyPair)(encryptionService, newPassword);
            (0, syncInfoUtils_1.saveLocalSyncInfo)(syncInfo);
        }
        Setting_1.default.setValue('encryption.masterPassword', newPassword);
    });
}
exports.resetMasterPassword = resetMasterPassword;
var MasterPasswordStatus;
(function (MasterPasswordStatus) {
    MasterPasswordStatus[MasterPasswordStatus["Unknown"] = 0] = "Unknown";
    MasterPasswordStatus[MasterPasswordStatus["Loaded"] = 1] = "Loaded";
    MasterPasswordStatus[MasterPasswordStatus["NotSet"] = 2] = "NotSet";
    MasterPasswordStatus[MasterPasswordStatus["Invalid"] = 3] = "Invalid";
    MasterPasswordStatus[MasterPasswordStatus["Valid"] = 4] = "Valid";
})(MasterPasswordStatus = exports.MasterPasswordStatus || (exports.MasterPasswordStatus = {}));
function getMasterPasswordStatus(password = null) {
    return __awaiter(this, void 0, void 0, function* () {
        password = password === null ? getMasterPassword(false) : password;
        if (!password)
            return MasterPasswordStatus.NotSet;
        const isValid = yield masterPasswordIsValid(password);
        return isValid ? MasterPasswordStatus.Valid : MasterPasswordStatus.Invalid;
    });
}
exports.getMasterPasswordStatus = getMasterPasswordStatus;
function checkHasMasterPasswordEncryptedData(syncInfo = null) {
    return __awaiter(this, void 0, void 0, function* () {
        syncInfo = syncInfo ? syncInfo : (0, syncInfoUtils_1.localSyncInfo)();
        return !!syncInfo.ppk || !!syncInfo.masterKeys.length;
    });
}
exports.checkHasMasterPasswordEncryptedData = checkHasMasterPasswordEncryptedData;
const masterPasswordStatusMessages = {
    [MasterPasswordStatus.Unknown]: 'Checking...',
    [MasterPasswordStatus.Loaded]: 'Loaded',
    [MasterPasswordStatus.NotSet]: 'Not set',
    [MasterPasswordStatus.Valid]: '✓ ' + 'Valid',
    [MasterPasswordStatus.Invalid]: '❌ ' + 'Invalid',
};
function getMasterPasswordStatusMessage(status) {
    return masterPasswordStatusMessages[status];
}
exports.getMasterPasswordStatusMessage = getMasterPasswordStatusMessage;
function masterPasswordIsValid(masterPassword, activeMasterKey = null) {
    return __awaiter(this, void 0, void 0, function* () {
        // A valid password is basically one that decrypts the private key, but due
        // to backward compatibility not all users have a PPK yet, so we also check
        // based on the active master key.
        if (!masterPassword)
            throw new Error('Password is empty');
        const ppk = (0, syncInfoUtils_1.localSyncInfo)().ppk;
        if (ppk) {
            return (0, ppk_1.ppkPasswordIsValid)(EncryptionService_1.default.instance(), ppk, masterPassword);
        }
        const masterKey = activeMasterKey ? activeMasterKey : getDefaultMasterKey();
        if (masterKey) {
            return EncryptionService_1.default.instance().checkMasterKeyPassword(masterKey, masterPassword);
        }
        // If the password has never been set, then whatever password is provided is considered valid.
        if (!Setting_1.default.value('encryption.masterPassword'))
            return true;
        // There may not be any key to decrypt if the master password has been set,
        // but the user has never synchronized. In which case, it's sufficient to
        // compare to whatever they've entered earlier.
        return Setting_1.default.value('encryption.masterPassword') === masterPassword;
    });
}
exports.masterPasswordIsValid = masterPasswordIsValid;
function masterKeysWithoutPassword() {
    return __awaiter(this, void 0, void 0, function* () {
        const syncInfo = (0, syncInfoUtils_1.localSyncInfo)();
        const passwordCache = Setting_1.default.value('encryption.passwordCache');
        const output = [];
        for (const mk of syncInfo.masterKeys) {
            if (!(0, syncInfoUtils_1.masterKeyEnabled)(mk))
                continue;
            const password = yield findMasterKeyPassword(EncryptionService_1.default.instance(), mk, passwordCache);
            if (!password)
                output.push(mk.id);
        }
        return output;
    });
}
exports.masterKeysWithoutPassword = masterKeysWithoutPassword;
//# sourceMappingURL=utils.js.map