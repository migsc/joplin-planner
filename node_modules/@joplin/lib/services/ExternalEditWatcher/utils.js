"use strict";
/* eslint-disable import/prefer-default-export */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.openFileWithExternalEditor = void 0;
const { splitCommandString } = require('../../string-utils');
const child_process_1 = require("child_process");
const Logger_1 = require("../../Logger");
const Setting_1 = require("../../models/Setting");
const path_utils_1 = require("../../path-utils");
const shim_1 = require("../../shim");
const logger = Logger_1.default.create('ExternalEditWatcher/utils');
const spawnCommand = (path, args, options) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
        // App bundles need to be opened using the `open` command.
        // Additional args can be specified after --args, and the
        // -n flag is needed to ensure that the app is always launched
        // with the arguments. Without it, if the app is already opened,
        // it will just bring it to the foreground without opening the file.
        // So the full command is:
        //
        // open -n /path/to/editor.app --args -app-flag -bla /path/to/file.md
        //
        if (shim_1.default.isMac() && (0, path_utils_1.fileExtension)(path) === 'app') {
            args = args.slice();
            args.splice(0, 0, '--args');
            args.splice(0, 0, path);
            args.splice(0, 0, '-n');
            path = 'open';
        }
        const wrapError = (error) => {
            if (!error)
                return error;
            const msg = error.message ? [error.message] : [];
            msg.push(`Command was: "${path}" ${args.join(' ')}`);
            error.message = msg.join('\n\n');
            return error;
        };
        try {
            const subProcess = (0, child_process_1.spawn)(path, args, options);
            const iid = shim_1.default.setInterval(() => {
                if (subProcess && subProcess.pid) {
                    logger.debug(`Started editor with PID ${subProcess.pid}`);
                    shim_1.default.clearInterval(iid);
                    resolve(null);
                }
            }, 100);
            subProcess.on('error', (error) => {
                shim_1.default.clearInterval(iid);
                reject(wrapError(error));
            });
        }
        catch (error) {
            throw wrapError(error);
        }
    });
});
const textEditorCommand = () => {
    const editorCommand = Setting_1.default.value('editor');
    if (!editorCommand)
        return null;
    const s = splitCommandString(editorCommand, { handleEscape: false });
    const path = s.splice(0, 1);
    if (!path.length)
        throw new Error(`Invalid editor command: ${editorCommand}`);
    return {
        path: path[0],
        args: s,
    };
};
const openFileWithExternalEditor = (filePath, bridge) => __awaiter(void 0, void 0, void 0, function* () {
    const cmd = textEditorCommand();
    if (!cmd) {
        bridge.openExternal(`file://${filePath}`);
    }
    else {
        cmd.args.push(filePath);
        yield spawnCommand(cmd.path, cmd.args, { detached: true });
    }
});
exports.openFileWithExternalEditor = openFileWithExternalEditor;
//# sourceMappingURL=utils.js.map