"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseService_1 = require("./BaseService");
const Mutex = require('async-mutex').Mutex;
var ValueType;
(function (ValueType) {
    ValueType[ValueType["Int"] = 1] = "Int";
    ValueType[ValueType["Text"] = 2] = "Text";
})(ValueType || (ValueType = {}));
class KvStore extends BaseService_1.default {
    constructor() {
        super();
        this.incMutex_ = null;
        this.db_ = null;
        this.incMutex_ = new Mutex();
    }
    static instance() {
        if (this.instance_)
            return this.instance_;
        this.instance_ = new KvStore();
        return this.instance_;
    }
    static destroyInstance() {
        this.instance_ = null;
    }
    setDb(v) {
        this.db_ = v;
    }
    db() {
        if (!this.db_)
            throw new Error('Accessing DB before it has been set!');
        return this.db_;
    }
    typeFromValue_(value) {
        if (typeof value === 'string')
            return ValueType.Text;
        if (typeof value === 'number')
            return ValueType.Int;
        throw new Error(`Unsupported value type: ${typeof value}`);
    }
    formatValues_(kvs) {
        const output = [];
        for (const kv of kvs) {
            kv.value = this.formatValue_(kv.value, kv.type);
            output.push(kv);
        }
        return output;
    }
    formatValue_(value, type) {
        if (type === ValueType.Int)
            return Number(value);
        if (type === ValueType.Text)
            return `${value}`;
        throw new Error(`Unknown type: ${type}`);
    }
    value(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.db().selectOne('SELECT `value`, `type` FROM key_values WHERE `key` = ?', [key]);
            if (!r)
                return null;
            return this.formatValue_(r.value, r.type);
        });
    }
    setValue(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const t = Date.now();
            yield this.db().exec('INSERT OR REPLACE INTO key_values (`key`, `value`, `type`, `updated_time`) VALUES (?, ?, ?, ?)', [key, value, this.typeFromValue_(value), t]);
        });
    }
    deleteValue(key) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.db().exec('DELETE FROM key_values WHERE `key` = ?', [key]);
        });
    }
    deleteByPrefix(prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.db().exec('DELETE FROM key_values WHERE `key` LIKE ?', [`${prefix}%`]);
        });
    }
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.db().exec('DELETE FROM key_values');
        });
    }
    all() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.formatValues_(yield this.db().selectAll('SELECT * FROM key_values'));
        });
    }
    // Note: atomicity is done at application level so two difference instances
    // accessing the db at the same time could mess up the increment.
    incValue(key, inc = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            const release = yield this.incMutex_.acquire();
            try {
                const result = yield this.db().selectOne('SELECT `value`, `type` FROM key_values WHERE `key` = ?', [key]);
                const newValue = result ? this.formatValue_(result.value, result.type) + inc : inc;
                yield this.setValue(key, newValue);
                release();
                return newValue;
            }
            catch (error) {
                release();
                throw error;
            }
        });
    }
    searchByPrefix(prefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield this.db().selectAll('SELECT `key`, `value`, `type` FROM key_values WHERE `key` LIKE ?', [`${prefix}%`]);
            return this.formatValues_(results);
        });
    }
    countKeys() {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.db().selectOne('SELECT count(*) as total FROM key_values');
            return r.total ? r.total : 0;
        });
    }
}
exports.default = KvStore;
KvStore.instance_ = null;
//# sourceMappingURL=KvStore.js.map