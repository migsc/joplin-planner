"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseItem_1 = require("../models/BaseItem");
const BaseModel_1 = require("../BaseModel");
const MasterKey_1 = require("../models/MasterKey");
const Resource_1 = require("../models/Resource");
const ResourceService_1 = require("./ResourceService");
const Logger_1 = require("../Logger");
const shim_1 = require("../shim");
const EventEmitter = require('events');
class DecryptionWorker {
    constructor() {
        this.state_ = 'idle';
        this.dispatch = () => { };
        this.scheduleId_ = null;
        this.kvStore_ = null;
        this.maxDecryptionAttempts_ = 2;
        this.startCalls_ = [];
        this.encryptionService_ = null;
        this.state_ = 'idle';
        this.logger_ = new Logger_1.default();
        this.eventEmitter_ = new EventEmitter();
    }
    setLogger(l) {
        this.logger_ = l;
    }
    logger() {
        return this.logger_;
    }
    on(eventName, callback) {
        return this.eventEmitter_.on(eventName, callback);
    }
    off(eventName, callback) {
        return this.eventEmitter_.removeListener(eventName, callback);
    }
    static instance() {
        if (DecryptionWorker.instance_)
            return DecryptionWorker.instance_;
        DecryptionWorker.instance_ = new DecryptionWorker();
        return DecryptionWorker.instance_;
    }
    setEncryptionService(v) {
        this.encryptionService_ = v;
    }
    setKvStore(v) {
        this.kvStore_ = v;
    }
    encryptionService() {
        if (!this.encryptionService_)
            throw new Error('DecryptionWorker.encryptionService_ is not set!!');
        return this.encryptionService_;
    }
    kvStore() {
        if (!this.kvStore_)
            throw new Error('DecryptionWorker.kvStore_ is not set!!');
        return this.kvStore_;
    }
    scheduleStart() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.scheduleId_)
                return;
            this.scheduleId_ = shim_1.default.setTimeout(() => {
                this.scheduleId_ = null;
                void this.start({
                    masterKeyNotLoadedHandler: 'dispatch',
                });
            }, 1000);
        });
    }
    decryptionDisabledItems() {
        return __awaiter(this, void 0, void 0, function* () {
            let items = yield this.kvStore().searchByPrefix('decrypt:');
            items = items.filter(item => item.value > this.maxDecryptionAttempts_);
            items = items.map(item => {
                const s = item.key.split(':');
                return {
                    type_: Number(s[1]),
                    id: s[2],
                };
            });
            return items;
        });
    }
    clearDisabledItem(typeId, itemId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.kvStore().deleteValue(`decrypt:${typeId}:${itemId}`);
        });
    }
    clearDisabledItems() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.kvStore().deleteByPrefix('decrypt:');
        });
    }
    dispatchReport(report) {
        const action = Object.assign({}, report);
        action.type = 'DECRYPTION_WORKER_SET';
        this.dispatch(action);
    }
    start_(options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options === null)
                options = {};
            if (!('masterKeyNotLoadedHandler' in options))
                options.masterKeyNotLoadedHandler = 'throw';
            if (!('errorHandler' in options))
                options.errorHandler = 'log';
            if (this.state_ !== 'idle') {
                const msg = `DecryptionWorker: cannot start because state is "${this.state_}"`;
                this.logger().debug(msg);
                return { error: new Error(msg) };
            }
            // Note: the logic below is an optimisation to avoid going through the loop if no master key exists
            // or if none is loaded. It means this logic needs to be duplicate a bit what's in the loop, like the
            // "throw" and "dispatch" logic.
            const loadedMasterKeyCount = yield this.encryptionService().loadedMasterKeysCount();
            if (!loadedMasterKeyCount) {
                const msg = 'DecryptionWorker: cannot start because no master key is currently loaded.';
                this.logger().info(msg);
                const ids = yield MasterKey_1.default.allIds();
                // Note that the current implementation means that a warning will be
                // displayed even if the user has no encrypted note. Just having
                // encrypted master key is sufficient. Not great but good enough for
                // now.
                if (ids.length) {
                    if (options.masterKeyNotLoadedHandler === 'throw') {
                        // By trying to load the master key here, we throw the "masterKeyNotLoaded" error
                        // which the caller needs.
                        yield this.encryptionService().loadedMasterKey(ids[0]);
                    }
                    else {
                        this.dispatch({
                            type: 'MASTERKEY_SET_NOT_LOADED',
                            ids: ids,
                        });
                    }
                }
                return { error: new Error(msg) };
            }
            this.logger().info('DecryptionWorker: starting decryption...');
            this.state_ = 'started';
            const excludedIds = [];
            const decryptedItemCounts = {};
            let skippedItemCount = 0;
            this.dispatch({ type: 'ENCRYPTION_HAS_DISABLED_ITEMS', value: false });
            this.dispatchReport({ state: 'started' });
            try {
                const notLoadedMasterKeyDisptaches = [];
                while (true) {
                    const result = yield BaseItem_1.default.itemsThatNeedDecryption(excludedIds);
                    const items = result.items;
                    for (let i = 0; i < items.length; i++) {
                        const item = items[i];
                        const ItemClass = BaseItem_1.default.itemClass(item);
                        this.dispatchReport({
                            itemIndex: i,
                            itemCount: items.length,
                        });
                        const counterKey = `decrypt:${item.type_}:${item.id}`;
                        const clearDecryptionCounter = () => __awaiter(this, void 0, void 0, function* () {
                            yield this.kvStore().deleteValue(counterKey);
                        });
                        // Don't log in production as it results in many messages when importing many items
                        // this.logger().debug('DecryptionWorker: decrypting: ' + item.id + ' (' + ItemClass.tableName() + ')');
                        try {
                            const decryptCounter = yield this.kvStore().incValue(counterKey);
                            if (decryptCounter > this.maxDecryptionAttempts_) {
                                this.logger().debug(`DecryptionWorker: ${BaseModel_1.default.modelTypeToName(item.type_)} ${item.id}: Decryption has failed more than 2 times - skipping it`);
                                this.dispatch({ type: 'ENCRYPTION_HAS_DISABLED_ITEMS', value: true });
                                skippedItemCount++;
                                excludedIds.push(item.id);
                                continue;
                            }
                            const decryptedItem = yield ItemClass.decrypt(item);
                            yield clearDecryptionCounter();
                            if (!decryptedItemCounts[decryptedItem.type_])
                                decryptedItemCounts[decryptedItem.type_] = 0;
                            decryptedItemCounts[decryptedItem.type_]++;
                            if (decryptedItem.type_ === Resource_1.default.modelType() && !!decryptedItem.encryption_blob_encrypted) {
                                // itemsThatNeedDecryption() will return the resource again if the blob has not been decrypted,
                                // but that will result in an infinite loop if the blob simply has not been downloaded yet.
                                // So skip the ID for now, and the service will try to decrypt the blob again the next time.
                                excludedIds.push(decryptedItem.id);
                            }
                            if (decryptedItem.type_ === Resource_1.default.modelType() && !decryptedItem.encryption_blob_encrypted) {
                                this.eventEmitter_.emit('resourceDecrypted', { id: decryptedItem.id });
                            }
                            if (decryptedItem.type_ === Resource_1.default.modelType() && !decryptedItem.encryption_applied && !!decryptedItem.encryption_blob_encrypted) {
                                this.eventEmitter_.emit('resourceMetadataButNotBlobDecrypted', { id: decryptedItem.id });
                            }
                        }
                        catch (error) {
                            excludedIds.push(item.id);
                            if (error.code === 'masterKeyNotLoaded' && options.masterKeyNotLoadedHandler === 'dispatch') {
                                if (notLoadedMasterKeyDisptaches.indexOf(error.masterKeyId) < 0) {
                                    this.dispatch({
                                        type: 'MASTERKEY_ADD_NOT_LOADED',
                                        id: error.masterKeyId,
                                    });
                                    notLoadedMasterKeyDisptaches.push(error.masterKeyId);
                                }
                                yield clearDecryptionCounter();
                                continue;
                            }
                            if (error.code === 'masterKeyNotLoaded' && options.masterKeyNotLoadedHandler === 'throw') {
                                yield clearDecryptionCounter();
                                throw error;
                            }
                            if (options.errorHandler === 'log') {
                                this.logger().warn(`DecryptionWorker: error for: ${item.id} (${ItemClass.tableName()})`, error, item);
                            }
                            else {
                                throw error;
                            }
                        }
                    }
                    if (!result.hasMore)
                        break;
                }
            }
            catch (error) {
                this.logger().error('DecryptionWorker:', error);
                this.state_ = 'idle';
                this.dispatchReport({ state: 'idle' });
                throw error;
            }
            // 2019-05-12: Temporary to set the file size of the resources
            // that weren't set in migration/20.js due to being on the sync target
            yield ResourceService_1.default.autoSetFileSizes();
            this.logger().info('DecryptionWorker: completed decryption.');
            const downloadedButEncryptedBlobCount = yield Resource_1.default.downloadedButEncryptedBlobCount(excludedIds);
            this.state_ = 'idle';
            let decryptedItemCount = 0;
            for (const itemType in decryptedItemCounts)
                decryptedItemCount += decryptedItemCounts[itemType];
            const finalReport = {
                skippedItemCount: skippedItemCount,
                decryptedItemCounts: decryptedItemCounts,
                decryptedItemCount: decryptedItemCount,
                error: null,
            };
            this.dispatchReport(Object.assign({}, finalReport, { state: 'idle' }));
            if (downloadedButEncryptedBlobCount) {
                this.logger().info(`DecryptionWorker: Some resources have been downloaded but are not decrypted yet. Scheduling another decryption. Resource count: ${downloadedButEncryptedBlobCount}`);
                void this.scheduleStart();
            }
            return finalReport;
        });
    }
    start(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.startCalls_.push(true);
            let output = null;
            try {
                output = yield this.start_(options);
            }
            finally {
                this.startCalls_.pop();
            }
            return output;
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            this.eventEmitter_.removeAllListeners();
            if (this.scheduleId_) {
                shim_1.default.clearTimeout(this.scheduleId_);
                this.scheduleId_ = null;
            }
            this.eventEmitter_ = null;
            DecryptionWorker.instance_ = null;
            return new Promise((resolve) => {
                const iid = shim_1.default.setInterval(() => {
                    if (!this.startCalls_.length) {
                        shim_1.default.clearInterval(iid);
                        resolve(null);
                    }
                }, 100);
            });
        });
    }
}
exports.default = DecryptionWorker;
DecryptionWorker.instance_ = null;
//# sourceMappingURL=DecryptionWorker.js.map