"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ItemChange_1 = require("../models/ItemChange");
const Note_1 = require("../models/Note");
const Folder_1 = require("../models/Folder");
const Setting_1 = require("../models/Setting");
const Revision_1 = require("../models/Revision");
const BaseModel_1 = require("../BaseModel");
const ItemChangeUtils_1 = require("./ItemChangeUtils");
const shim_1 = require("../shim");
const BaseService_1 = require("./BaseService");
const locale_1 = require("../locale");
const Logger_1 = require("../Logger");
const renderer_1 = require("../../renderer");
const { substrWithEllipsis } = require('../string-utils');
const { sprintf } = require('sprintf-js');
const { wrapError } = require('../errorUtils');
const logger = Logger_1.default.create('RevisionService');
class RevisionService extends BaseService_1.default {
    constructor() {
        super(...arguments);
        // An "old note" is one that has been created before the revision service existed. These
        // notes never benefited from revisions so the first time they are modified, a copy of
        // the original note is saved. The goal is to have at least one revision in case the note
        // is deleted or modified as a result of a bug or user mistake.
        this.isOldNotesCache_ = {};
        this.maintenanceCalls_ = [];
        this.maintenanceTimer1_ = null;
        this.maintenanceTimer2_ = null;
        this.isCollecting_ = false;
        this.isRunningInBackground_ = false;
    }
    static instance() {
        if (this.instance_)
            return this.instance_;
        this.instance_ = new RevisionService();
        return this.instance_;
    }
    oldNoteCutOffDate_() {
        return Date.now() - Setting_1.default.value('revisionService.oldNoteInterval');
    }
    isOldNote(noteId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (noteId in this.isOldNotesCache_)
                return this.isOldNotesCache_[noteId];
            const isOld = yield Note_1.default.noteIsOlderThan(noteId, this.oldNoteCutOffDate_());
            this.isOldNotesCache_[noteId] = isOld;
            return isOld;
        });
    }
    noteMetadata_(note) {
        const excludedFields = ['type_', 'title', 'body', 'created_time', 'updated_time', 'encryption_applied', 'encryption_cipher_text', 'is_conflict'];
        const md = {};
        for (const k in note) {
            if (excludedFields.indexOf(k) >= 0)
                continue;
            md[k] = note[k];
        }
        if (note.user_updated_time === note.updated_time)
            delete md.user_updated_time;
        if (note.user_created_time === note.created_time)
            delete md.user_created_time;
        return md;
    }
    createNoteRevision_(note, parentRevId = null) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const parentRev = parentRevId ? yield Revision_1.default.load(parentRevId) : yield Revision_1.default.latestRevision(BaseModel_1.default.TYPE_NOTE, note.id);
                const output = {
                    parent_id: '',
                    item_type: BaseModel_1.default.TYPE_NOTE,
                    item_id: note.id,
                    item_updated_time: note.updated_time,
                };
                const noteMd = this.noteMetadata_(note);
                const noteTitle = note.title ? note.title : '';
                const noteBody = note.body ? note.body : '';
                if (!parentRev) {
                    output.title_diff = Revision_1.default.createTextPatch('', noteTitle);
                    output.body_diff = Revision_1.default.createTextPatch('', noteBody);
                    output.metadata_diff = Revision_1.default.createObjectPatch({}, noteMd);
                }
                else {
                    if (Date.now() - parentRev.updated_time < Setting_1.default.value('revisionService.intervalBetweenRevisions'))
                        return null;
                    const merged = yield Revision_1.default.mergeDiffs(parentRev);
                    output.parent_id = parentRev.id;
                    output.title_diff = Revision_1.default.createTextPatch(merged.title, noteTitle);
                    output.body_diff = Revision_1.default.createTextPatch(merged.body, noteBody);
                    output.metadata_diff = Revision_1.default.createObjectPatch(merged.metadata, noteMd);
                }
                if (Revision_1.default.isEmptyRevision(output))
                    return null;
                return Revision_1.default.save(output);
            }
            catch (error) {
                const newError = wrapError(`Could not create revision for note: ${note.id}`, error);
                throw newError;
            }
        });
    }
    collectRevisions() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isCollecting_)
                return;
            this.isCollecting_ = true;
            yield ItemChange_1.default.waitForAllSaved();
            const doneNoteIds = [];
            try {
                while (true) {
                    // See synchronizer test units to see why changes coming
                    // from sync are skipped.
                    const changes = yield ItemChange_1.default.modelSelectAll(`
					SELECT id, item_id, type, before_change_item
					FROM item_changes
					WHERE item_type = ?
					AND source != ?
					AND source != ?
					AND id > ?
					ORDER BY id ASC
					LIMIT 10
				`, [BaseModel_1.default.TYPE_NOTE, ItemChange_1.default.SOURCE_SYNC, ItemChange_1.default.SOURCE_DECRYPTION, Setting_1.default.value('revisionService.lastProcessedChangeId')]);
                    if (!changes.length)
                        break;
                    const noteIds = changes.map((a) => a.item_id);
                    const notes = yield Note_1.default.modelSelectAll(`SELECT * FROM notes WHERE is_conflict = 0 AND encryption_applied = 0 AND id IN ("${noteIds.join('","')}")`);
                    for (let i = 0; i < changes.length; i++) {
                        const change = changes[i];
                        const noteId = change.item_id;
                        try {
                            if (change.type === ItemChange_1.default.TYPE_UPDATE && doneNoteIds.indexOf(noteId) < 0) {
                                const note = BaseModel_1.default.byId(notes, noteId);
                                const oldNote = change.before_change_item ? JSON.parse(change.before_change_item) : null;
                                if (note) {
                                    if (oldNote && oldNote.updated_time < this.oldNoteCutOffDate_()) {
                                        // This is where we save the original version of this old note
                                        const rev = yield this.createNoteRevision_(oldNote);
                                        if (rev)
                                            logger.debug(sprintf('collectRevisions: Saved revision %s (old note)', rev.id));
                                    }
                                    const rev = yield this.createNoteRevision_(note);
                                    if (rev)
                                        logger.debug(sprintf('collectRevisions: Saved revision %s (Last rev was more than %d ms ago)', rev.id, Setting_1.default.value('revisionService.intervalBetweenRevisions')));
                                    doneNoteIds.push(noteId);
                                    this.isOldNotesCache_[noteId] = false;
                                }
                            }
                            if (change.type === ItemChange_1.default.TYPE_DELETE && !!change.before_change_item) {
                                const note = JSON.parse(change.before_change_item);
                                const revExists = yield Revision_1.default.revisionExists(BaseModel_1.default.TYPE_NOTE, note.id, note.updated_time);
                                if (!revExists) {
                                    const rev = yield this.createNoteRevision_(note);
                                    if (rev)
                                        logger.debug(sprintf('collectRevisions: Saved revision %s (for deleted note)', rev.id));
                                }
                                doneNoteIds.push(noteId);
                            }
                        }
                        catch (error) {
                            if (error.code === 'revision_encrypted') {
                                throw error;
                            }
                            else {
                                // If any revision creation fails, we continue
                                // processing the other changes. It seems a rare bug
                                // in diff-match-patch can cause the creation of
                                // revisions to fail in some case. It should be rare
                                // and it's best to continue processing the other
                                // changes. The alternative would be to stop here
                                // and fix the bug, but in the meantime revisions
                                // will no longer be generated.
                                // The drawback is that once a change has been
                                // skipped it will never be processed again because
                                // the error will be in the past (before
                                // revisionService.lastProcessedChangeId)
                                //
                                // https://github.com/laurent22/joplin/issues/5531
                                logger.error(`collectRevisions: Processing one of the changes for note ${noteId} failed. Other changes will still be processed. Error was: `, error);
                                logger.error('collectRevisions: Change was:', change);
                            }
                        }
                        Setting_1.default.setValue('revisionService.lastProcessedChangeId', change.id);
                    }
                }
            }
            catch (error) {
                if (error.code === 'revision_encrypted') {
                    // One or more revisions are encrypted - stop processing for now
                    // and these revisions will be processed next time the revision
                    // collector runs.
                    logger.info('collectRevisions: One or more revision was encrypted. Processing was stopped but will resume later when the revision is decrypted.', error);
                }
                else {
                    // This should not happen anymore because we handle the error in
                    // the loop above.
                    logger.error('collectRevisions:', error);
                }
            }
            yield Setting_1.default.saveAll();
            yield ItemChangeUtils_1.default.deleteProcessedChanges();
            this.isCollecting_ = false;
            logger.info(`collectRevisions: Created revisions for ${doneNoteIds.length} notes`);
        });
    }
    deleteOldRevisions(ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            return Revision_1.default.deleteOldRevisions(ttl);
        });
    }
    revisionNote(revisions, index) {
        return __awaiter(this, void 0, void 0, function* () {
            if (index < 0 || index >= revisions.length)
                throw new Error(`Invalid revision index: ${index}`);
            const rev = revisions[index];
            const merged = yield Revision_1.default.mergeDiffs(rev, revisions);
            const output = Object.assign({
                title: merged.title,
                body: merged.body,
            }, merged.metadata);
            output.updated_time = output.user_updated_time;
            output.created_time = output.user_created_time;
            output.type_ = BaseModel_1.default.TYPE_NOTE;
            if (!('markup_language' in output))
                output.markup_language = renderer_1.MarkupLanguage.Markdown;
            return output;
        });
    }
    restoreFolderTitle() {
        return (0, locale_1._)('Restored Notes');
    }
    restoreFolder() {
        return __awaiter(this, void 0, void 0, function* () {
            let folder = yield Folder_1.default.loadByTitle(this.restoreFolderTitle());
            if (!folder) {
                folder = yield Folder_1.default.save({ title: this.restoreFolderTitle() });
            }
            return folder;
        });
    }
    // reverseRevIndex = 0 means restoring the latest version. reverseRevIndex =
    // 1 means the version before that, etc.
    restoreNoteById(noteId, reverseRevIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            const revisions = yield Revision_1.default.allByType(BaseModel_1.default.TYPE_NOTE, noteId);
            if (!revisions.length)
                throw new Error(`No revision for note "${noteId}"`);
            const revIndex = revisions.length - 1 - reverseRevIndex;
            const note = yield this.revisionNote(revisions, revIndex);
            return this.importRevisionNote(note);
        });
    }
    restoreSuccessMessage(note) {
        return (0, locale_1._)('The note "%s" has been successfully restored to the notebook "%s".', substrWithEllipsis(note.title, 0, 32), this.restoreFolderTitle());
    }
    importRevisionNote(note) {
        return __awaiter(this, void 0, void 0, function* () {
            const toImport = Object.assign({}, note);
            delete toImport.id;
            delete toImport.updated_time;
            delete toImport.created_time;
            delete toImport.encryption_applied;
            delete toImport.encryption_cipher_text;
            const folder = yield this.restoreFolder();
            toImport.parent_id = folder.id;
            return Note_1.default.save(toImport);
        });
    }
    maintenance() {
        return __awaiter(this, void 0, void 0, function* () {
            this.maintenanceCalls_.push(true);
            try {
                const startTime = Date.now();
                logger.info('maintenance: Starting...');
                if (!Setting_1.default.value('revisionService.enabled')) {
                    logger.info('maintenance: Service is disabled');
                    // We do as if we had processed all the latest changes so that they can be cleaned up
                    // later on by ItemChangeUtils.deleteProcessedChanges().
                    Setting_1.default.setValue('revisionService.lastProcessedChangeId', yield ItemChange_1.default.lastChangeId());
                    yield this.deleteOldRevisions(Setting_1.default.value('revisionService.ttlDays') * 24 * 60 * 60 * 1000);
                }
                else {
                    logger.info('maintenance: Service is enabled');
                    yield this.collectRevisions();
                    yield this.deleteOldRevisions(Setting_1.default.value('revisionService.ttlDays') * 24 * 60 * 60 * 1000);
                    logger.info(`maintenance: Done in ${Date.now() - startTime}ms`);
                }
            }
            catch (error) {
                logger.error('maintenance:', error);
            }
            finally {
                this.maintenanceCalls_.pop();
            }
        });
    }
    runInBackground(collectRevisionInterval = null) {
        if (this.isRunningInBackground_)
            return;
        this.isRunningInBackground_ = true;
        if (collectRevisionInterval === null)
            collectRevisionInterval = 1000 * 60 * 10;
        logger.info(`runInBackground: Starting background service with revision collection interval ${collectRevisionInterval}`);
        this.maintenanceTimer1_ = shim_1.default.setTimeout(() => {
            void this.maintenance();
        }, 1000 * 4);
        this.maintenanceTimer2_ = shim_1.default.setInterval(() => {
            void this.maintenance();
        }, collectRevisionInterval);
    }
    cancelTimers() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.maintenanceTimer1_) {
                shim_1.default.clearTimeout(this.maintenanceTimer1_);
                this.maintenanceTimer1_ = null;
            }
            if (this.maintenanceTimer2_) {
                shim_1.default.clearInterval(this.maintenanceTimer2_);
                this.maintenanceTimer2_ = null;
            }
            return new Promise((resolve) => {
                const iid = shim_1.default.setInterval(() => {
                    if (!this.maintenanceCalls_.length) {
                        shim_1.default.clearInterval(iid);
                        resolve(null);
                    }
                }, 100);
            });
        });
    }
}
exports.default = RevisionService;
//# sourceMappingURL=RevisionService.js.map