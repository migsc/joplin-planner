"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const reducer_1 = require("../../reducer");
const focusEditorIfEditorCommand_1 = require("./focusEditorIfEditorCommand");
const separatorItem = { type: 'separator' };
class ToolbarButtonUtils {
    constructor(service) {
        this.toolbarButtonCache_ = {};
        this.service_ = service;
    }
    get service() {
        return this.service_;
    }
    commandToToolbarButton(commandName, whenClauseContext) {
        const newEnabled = this.service.isEnabled(commandName, whenClauseContext);
        const newTitle = this.service.title(commandName);
        if (this.toolbarButtonCache_[commandName] &&
            this.toolbarButtonCache_[commandName].info.enabled === newEnabled &&
            this.toolbarButtonCache_[commandName].info.title === newTitle) {
            return this.toolbarButtonCache_[commandName].info;
        }
        const command = this.service.commandByName(commandName, { runtimeMustBeRegistered: true });
        const output = {
            name: commandName,
            tooltip: this.service.label(commandName),
            iconName: command.declaration.iconName,
            enabled: newEnabled,
            onClick: () => __awaiter(this, void 0, void 0, function* () {
                void this.service.execute(commandName);
                void (0, focusEditorIfEditorCommand_1.default)(commandName, this.service);
            }),
            title: newTitle,
        };
        this.toolbarButtonCache_[commandName] = {
            info: output,
        };
        return this.toolbarButtonCache_[commandName].info;
    }
    // This method ensures that if the provided commandNames and state hasn't changed
    // the output also won't change. Invididual toolbarButtonInfo also won't changed
    // if the state they use hasn't changed. This is to avoid useless renders of the toolbars.
    commandsToToolbarButtons(commandNames, whenClauseContext) {
        const output = [];
        for (const commandName of commandNames) {
            if (commandName === '-') {
                output.push(separatorItem);
                continue;
            }
            output.push(this.commandToToolbarButton(commandName, whenClauseContext));
        }
        return reducer_1.stateUtils.selectArrayShallow({ array: output }, commandNames.join('_'));
    }
}
exports.default = ToolbarButtonUtils;
//# sourceMappingURL=ToolbarButtonUtils.js.map