"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.plainTextToHtml = void 0;
const urlUtils = require('./urlUtils.js');
const Entities = require('html-entities').AllHtmlEntities;
const htmlentities = new Entities().encode;
const { escapeHtml } = require('./string-utils.js');
// [\s\S] instead of . for multiline matching
// https://stackoverflow.com/a/16119722/561309
const imageRegex = /<img([\s\S]*?)src=["']([\s\S]*?)["']([\s\S]*?)>/gi;
const anchorRegex = /<a([\s\S]*?)href=["']([\s\S]*?)["']([\s\S]*?)>/gi;
const embedRegex = /<embed([\s\S]*?)src=["']([\s\S]*?)["']([\s\S]*?)>/gi;
const objectRegex = /<object([\s\S]*?)data=["']([\s\S]*?)["']([\s\S]*?)>/gi;
const pdfUrlRegex = /[\s\S]*?\.pdf$/i;
const selfClosingElements = [
    'area',
    'base',
    'basefont',
    'br',
    'col',
    'command',
    'embed',
    'frame',
    'hr',
    'img',
    'input',
    'isindex',
    'keygen',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr',
];
class HtmlUtils {
    headAndBodyHtml(doc) {
        const output = [];
        if (doc.head)
            output.push(doc.head.innerHTML);
        if (doc.body)
            output.push(doc.body.innerHTML);
        return output.join('\n');
    }
    isSelfClosingTag(tagName) {
        return selfClosingElements.includes(tagName.toLowerCase());
    }
    // Returns the **encoded** URLs, so to be useful they should be decoded again before use.
    extractUrls(regex, html) {
        if (!html)
            return [];
        const output = [];
        let matches;
        while ((matches = regex.exec(html))) {
            output.push(matches[2]);
        }
        return output.filter(url => !!url);
    }
    // Returns the **encoded** URLs, so to be useful they should be decoded again before use.
    extractImageUrls(html) {
        return this.extractUrls(imageRegex, html);
    }
    // Returns the **encoded** URLs, so to be useful they should be decoded again before use.
    extractPdfUrls(html) {
        return [...this.extractUrls(embedRegex, html), ...this.extractUrls(objectRegex, html)].filter(url => pdfUrlRegex.test(url));
    }
    // Returns the **encoded** URLs, so to be useful they should be decoded again before use.
    extractAnchorUrls(html) {
        return this.extractUrls(anchorRegex, html);
    }
    // Returns the **encoded** URLs, so to be useful they should be decoded again before use.
    extractFileUrls(html) {
        return this.extractImageUrls(html).concat(this.extractAnchorUrls(html));
    }
    replaceResourceUrl(html, urlToReplace, id) {
        const htmlLinkRegex = `(?<=(?:src|href)=["'])${urlToReplace}(?=["'])`;
        const htmlReg = new RegExp(htmlLinkRegex, 'g');
        return html.replace(htmlReg, `:/${id}`);
    }
    replaceImageUrls(html, callback) {
        return this.processImageTags(html, (data) => {
            const newSrc = callback(data.src);
            return {
                type: 'replaceSource',
                src: newSrc,
            };
        });
    }
    replaceEmbedUrls(html, callback) {
        if (!html)
            return '';
        // We are adding the link as <a> since joplin disabled <embed>, <object> tags due to security reasons.
        // See: CVE-2020-15930
        html = html.replace(embedRegex, (_v, _before, src, _after) => {
            const link = callback(src);
            return `<a href="${link}">${escapeHtml(src)}</a>`;
        });
        html = html.replace(objectRegex, (_v, _before, src, _after) => {
            const link = callback(src);
            return `<a href="${link}">${escapeHtml(src)}</a>`;
        });
        return html;
    }
    replaceMediaUrls(html, callback) {
        html = this.replaceImageUrls(html, callback);
        html = this.replaceEmbedUrls(html, callback);
        return html;
    }
    // Note that the URLs provided by this function are URL-encoded, which is
    // usually what you want for web URLs. But if they are file:// URLs and the
    // file path is going to be used, it will need to be unescaped first. The
    // transformed SRC, must also be escaped before being sent back to this
    // function.
    processImageTags(html, callback) {
        if (!html)
            return '';
        return html.replace(imageRegex, (_v, before, src, after) => {
            const action = callback({ src: src });
            if (!action)
                return `<img${before}src="${src}"${after}>`;
            if (action.type === 'replaceElement') {
                return action.html;
            }
            if (action.type === 'replaceSource') {
                return `<img${before}src="${action.src}"${after}>`;
            }
            if (action.type === 'setAttributes') {
                const attrHtml = this.attributesHtml(action.attrs);
                return `<img${before}${attrHtml}${after}>`;
            }
            throw new Error(`Invalid action: ${action.type}`);
        });
    }
    prependBaseUrl(html, baseUrl) {
        if (!html)
            return '';
        return html.replace(anchorRegex, (_v, before, href, after) => {
            const newHref = urlUtils.prependBaseUrl(href, baseUrl);
            return `<a${before}href="${newHref}"${after}>`;
        });
    }
    attributesHtml(attr) {
        const output = [];
        for (const n in attr) {
            if (!attr.hasOwnProperty(n))
                continue;
            output.push(`${n}="${htmlentities(attr[n])}"`);
        }
        return output.join(' ');
    }
}
exports.default = new HtmlUtils();
function plainTextToHtml(plainText) {
    const lines = plainText
        .replace(/[\n\r]/g, '\n')
        .split('\n');
    const lineOpenTag = lines.length > 1 ? '<p>' : '';
    const lineCloseTag = lines.length > 1 ? '</p>' : '';
    return lines
        .map(line => lineOpenTag + escapeHtml(line) + lineCloseTag)
        .join('');
}
exports.plainTextToHtml = plainTextToHtml;
//# sourceMappingURL=htmlUtils.js.map