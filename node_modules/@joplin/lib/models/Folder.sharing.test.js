"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const test_utils_1 = require("../testing/test-utils");
const Folder_1 = require("../models/Folder");
const test_utils_synchronizer_1 = require("../testing/test-utils-synchronizer");
const Note_1 = require("../models/Note");
const shim_1 = require("../shim");
const Resource_1 = require("../models/Resource");
const ResourceService_1 = require("../services/ResourceService");
const testImagePath = `${test_utils_1.supportDir}/photo.jpg`;
describe('models/Folder.sharing', function () {
    beforeEach((done) => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.switchClient)(1);
        done();
    }));
    it('should apply the share ID to all children', (() => __awaiter(this, void 0, void 0, function* () {
        const folder = yield (0, test_utils_1.createFolderTree)('', [
            {
                title: 'folder 1',
                children: [
                    {
                        title: 'note 1',
                    },
                    {
                        title: 'note 2',
                    },
                    {
                        title: 'folder 2',
                        children: [
                            {
                                title: 'note 3',
                            },
                        ],
                    },
                ],
            },
        ]);
        yield Folder_1.default.save({ id: folder.id, share_id: 'abcd1234' });
        yield Folder_1.default.updateAllShareIds((0, test_utils_1.resourceService)());
        const allItems = yield (0, test_utils_synchronizer_1.allNotesFolders)();
        for (const item of allItems) {
            expect(item.share_id).toBe('abcd1234');
        }
    })));
    it('should apply the share ID to all sub-folders', (() => __awaiter(this, void 0, void 0, function* () {
        let folder1 = yield (0, test_utils_1.createFolderTree)('', [
            {
                title: 'folder 1',
                children: [
                    {
                        title: 'note 1',
                    },
                    {
                        title: 'note 2',
                    },
                    {
                        title: 'folder 2',
                        children: [
                            {
                                title: 'note 3',
                            },
                        ],
                    },
                    {
                        title: 'folder 3',
                        children: [
                            {
                                title: 'folder 4',
                                children: [],
                            },
                        ],
                    },
                ],
            },
            {
                title: 'folder 5',
                children: [],
            },
        ]);
        yield Folder_1.default.save({ id: folder1.id, share_id: 'abcd1234' });
        yield Folder_1.default.updateAllShareIds((0, test_utils_1.resourceService)());
        folder1 = yield Folder_1.default.loadByTitle('folder 1');
        const folder2 = yield Folder_1.default.loadByTitle('folder 2');
        const folder3 = yield Folder_1.default.loadByTitle('folder 3');
        const folder4 = yield Folder_1.default.loadByTitle('folder 4');
        const folder5 = yield Folder_1.default.loadByTitle('folder 5');
        expect(folder1.share_id).toBe('abcd1234');
        expect(folder2.share_id).toBe('abcd1234');
        expect(folder3.share_id).toBe('abcd1234');
        expect(folder4.share_id).toBe('abcd1234');
        expect(folder5.share_id).toBe('');
    })));
    it('should update the share ID when a folder is moved in or out of shared folder', (() => __awaiter(this, void 0, void 0, function* () {
        let folder1 = yield (0, test_utils_1.createFolderTree)('', [
            {
                title: 'folder 1',
                children: [
                    {
                        title: 'folder 2',
                        children: [],
                    },
                ],
            },
            {
                title: 'folder 3',
                children: [],
            },
        ]);
        yield Folder_1.default.save({ id: folder1.id, share_id: 'abcd1234' });
        yield Folder_1.default.updateAllShareIds((0, test_utils_1.resourceService)());
        folder1 = yield Folder_1.default.loadByTitle('folder 1');
        let folder2 = yield Folder_1.default.loadByTitle('folder 2');
        const folder3 = yield Folder_1.default.loadByTitle('folder 3');
        expect(folder1.share_id).toBe('abcd1234');
        expect(folder2.share_id).toBe('abcd1234');
        // Move the folder outside the shared folder
        yield Folder_1.default.save({ id: folder2.id, parent_id: folder3.id });
        yield Folder_1.default.updateAllShareIds((0, test_utils_1.resourceService)());
        folder2 = yield Folder_1.default.loadByTitle('folder 2');
        expect(folder2.share_id).toBe('');
        // Move the folder inside the shared folder
        {
            yield Folder_1.default.save({ id: folder2.id, parent_id: folder1.id });
            yield Folder_1.default.updateAllShareIds((0, test_utils_1.resourceService)());
            folder2 = yield Folder_1.default.loadByTitle('folder 2');
            expect(folder2.share_id).toBe('abcd1234');
        }
    })));
    it('should apply the share ID to all notes', (() => __awaiter(this, void 0, void 0, function* () {
        const folder1 = yield (0, test_utils_1.createFolderTree)('', [
            {
                title: 'folder 1',
                children: [
                    {
                        title: 'note 1',
                    },
                    {
                        title: 'note 2',
                    },
                    {
                        title: 'folder 2',
                        children: [
                            {
                                title: 'note 3',
                            },
                        ],
                    },
                ],
            },
            {
                title: 'folder 5',
                children: [
                    {
                        title: 'note 4',
                    },
                ],
            },
        ]);
        yield Folder_1.default.save({ id: folder1.id, share_id: 'abcd1234' });
        yield Folder_1.default.updateAllShareIds((0, test_utils_1.resourceService)());
        const note1 = yield Note_1.default.loadByTitle('note 1');
        const note2 = yield Note_1.default.loadByTitle('note 2');
        const note3 = yield Note_1.default.loadByTitle('note 3');
        const note4 = yield Note_1.default.loadByTitle('note 4');
        expect(note1.share_id).toBe('abcd1234');
        expect(note2.share_id).toBe('abcd1234');
        expect(note3.share_id).toBe('abcd1234');
        expect(note4.share_id).toBe('');
    })));
    it('should remove the share ID when a note is moved in or out of shared folder', (() => __awaiter(this, void 0, void 0, function* () {
        const folder1 = yield (0, test_utils_1.createFolderTree)('', [
            {
                title: 'folder 1',
                children: [
                    {
                        title: 'note 1',
                    },
                ],
            },
            {
                title: 'folder 2',
                children: [],
            },
        ]);
        yield Folder_1.default.save({ id: folder1.id, share_id: 'abcd1234' });
        yield Folder_1.default.updateAllShareIds((0, test_utils_1.resourceService)());
        const note1 = yield Note_1.default.loadByTitle('note 1');
        const folder2 = yield Folder_1.default.loadByTitle('folder 2');
        expect(note1.share_id).toBe('abcd1234');
        // Move the note outside of the shared folder
        yield Note_1.default.save({ id: note1.id, parent_id: folder2.id });
        yield Folder_1.default.updateAllShareIds((0, test_utils_1.resourceService)());
        {
            const note1 = yield Note_1.default.loadByTitle('note 1');
            expect(note1.share_id).toBe('');
        }
        // Move the note back inside the shared folder
        yield Note_1.default.save({ id: note1.id, parent_id: folder1.id });
        yield Folder_1.default.updateAllShareIds((0, test_utils_1.resourceService)());
        {
            const note1 = yield Note_1.default.loadByTitle('note 1');
            expect(note1.share_id).toBe('abcd1234');
        }
    })));
    it('should not remove the share ID of non-modified notes', (() => __awaiter(this, void 0, void 0, function* () {
        const folder1 = yield (0, test_utils_1.createFolderTree)('', [
            {
                title: 'folder 1',
                children: [
                    {
                        title: 'note 1',
                    },
                    {
                        title: 'note 2',
                    },
                ],
            },
            {
                title: 'folder 2',
                children: [],
            },
        ]);
        yield Folder_1.default.save({ id: folder1.id, share_id: 'abcd1234' });
        yield Folder_1.default.updateAllShareIds((0, test_utils_1.resourceService)());
        let note1 = yield Note_1.default.loadByTitle('note 1');
        let note2 = yield Note_1.default.loadByTitle('note 2');
        const folder2 = yield Folder_1.default.loadByTitle('folder 2');
        expect(note1.share_id).toBe('abcd1234');
        expect(note2.share_id).toBe('abcd1234');
        yield Note_1.default.save({ id: note1.id, parent_id: folder2.id });
        yield Folder_1.default.updateAllShareIds((0, test_utils_1.resourceService)());
        note1 = yield Note_1.default.loadByTitle('note 1');
        note2 = yield Note_1.default.loadByTitle('note 2');
        expect(note1.share_id).toBe('');
        expect(note2.share_id).toBe('abcd1234');
    })));
    it('should apply the note share ID to its resources', () => __awaiter(this, void 0, void 0, function* () {
        const resourceService = new ResourceService_1.default();
        const folder = yield (0, test_utils_1.createFolderTree)('', [
            {
                title: 'folder 1',
                children: [
                    {
                        title: 'note 1',
                    },
                    {
                        title: 'note 2',
                    },
                ],
            },
            {
                title: 'folder 2',
                children: [],
            },
        ]);
        yield Folder_1.default.save({ id: folder.id, share_id: 'abcd1234' });
        yield Folder_1.default.updateAllShareIds(resourceService);
        const folder2 = yield Folder_1.default.loadByTitle('folder 2');
        const note1 = yield Note_1.default.loadByTitle('note 1');
        yield shim_1.default.attachFileToNote(note1, testImagePath);
        // We need to index the resources to populate the note_resources table
        yield resourceService.indexNoteResources();
        const resourceId = (yield Resource_1.default.all())[0].id;
        {
            const resource = yield Resource_1.default.load(resourceId);
            expect(resource.share_id).toBe('');
        }
        yield Folder_1.default.updateAllShareIds(resourceService);
        {
            const resource = yield Resource_1.default.load(resourceId);
            expect(resource.share_id).toBe(note1.share_id);
        }
        yield Note_1.default.save({ id: note1.id, parent_id: folder2.id });
        yield resourceService.indexNoteResources();
        yield Folder_1.default.updateAllShareIds(resourceService);
        {
            const resource = yield Resource_1.default.load(resourceId);
            expect(resource.share_id).toBe('');
        }
    }));
    it('should automatically duplicate resources when they are shared', () => __awaiter(this, void 0, void 0, function* () {
        const resourceService = new ResourceService_1.default();
        const folder1 = yield (0, test_utils_1.createFolderTree)('', [
            {
                title: 'folder 1',
                children: [
                    {
                        title: 'note 1',
                    },
                    {
                        title: 'note 2',
                    },
                ],
            },
            {
                title: 'folder 2',
                children: [
                    {
                        title: 'note 3',
                    },
                ],
            },
            {
                title: 'folder 3',
                children: [
                    {
                        title: 'note 4',
                    },
                ],
            },
        ]);
        const folder2 = yield Folder_1.default.loadByTitle('folder 2');
        // await Folder.loadByTitle('folder 3');
        let note1 = yield Note_1.default.loadByTitle('note 1');
        let note2 = yield Note_1.default.loadByTitle('note 2');
        let note3 = yield Note_1.default.loadByTitle('note 3');
        let note4 = yield Note_1.default.loadByTitle('note 4');
        yield Folder_1.default.save({ id: folder1.id, share_id: 'share1' });
        yield Folder_1.default.save({ id: folder2.id, share_id: 'share2' });
        note1 = yield shim_1.default.attachFileToNote(note1, testImagePath);
        note2 = yield shim_1.default.attachFileToNote(note2, testImagePath);
        note3 = yield Note_1.default.save({ id: note3.id, body: note1.body });
        note4 = yield Note_1.default.save({ id: note4.id, body: note1.body });
        const userUpdatedTimes = {
            [note1.id]: note1.user_updated_time,
            [note2.id]: note2.user_updated_time,
            [note3.id]: note3.user_updated_time,
            [note4.id]: note4.user_updated_time,
        };
        yield (0, test_utils_1.msleep)(1);
        // We need to index the resources to populate the note_resources table
        yield resourceService.indexNoteResources();
        yield Folder_1.default.updateAllShareIds(resourceService);
        // BEFORE:
        //
        // - Note 1 has resource 1 (share1)
        // - Note 2 has resource 2 (share1)
        // - Note 3 has resource 1 (share2)
        // - Note 4 has resource 1 (not shared)
        // AFTER:
        //
        // - Note 1 has resource 1 (share1)
        // - Note 2 has resource 2 (share1)
        // - Note 3 has resource 3 (share2)
        // - Note 4 has resource 4 (not shared)
        const resources = yield Resource_1.default.all();
        expect(resources.length).toBe(4);
        note1 = yield Note_1.default.load(note1.id);
        note2 = yield Note_1.default.load(note2.id);
        note3 = yield Note_1.default.load(note3.id);
        note4 = yield Note_1.default.load(note4.id);
        expect(note1.body).not.toBe(note2.body);
        expect(note1.body).not.toBe(note3.body);
        expect(note1.body).not.toBe(note4.body);
        expect(note2.body).not.toBe(note3.body);
        expect(note2.body).not.toBe(note4.body);
        expect(note3.body).not.toBe(note4.body);
        expect(note1.user_updated_time).toBe(userUpdatedTimes[note1.id]);
        expect(note2.user_updated_time).toBe(userUpdatedTimes[note2.id]);
        expect(note3.user_updated_time).toBe(userUpdatedTimes[note3.id]);
        expect(note4.user_updated_time).toBe(userUpdatedTimes[note4.id]);
    }));
    it('should unshare items that are no longer part of an existing share', () => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.createFolderTree)('', [
            {
                title: 'folder 1',
                share_id: '1',
                children: [
                    {
                        title: 'note 1',
                    },
                ],
            },
            {
                title: 'folder 2',
                share_id: '2',
                children: [
                    {
                        title: 'note 2',
                    },
                ],
            },
        ]);
        const resourceService = new ResourceService_1.default();
        const folder1 = yield Folder_1.default.loadByTitle('folder 1');
        const folder2 = yield Folder_1.default.loadByTitle('folder 2');
        let note1 = yield Note_1.default.loadByTitle('note 1');
        let note2 = yield Note_1.default.loadByTitle('note 2');
        note1 = yield shim_1.default.attachFileToNote(note1, testImagePath);
        note2 = yield shim_1.default.attachFileToNote(note2, testImagePath);
        const resourceId1 = (yield Note_1.default.linkedResourceIds(note1.body))[0];
        const resourceId2 = (yield Note_1.default.linkedResourceIds(note2.body))[0];
        yield resourceService.indexNoteResources();
        yield Folder_1.default.updateAllShareIds(resourceService);
        yield Folder_1.default.updateNoLongerSharedItems(['1']);
        // Since `updateNoLongerSharedItems` sets the parent_id too,
        // double-check that it's not actually modified.
        expect((yield Note_1.default.loadByTitle('note 1')).parent_id).toBe(folder1.id);
        expect((yield Note_1.default.loadByTitle('note 2')).parent_id).toBe(folder2.id);
        expect((yield Folder_1.default.loadByTitle('folder 1')).parent_id).toBe(folder1.parent_id);
        expect((yield Folder_1.default.loadByTitle('folder 2')).parent_id).toBe(folder2.parent_id);
        // At this point, all items associated with share 2 should have their
        // share_id cleared, because the share no longer exists. We also
        // double-check that share 1 hasn't been cleared.
        expect((yield Note_1.default.loadByTitle('note 1')).share_id).toBe('1');
        expect((yield Note_1.default.loadByTitle('note 2')).share_id).toBe('');
        expect((yield Folder_1.default.loadByTitle('folder 1')).share_id).toBe('1');
        expect((yield Folder_1.default.loadByTitle('folder 2')).share_id).toBe('');
        expect((yield Resource_1.default.load(resourceId1)).share_id).toBe('1');
        expect((yield Resource_1.default.load(resourceId2)).share_id).toBe('');
        // If we pass an empty array, it means there are no active share
        // anymore, so all share_id should be cleared.
        yield Folder_1.default.updateNoLongerSharedItems([]);
        expect((yield Note_1.default.loadByTitle('note 1')).share_id).toBe('');
        expect((yield Folder_1.default.loadByTitle('folder 1')).share_id).toBe('');
        expect((yield Resource_1.default.load(resourceId1)).share_id).toBe('');
        {
            // If we run it again, it should not update the notes since the share_id
            // has already been cleared.
            const resource1 = yield Resource_1.default.load(resourceId1);
            const resource2 = yield Resource_1.default.load(resourceId2);
            const note1 = yield Note_1.default.loadByTitle('note 1');
            const note2 = yield Note_1.default.loadByTitle('note 2');
            const folder1 = yield Folder_1.default.loadByTitle('folder 1');
            const folder2 = yield Folder_1.default.loadByTitle('folder 2');
            yield (0, test_utils_1.msleep)(1);
            yield Folder_1.default.updateNoLongerSharedItems(['1']);
            expect((yield Resource_1.default.load(resourceId1)).updated_time).toBe(resource1.updated_time);
            expect((yield Resource_1.default.load(resourceId2)).updated_time).toBe(resource2.updated_time);
            expect((yield Note_1.default.loadByTitle('note 1')).updated_time).toBe(note1.updated_time);
            expect((yield Note_1.default.loadByTitle('note 2')).updated_time).toBe(note2.updated_time);
            expect((yield Folder_1.default.loadByTitle('folder 1')).updated_time).toBe(folder1.updated_time);
            expect((yield Folder_1.default.loadByTitle('folder 2')).updated_time).toBe(folder2.updated_time);
        }
    }));
});
//# sourceMappingURL=Folder.sharing.test.js.map