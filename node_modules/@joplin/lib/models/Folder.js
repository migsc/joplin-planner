"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../services/database/types");
const BaseModel_1 = require("../BaseModel");
const time_1 = require("../time");
const locale_1 = require("../locale");
const Note_1 = require("./Note");
const database_1 = require("../database");
const BaseItem_1 = require("./BaseItem");
const Resource_1 = require("./Resource");
const reducer_1 = require("../services/share/reducer");
const Logger_1 = require("../Logger");
const syncDebugLog_1 = require("../services/synchronizer/syncDebugLog");
const { substrWithEllipsis } = require('../string-utils.js');
const logger = Logger_1.default.create('models/Folder');
class Folder extends BaseItem_1.default {
    static tableName() {
        return 'folders';
    }
    static modelType() {
        return BaseModel_1.default.TYPE_FOLDER;
    }
    static newFolder() {
        return {
            id: null,
            title: '',
        };
    }
    static fieldToLabel(field) {
        const fieldsToLabels = {
            title: (0, locale_1._)('title'),
            last_note_user_updated_time: (0, locale_1._)('updated date'),
        };
        return field in fieldsToLabels ? fieldsToLabels[field] : field;
    }
    static noteIds(parentId, options = null) {
        options = Object.assign({}, {
            includeConflicts: false,
        }, options);
        const where = ['parent_id = ?'];
        if (!options.includeConflicts) {
            where.push('is_conflict = 0');
        }
        return this.db()
            .selectAll(`SELECT id FROM notes WHERE ${where.join(' AND ')}`, [parentId])
            // eslint-disable-next-line promise/prefer-await-to-then -- Old code before rule was applied
            .then((rows) => {
            const output = [];
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                output.push(row.id);
            }
            return output;
        });
    }
    static subFolderIds(parentId) {
        return __awaiter(this, void 0, void 0, function* () {
            const rows = yield this.db().selectAll('SELECT id FROM folders WHERE parent_id = ?', [parentId]);
            return rows.map((r) => r.id);
        });
    }
    static noteCount(parentId) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.db().selectOne('SELECT count(*) as total FROM notes WHERE is_conflict = 0 AND parent_id = ?', [parentId]);
            return r ? r.total : 0;
        });
    }
    static markNotesAsConflict(parentId) {
        const query = database_1.default.updateQuery('notes', { is_conflict: 1 }, { parent_id: parentId });
        return this.db().exec(query);
    }
    static delete(folderId, options = null) {
        const _super = Object.create(null, {
            delete: { get: () => super.delete }
        });
        return __awaiter(this, void 0, void 0, function* () {
            options = Object.assign({ deleteChildren: true }, options);
            const folder = yield Folder.load(folderId);
            if (!folder)
                return; // noop
            if (options.deleteChildren) {
                const noteIds = yield Folder.noteIds(folderId);
                yield Note_1.default.batchDelete(noteIds);
                const subFolderIds = yield Folder.subFolderIds(folderId);
                for (let i = 0; i < subFolderIds.length; i++) {
                    yield Folder.delete(subFolderIds[i]);
                }
            }
            yield _super.delete.call(this, folderId, options);
            this.dispatch({
                type: 'FOLDER_DELETE',
                id: folderId,
            });
        });
    }
    static conflictFolderTitle() {
        return (0, locale_1._)('Conflicts');
    }
    static conflictFolderId() {
        return 'c04f1c7c04f1c7c04f1c7c04f1c7c04f';
    }
    static conflictFolder() {
        return {
            type_: this.TYPE_FOLDER,
            id: this.conflictFolderId(),
            parent_id: '',
            title: this.conflictFolderTitle(),
            updated_time: time_1.default.unixMs(),
            user_updated_time: time_1.default.unixMs(),
        };
    }
    // Calculates note counts for all folders and adds the note_count attribute to each folder
    // Note: this only calculates the overall number of nodes for this folder and all its descendants
    static addNoteCounts(folders, includeCompletedTodos = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const foldersById = {};
            for (const f of folders) {
                foldersById[f.id] = f;
                if (this.conflictFolderId() === f.id) {
                    f.note_count = yield Note_1.default.conflictedCount();
                }
                else {
                    f.note_count = 0;
                }
            }
            const where = ['is_conflict = 0'];
            if (!includeCompletedTodos)
                where.push('(notes.is_todo = 0 OR notes.todo_completed = 0)');
            const sql = `
			SELECT folders.id as folder_id, count(notes.parent_id) as note_count 
			FROM folders LEFT JOIN notes ON notes.parent_id = folders.id
			WHERE ${where.join(' AND ')}
			GROUP BY folders.id
		`;
            const noteCounts = yield this.db().selectAll(sql);
            noteCounts.forEach((noteCount) => {
                let parentId = noteCount.folder_id;
                do {
                    const folder = foldersById[parentId];
                    if (!folder)
                        break; // https://github.com/laurent22/joplin/issues/2079
                    folder.note_count = (folder.note_count || 0) + noteCount.note_count;
                    // Should not happen anymore but just to be safe, add the check below
                    // https://github.com/laurent22/joplin/issues/3334
                    if (folder.id === folder.parent_id)
                        break;
                    parentId = folder.parent_id;
                } while (parentId);
            });
        });
    }
    // Folders that contain notes that have been modified recently go on top.
    // The remaining folders, that don't contain any notes are sorted by their own user_updated_time
    static orderByLastModified(folders, dir = 'DESC') {
        return __awaiter(this, void 0, void 0, function* () {
            dir = dir.toUpperCase();
            const sql = 'select parent_id, max(user_updated_time) content_updated_time from notes where parent_id != "" group by parent_id';
            const rows = yield this.db().selectAll(sql);
            const folderIdToTime = {};
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                folderIdToTime[row.parent_id] = row.content_updated_time;
            }
            const findFolderParent = (folderId) => {
                const folder = BaseModel_1.default.byId(folders, folderId);
                if (!folder)
                    return null; // For the rare case of notes that are associated with a no longer existing folder
                if (!folder.parent_id)
                    return null;
                for (let i = 0; i < folders.length; i++) {
                    if (folders[i].id === folder.parent_id)
                        return folders[i];
                }
                // In some rare cases, some folders may not have a parent, for example
                // if it has not been downloaded via sync yet.
                // https://github.com/laurent22/joplin/issues/2088
                return null;
            };
            const applyChildTimeToParent = (folderId) => {
                const parent = findFolderParent(folderId);
                if (!parent)
                    return;
                if (folderIdToTime[parent.id] && folderIdToTime[parent.id] >= folderIdToTime[folderId]) {
                    // Don't change so that parent has the same time as the last updated child
                }
                else {
                    folderIdToTime[parent.id] = folderIdToTime[folderId];
                }
                applyChildTimeToParent(parent.id);
            };
            for (const folderId in folderIdToTime) {
                if (!folderIdToTime.hasOwnProperty(folderId))
                    continue;
                applyChildTimeToParent(folderId);
            }
            const mod = dir === 'DESC' ? +1 : -1;
            const output = folders.slice();
            output.sort((a, b) => {
                const aTime = folderIdToTime[a.id] ? folderIdToTime[a.id] : a.user_updated_time;
                const bTime = folderIdToTime[b.id] ? folderIdToTime[b.id] : b.user_updated_time;
                if (aTime < bTime)
                    return +1 * mod;
                if (aTime > bTime)
                    return -1 * mod;
                return 0;
            });
            return output;
        });
    }
    static all(options = null) {
        const _super = Object.create(null, {
            all: { get: () => super.all }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const output = yield _super.all.call(this, options);
            if (options && options.includeConflictFolder) {
                const conflictCount = yield Note_1.default.conflictedCount();
                if (conflictCount)
                    output.push(this.conflictFolder());
            }
            return output;
        });
    }
    static childrenIds(folderId) {
        return __awaiter(this, void 0, void 0, function* () {
            const folders = yield this.db().selectAll('SELECT id FROM folders WHERE parent_id = ?', [folderId]);
            let output = [];
            for (let i = 0; i < folders.length; i++) {
                const f = folders[i];
                output.push(f.id);
                const subChildrenIds = yield this.childrenIds(f.id);
                output = output.concat(subChildrenIds);
            }
            return output;
        });
    }
    static expandTree(folders, parentId) {
        return __awaiter(this, void 0, void 0, function* () {
            const folderPath = yield this.folderPath(folders, parentId);
            folderPath.pop(); // We don't expand the leaft notebook
            for (const folder of folderPath) {
                this.dispatch({
                    type: 'FOLDER_SET_COLLAPSED',
                    id: folder.id,
                    collapsed: false,
                });
            }
        });
    }
    static allChildrenFolders(folderId) {
        return __awaiter(this, void 0, void 0, function* () {
            const sql = `
			WITH RECURSIVE
				folders_cte(id, parent_id, share_id) AS (
					SELECT id, parent_id, share_id
						FROM folders
						WHERE parent_id = ?
					UNION ALL
						SELECT folders.id, folders.parent_id, folders.share_id
							FROM folders
							INNER JOIN folders_cte AS folders_cte ON (folders.parent_id = folders_cte.id)
				)
				SELECT id, parent_id, share_id FROM folders_cte;
		`;
            return this.db().selectAll(sql, [folderId]);
        });
    }
    static rootSharedFolders() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.db().selectAll('SELECT id, share_id FROM folders WHERE parent_id = "" AND share_id != ""');
        });
    }
    static rootShareFoldersByKeyId(keyId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.db().selectAll('SELECT id, share_id FROM folders WHERE master_key_id = ?', [keyId]);
        });
    }
    static updateFolderShareIds() {
        return __awaiter(this, void 0, void 0, function* () {
            // Get all the sub-folders of the shared folders, and set the share_id
            // property.
            const rootFolders = yield this.rootSharedFolders();
            let sharedFolderIds = [];
            const report = {
                shareUpdateCount: 0,
                unshareUpdateCount: 0,
            };
            for (const rootFolder of rootFolders) {
                const children = yield this.allChildrenFolders(rootFolder.id);
                report.shareUpdateCount += children.length;
                for (const child of children) {
                    if (child.share_id !== rootFolder.share_id) {
                        yield this.save({
                            id: child.id,
                            share_id: rootFolder.share_id,
                            updated_time: Date.now(),
                        }, { autoTimestamp: false });
                    }
                }
                sharedFolderIds.push(rootFolder.id);
                sharedFolderIds = sharedFolderIds.concat(children.map(c => c.id));
            }
            // Now that we've set the share ID on all the sub-folders of the shared
            // folders, those that remain should not be shared anymore. For example,
            // if they've been moved out of a shared folder.
            // await this.unshareItems(ModelType.Folder, sharedFolderIds);
            const sql = ['SELECT id, parent_id FROM folders WHERE share_id != ""'];
            if (sharedFolderIds.length) {
                sql.push(` AND id NOT IN ("${sharedFolderIds.join('","')}")`);
            }
            const foldersToUnshare = yield this.db().selectAll(sql.join(' '));
            report.unshareUpdateCount += foldersToUnshare.length;
            for (const item of foldersToUnshare) {
                yield this.save({
                    id: item.id,
                    share_id: '',
                    updated_time: Date.now(),
                    parent_id: item.parent_id,
                }, { autoTimestamp: false });
            }
            logger.debug('updateFolderShareIds:', report);
        });
    }
    static updateNoteShareIds() {
        return __awaiter(this, void 0, void 0, function* () {
            // Find all the notes where the share_id is not the same as the
            // parent share_id because we only need to update those.
            const rows = yield this.db().selectAll(`
			SELECT notes.id, folders.share_id, notes.parent_id
			FROM notes
			LEFT JOIN folders ON notes.parent_id = folders.id
			WHERE notes.share_id != folders.share_id
		`);
            logger.debug('updateNoteShareIds: notes to update:', rows.length);
            for (const row of rows) {
                yield Note_1.default.save({
                    id: row.id,
                    share_id: row.share_id || '',
                    parent_id: row.parent_id,
                    updated_time: Date.now(),
                }, { autoTimestamp: false });
            }
        });
    }
    static updateResourceShareIds(resourceService) {
        return __awaiter(this, void 0, void 0, function* () {
            // Updating the share_id property of the resources is complex because:
            //
            // The resource association to the note is done indirectly via the
            // ResourceService
            //
            // And a given resource can appear inside multiple notes. However, for
            // sharing we make the assumption that a resource can be part of only
            // one share (one-to-one relationship because "share_id" is part of the
            // "resources" table), which is usually the case. By copying and pasting
            // note content from one note to another it's however possible to have
            // the same resource in multiple shares (or in a non-shared and a shared
            // folder).
            //
            // So in this function we take this into account - if a shared resource
            // is part of multiple notes, we duplicate that resource so that each
            // note has its own instance. When such duplication happens, we need to
            // resume the process from the start (thus the loop) so that we deal
            // with the right note/resource associations.
            for (let i = 0; i < 5; i++) {
                // Find all resources where share_id is different from parent note
                // share_id. Then update share_id on all these resources. Essentially it
                // makes it match the resource share_id to the note share_id. At the
                // same time we also process the is_shared property.
                const rows = yield this.db().selectAll(`
				SELECT r.id, n.share_id, n.is_shared
				FROM note_resources nr
				LEFT JOIN resources r ON nr.resource_id = r.id
				LEFT JOIN notes n ON nr.note_id = n.id
				WHERE (
					n.share_id != r.share_id
					OR n.is_shared != r.is_shared
				) AND nr.is_associated = 1
			`);
                if (!rows.length)
                    return;
                logger.debug('updateResourceShareIds: resources to update:', rows.length);
                const resourceIds = rows.map(r => r.id);
                // Now we check, for each resource, that it is associated with only
                // one note. If it is not, we create duplicate resources so that
                // each note has its own separate resource.
                const noteResourceAssociations = yield this.db().selectAll(`
				SELECT resource_id, note_id, notes.share_id
				FROM note_resources
				LEFT JOIN notes ON notes.id = note_resources.note_id
				WHERE resource_id IN ('${resourceIds.join('\',\'')}')
				AND is_associated = 1
			`);
                const resourceIdToNotes = {};
                for (const r of noteResourceAssociations) {
                    if (!resourceIdToNotes[r.resource_id])
                        resourceIdToNotes[r.resource_id] = [];
                    resourceIdToNotes[r.resource_id].push(r);
                }
                let hasCreatedResources = false;
                for (const [resourceId, rows] of Object.entries(resourceIdToNotes)) {
                    if (rows.length <= 1)
                        continue;
                    for (let i = 0; i < rows.length - 1; i++) {
                        const row = rows[i];
                        const note = yield Note_1.default.load(row.note_id);
                        if (!note)
                            continue; // probably got deleted in the meantime?
                        const newResource = yield Resource_1.default.duplicateResource(resourceId);
                        logger.info(`updateResourceShareIds: Automatically created resource "${newResource.id}" to replace resource "${resourceId}" because it is shared and duplicate across notes:`, row);
                        const regex = new RegExp(resourceId, 'gi');
                        const newBody = note.body.replace(regex, newResource.id);
                        yield Note_1.default.save({
                            id: note.id,
                            body: newBody,
                            parent_id: note.parent_id,
                            updated_time: Date.now(),
                        }, {
                            autoTimestamp: false,
                        });
                        hasCreatedResources = true;
                    }
                }
                // If we have created resources, we refresh the note/resource
                // associations using ResourceService and we resume the process.
                // Normally, if the user didn't create any new notes or resources in
                // the meantime, the second loop should find that each shared
                // resource is associated with only one note.
                if (hasCreatedResources) {
                    yield resourceService.indexNoteResources();
                    continue;
                }
                else {
                    // If all is good, we can set the share_id and is_shared
                    // property of the resource.
                    for (const row of rows) {
                        yield Resource_1.default.save({
                            id: row.id,
                            share_id: row.share_id || '',
                            is_shared: row.is_shared,
                            updated_time: Date.now(),
                        }, { autoTimestamp: false });
                    }
                    return;
                }
            }
            throw new Error('Failed to update resource share IDs');
        });
    }
    static updateAllShareIds(resourceService) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.updateFolderShareIds();
            yield this.updateNoteShareIds();
            yield this.updateResourceShareIds(resourceService);
        });
    }
    // Clear the "share_id" property for the items that are associated with a
    // share that no longer exists.
    static updateNoLongerSharedItems(activeShareIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const tableNameToClasses = {
                'folders': Folder,
                'notes': Note_1.default,
                'resources': Resource_1.default,
            };
            const report = {};
            for (const tableName of ['folders', 'notes', 'resources']) {
                const ItemClass = tableNameToClasses[tableName];
                const hasParentId = tableName !== 'resources';
                const fields = ['id'];
                if (hasParentId)
                    fields.push('parent_id');
                const query = activeShareIds.length ? `
				SELECT ${this.db().escapeFields(fields)} FROM ${tableName}
				WHERE share_id != "" AND share_id NOT IN ("${activeShareIds.join('","')}")
			` : `
				SELECT ${this.db().escapeFields(fields)} FROM ${tableName}
				WHERE share_id != ''
			`;
                const rows = yield this.db().selectAll(query);
                report[tableName] = rows.length;
                for (const row of rows) {
                    const toSave = {
                        id: row.id,
                        share_id: '',
                        updated_time: Date.now(),
                    };
                    if (hasParentId)
                        toSave.parent_id = row.parent_id;
                    yield ItemClass.save(toSave, { autoTimestamp: false });
                }
            }
            logger.debug('updateNoLongerSharedItems:', report);
        });
    }
    static allAsTree(folders = null, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const all = folders ? folders : yield this.all(options);
            if (options && options.includeNotes) {
                for (const folder of all) {
                    folder.notes = yield Note_1.default.previews(folder.id);
                }
            }
            // https://stackoverflow.com/a/49387427/561309
            function getNestedChildren(models, parentId) {
                const nestedTreeStructure = [];
                const length = models.length;
                for (let i = 0; i < length; i++) {
                    const model = models[i];
                    if (model.parent_id === parentId) {
                        const children = getNestedChildren(models, model.id);
                        if (children.length > 0) {
                            model.children = children;
                        }
                        nestedTreeStructure.push(model);
                    }
                }
                return nestedTreeStructure;
            }
            return getNestedChildren(all, '');
        });
    }
    static folderPath(folders, folderId) {
        const idToFolders = {};
        for (let i = 0; i < folders.length; i++) {
            idToFolders[folders[i].id] = folders[i];
        }
        const path = [];
        while (folderId) {
            const folder = idToFolders[folderId];
            if (!folder)
                break; // Shouldn't happen
            path.push(folder);
            folderId = folder.parent_id;
        }
        path.reverse();
        return path;
    }
    static folderPathString(folders, folderId, maxTotalLength = 80) {
        const path = this.folderPath(folders, folderId);
        let currentTotalLength = 0;
        for (let i = 0; i < path.length; i++) {
            currentTotalLength += path[i].title.length;
        }
        let pieceLength = maxTotalLength;
        if (currentTotalLength > maxTotalLength) {
            pieceLength = maxTotalLength / path.length;
        }
        const output = [];
        for (let i = 0; i < path.length; i++) {
            output.push(substrWithEllipsis(path[i].title, 0, pieceLength));
        }
        return output.join(' / ');
    }
    static buildTree(folders) {
        const idToFolders = {};
        for (let i = 0; i < folders.length; i++) {
            idToFolders[folders[i].id] = Object.assign({}, folders[i]);
            idToFolders[folders[i].id].children = [];
        }
        const rootFolders = [];
        for (const folderId in idToFolders) {
            if (!idToFolders.hasOwnProperty(folderId))
                continue;
            const folder = idToFolders[folderId];
            if (!folder.parent_id) {
                rootFolders.push(folder);
            }
            else {
                if (!idToFolders[folder.parent_id]) {
                    // It means the notebook is refering a folder that doesn't exist. In theory it shouldn't happen
                    // but sometimes does - https://github.com/laurent22/joplin/issues/1068#issuecomment-450594708
                    rootFolders.push(folder);
                }
                else {
                    idToFolders[folder.parent_id].children.push(folder);
                }
            }
        }
        return rootFolders;
    }
    static sortFolderTree(folders = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const output = folders ? folders : yield this.allAsTree();
            const sortFoldersAlphabetically = (folders) => {
                folders.sort((a, b) => {
                    if (a.parent_id === b.parent_id) {
                        return a.title.localeCompare(b.title, undefined, { sensitivity: 'accent' });
                    }
                    return 0;
                });
                return folders;
            };
            const sortFolders = (folders) => {
                for (let i = 0; i < folders.length; i++) {
                    const folder = folders[i];
                    if (folder.children) {
                        folder.children = sortFoldersAlphabetically(folder.children);
                        sortFolders(folder.children);
                    }
                }
                return folders;
            };
            sortFolders(sortFoldersAlphabetically(output));
            return output;
        });
    }
    static load(id, _options = null) {
        if (id === this.conflictFolderId())
            return Promise.resolve(this.conflictFolder());
        return super.load(id);
    }
    static defaultFolder() {
        return this.modelSelectOne('SELECT * FROM folders ORDER BY created_time DESC LIMIT 1');
    }
    static canNestUnder(folderId, targetFolderId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (folderId === targetFolderId)
                return false;
            const folder = yield Folder.load(folderId);
            if ((0, reducer_1.isRootSharedFolder)(folder))
                return false;
            const conflictFolderId = Folder.conflictFolderId();
            if (folderId === conflictFolderId || targetFolderId === conflictFolderId)
                return false;
            if (!targetFolderId)
                return true;
            while (true) {
                const folder = yield Folder.load(targetFolderId);
                if (!folder.parent_id)
                    break;
                if (folder.parent_id === folderId)
                    return false;
                targetFolderId = folder.parent_id;
            }
            return true;
        });
    }
    static moveToFolder(folderId, targetFolderId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.canNestUnder(folderId, targetFolderId)))
                throw new Error((0, locale_1._)('Cannot move notebook to this location'));
            // When moving a note to a different folder, the user timestamp is not updated.
            // However updated_time is updated so that the note can be synced later on.
            const modifiedFolder = {
                id: folderId,
                parent_id: targetFolderId,
                updated_time: time_1.default.unixMs(),
            };
            return Folder.save(modifiedFolder, { autoTimestamp: false });
        });
    }
    // These "duplicateCheck" and "reservedTitleCheck" should only be done when a user is
    // manually creating a folder. They shouldn't be done for example when the folders
    // are being synced to avoid any strange side-effects. Technically it's possible to
    // have folders and notes with duplicate titles (or no title), or with reserved words.
    static save(o, options = null) {
        const _super = Object.create(null, {
            save: { get: () => super.save }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!options)
                options = {};
            if (options.userSideValidation === true) {
                if (!('duplicateCheck' in options))
                    options.duplicateCheck = true;
                if (!('reservedTitleCheck' in options))
                    options.reservedTitleCheck = true;
                if (!('stripLeftSlashes' in options))
                    options.stripLeftSlashes = true;
                if (o.id && o.parent_id && o.id === o.parent_id) {
                    throw new Error('Parent ID cannot be the same as ID');
                }
            }
            if (options.stripLeftSlashes === true && o.title) {
                while (o.title.length && (o.title[0] === '/' || o.title[0] === '\\')) {
                    o.title = o.title.substr(1);
                }
            }
            // We allow folders with duplicate titles so that folders with the same title can exist under different parent folder. For example:
            //
            // PHP
            //     Code samples
            //     Doc
            // Java
            //     My project
            //     Doc
            // if (options.duplicateCheck === true && o.title) {
            // 	let existingFolder = await Folder.loadByTitle(o.title);
            // 	if (existingFolder && existingFolder.id != o.id) throw new Error(_('A notebook with this title already exists: "%s"', o.title));
            // }
            if (options.reservedTitleCheck === true && o.title) {
                if (o.title === Folder.conflictFolderTitle())
                    throw new Error((0, locale_1._)('Notebooks cannot be named "%s", which is a reserved title.', o.title));
            }
            syncDebugLog_1.default.info('Folder Save:', o);
            // eslint-disable-next-line promise/prefer-await-to-then -- Old code before rule was applied
            return _super.save.call(this, o, options).then((folder) => {
                this.dispatch({
                    type: 'FOLDER_UPDATE_ONE',
                    item: folder,
                });
                return folder;
            });
        });
    }
    static serializeIcon(icon) {
        return icon ? JSON.stringify(icon) : '';
    }
    static unserializeIcon(icon) {
        if (!icon)
            return null;
        return Object.assign(Object.assign({}, (0, types_1.defaultFolderIcon)()), JSON.parse(icon));
    }
    static shouldShowFolderIcons(folders) {
        // If at least one of the folder has an icon, then we display icons for all
        // folders (those without one will get the default icon). This is so that
        // visual alignment is correct for all folders, otherwise the folder tree
        // looks messy.
        return !!folders.find(f => !!f.icon);
    }
}
exports.default = Folder;
//# sourceMappingURL=Folder.js.map