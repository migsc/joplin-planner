"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseModel_1 = require("../BaseModel");
const BaseItem_1 = require("./BaseItem");
const NoteTag_1 = require("./NoteTag");
const Note_1 = require("./Note");
const locale_1 = require("../locale");
class Tag extends BaseItem_1.default {
    static tableName() {
        return 'tags';
    }
    static modelType() {
        return BaseModel_1.default.TYPE_TAG;
    }
    static noteIds(tagId) {
        return __awaiter(this, void 0, void 0, function* () {
            const rows = yield this.db().selectAll('SELECT note_id FROM note_tags WHERE tag_id = ?', [tagId]);
            const output = [];
            for (let i = 0; i < rows.length; i++) {
                output.push(rows[i].note_id);
            }
            return output;
        });
    }
    static notes(tagId, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options === null)
                options = {};
            const noteIds = yield this.noteIds(tagId);
            if (!noteIds.length)
                return [];
            return Note_1.default.previews(null, Object.assign({}, options, {
                conditions: [`id IN ("${noteIds.join('","')}")`],
            }));
        });
    }
    // Untag all the notes and delete tag
    static untagAll(tagId) {
        return __awaiter(this, void 0, void 0, function* () {
            const noteTags = yield NoteTag_1.default.modelSelectAll('SELECT id FROM note_tags WHERE tag_id = ?', [tagId]);
            for (let i = 0; i < noteTags.length; i++) {
                yield NoteTag_1.default.delete(noteTags[i].id);
            }
            yield Tag.delete(tagId);
        });
    }
    static delete(id, options = null) {
        const _super = Object.create(null, {
            delete: { get: () => super.delete }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!options)
                options = {};
            yield _super.delete.call(this, id, options);
            this.dispatch({
                type: 'TAG_DELETE',
                id: id,
            });
        });
    }
    static addNote(tagId, noteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const hasIt = yield this.hasNote(tagId, noteId);
            if (hasIt)
                return;
            const output = yield NoteTag_1.default.save({
                tag_id: tagId,
                note_id: noteId,
            });
            // While syncing or importing notes, the app might associate a tag ID with a note ID
            // but the actual items might not have been downloaded yet, so
            // check that we actually get some result before dispatching
            // the action.
            //
            // Fixes: https://github.com/laurent22/joplin/issues/3958#issuecomment-714320526
            //
            // Also probably fixes the errors on GitHub about reducer
            // items being undefined.
            const tagWithCount = yield Tag.loadWithCount(tagId);
            if (tagWithCount) {
                this.dispatch({
                    type: 'TAG_UPDATE_ONE',
                    item: tagWithCount,
                });
            }
            return output;
        });
    }
    static removeNote(tagId, noteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const noteTags = yield NoteTag_1.default.modelSelectAll('SELECT id FROM note_tags WHERE tag_id = ? and note_id = ?', [tagId, noteId]);
            for (let i = 0; i < noteTags.length; i++) {
                yield NoteTag_1.default.delete(noteTags[i].id);
            }
            this.dispatch({
                type: 'NOTE_TAG_REMOVE',
                item: yield Tag.load(tagId),
            });
        });
    }
    static loadWithCount(tagId) {
        const sql = 'SELECT * FROM tags_with_note_count WHERE id = ?';
        return this.modelSelectOne(sql, [tagId]);
    }
    static hasNote(tagId, noteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.db().selectOne('SELECT note_id FROM note_tags WHERE tag_id = ? AND note_id = ? LIMIT 1', [tagId, noteId]);
            return !!r;
        });
    }
    static allWithNotes() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield Tag.modelSelectAll('SELECT * FROM tags_with_note_count');
        });
    }
    static searchAllWithNotes(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options)
                options = {};
            if (!options.conditions)
                options.conditions = [];
            options.conditions.push('id IN (SELECT distinct id FROM tags_with_note_count)');
            return this.search(options);
        });
    }
    static tagsByNoteId(noteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tagIds = yield NoteTag_1.default.tagIdsByNoteId(noteId);
            if (!tagIds.length)
                return [];
            return this.modelSelectAll(`SELECT * FROM tags WHERE id IN ("${tagIds.join('","')}")`);
        });
    }
    static commonTagsByNoteIds(noteIds) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!noteIds || noteIds.length === 0) {
                return [];
            }
            let commonTagIds = yield NoteTag_1.default.tagIdsByNoteId(noteIds[0]);
            for (let i = 1; i < noteIds.length; i++) {
                const tagIds = yield NoteTag_1.default.tagIdsByNoteId(noteIds[i]);
                commonTagIds = commonTagIds.filter(value => tagIds.includes(value));
                if (commonTagIds.length === 0) {
                    break;
                }
            }
            return this.modelSelectAll(`SELECT * FROM tags WHERE id IN ("${commonTagIds.join('","')}")`);
        });
    }
    static loadByTitle(title) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.loadByField('title', title, { caseInsensitive: true });
        });
    }
    static addNoteTagByTitle(noteId, tagTitle) {
        return __awaiter(this, void 0, void 0, function* () {
            let tag = yield this.loadByTitle(tagTitle);
            if (!tag)
                tag = yield Tag.save({ title: tagTitle }, { userSideValidation: true });
            return yield this.addNote(tag.id, noteId);
        });
    }
    static setNoteTagsByTitles(noteId, tagTitles) {
        return __awaiter(this, void 0, void 0, function* () {
            const previousTags = yield this.tagsByNoteId(noteId);
            const addedTitles = [];
            for (let i = 0; i < tagTitles.length; i++) {
                const title = tagTitles[i].trim().toLowerCase();
                if (!title)
                    continue;
                let tag = yield this.loadByTitle(title);
                if (!tag)
                    tag = yield Tag.save({ title: title }, { userSideValidation: true });
                yield this.addNote(tag.id, noteId);
                addedTitles.push(title);
            }
            for (let i = 0; i < previousTags.length; i++) {
                if (addedTitles.indexOf(previousTags[i].title.toLowerCase()) < 0) {
                    yield this.removeNote(previousTags[i].id, noteId);
                }
            }
        });
    }
    static setNoteTagsByIds(noteId, tagIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const previousTags = yield this.tagsByNoteId(noteId);
            const addedIds = [];
            for (let i = 0; i < tagIds.length; i++) {
                const tagId = tagIds[i];
                yield this.addNote(tagId, noteId);
                addedIds.push(tagId);
            }
            for (let i = 0; i < previousTags.length; i++) {
                if (addedIds.indexOf(previousTags[i].id) < 0) {
                    yield this.removeNote(previousTags[i].id, noteId);
                }
            }
        });
    }
    static save(o, options = null) {
        const _super = Object.create(null, {
            save: { get: () => super.save }
        });
        return __awaiter(this, void 0, void 0, function* () {
            options = Object.assign({}, {
                dispatchUpdateAction: true,
                userSideValidation: false,
            }, options);
            if (options.userSideValidation) {
                if ('title' in o) {
                    o.title = o.title.trim().toLowerCase();
                    const existingTag = yield Tag.loadByTitle(o.title);
                    if (existingTag && existingTag.id !== o.id)
                        throw new Error((0, locale_1._)('The tag "%s" already exists. Please choose a different name.', o.title));
                }
            }
            // eslint-disable-next-line promise/prefer-await-to-then -- Old code before rule was applied
            return _super.save.call(this, o, options).then((tag) => {
                if (options.dispatchUpdateAction) {
                    this.dispatch({
                        type: 'TAG_UPDATE_ONE',
                        item: tag,
                    });
                }
                return tag;
            });
        });
    }
}
exports.default = Tag;
//# sourceMappingURL=Tag.js.map