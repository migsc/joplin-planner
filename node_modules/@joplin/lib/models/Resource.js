"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseModel_1 = require("../BaseModel");
const BaseItem_1 = require("./BaseItem");
const ItemChange_1 = require("./ItemChange");
const NoteResource_1 = require("./NoteResource");
const Setting_1 = require("./Setting");
const markdownUtils_1 = require("../markdownUtils");
const locale_1 = require("../locale");
const ResourceLocalState_1 = require("./ResourceLocalState");
const pathUtils = require('../path-utils');
const { mime } = require('../mime-utils.js');
const { filename, safeFilename } = require('../path-utils');
const { FsDriverDummy } = require('../fs-driver-dummy.js');
const JoplinError_1 = require("../JoplinError");
const itemCanBeEncrypted_1 = require("./utils/itemCanBeEncrypted");
const syncInfoUtils_1 = require("../services/synchronizer/syncInfoUtils");
class Resource extends BaseItem_1.default {
    static tableName() {
        return 'resources';
    }
    static modelType() {
        return BaseModel_1.default.TYPE_RESOURCE;
    }
    static encryptionService() {
        if (!this.encryptionService_)
            throw new Error('Resource.encryptionService_ is not set!!');
        return this.encryptionService_;
    }
    static shareService() {
        if (!this.shareService_)
            throw new Error('Resource.shareService_ is not set!!');
        return this.shareService_;
    }
    static isSupportedImageMimeType(type) {
        const imageMimeTypes = ['image/jpg', 'image/jpeg', 'image/png', 'image/gif', 'image/svg+xml', 'image/webp'];
        return imageMimeTypes.indexOf(type.toLowerCase()) >= 0;
    }
    static fetchStatuses(resourceIds) {
        if (!resourceIds.length)
            return Promise.resolve([]);
        return this.db().selectAll(`SELECT resource_id, fetch_status FROM resource_local_states WHERE resource_id IN ("${resourceIds.join('","')}")`);
    }
    static sharedResourceIds() {
        return this.db().selectAllFields('SELECT id FROM resources WHERE is_shared = 1', [], 'id');
    }
    static errorFetchStatuses() {
        return this.db().selectAll(`
			SELECT title AS resource_title, resource_id, fetch_error
			FROM resource_local_states
			LEFT JOIN resources ON resources.id = resource_local_states.resource_id
			WHERE fetch_status = ?
		`, [Resource.FETCH_STATUS_ERROR]);
    }
    static needToBeFetched(resourceDownloadMode = null, limit = null) {
        const sql = ['SELECT * FROM resources WHERE encryption_applied = 0 AND id IN (SELECT resource_id FROM resource_local_states WHERE fetch_status = ?)'];
        if (resourceDownloadMode !== 'always') {
            sql.push('AND resources.id IN (SELECT resource_id FROM resources_to_download)');
        }
        sql.push('ORDER BY updated_time DESC');
        if (limit !== null)
            sql.push(`LIMIT ${limit}`);
        return this.modelSelectAll(sql.join(' '), [Resource.FETCH_STATUS_IDLE]);
    }
    static resetStartedFetchStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.db().exec('UPDATE resource_local_states SET fetch_status = ? WHERE fetch_status = ?', [Resource.FETCH_STATUS_IDLE, Resource.FETCH_STATUS_STARTED]);
        });
    }
    static resetErrorStatus(resourceId) {
        return this.db().exec('UPDATE resource_local_states SET fetch_status = ?, fetch_error = "" WHERE resource_id = ?', [Resource.FETCH_STATUS_IDLE, resourceId]);
    }
    static fsDriver() {
        if (!Resource.fsDriver_)
            Resource.fsDriver_ = new FsDriverDummy();
        return Resource.fsDriver_;
    }
    // DEPRECATED IN FAVOUR OF friendlySafeFilename()
    static friendlyFilename(resource) {
        let output = safeFilename(resource.title); // Make sure not to allow spaces or any special characters as it's not supported in HTTP headers
        if (!output)
            output = resource.id;
        let extension = resource.file_extension;
        if (!extension)
            extension = resource.mime ? mime.toFileExtension(resource.mime) : '';
        extension = extension ? `.${extension}` : '';
        return output + extension;
    }
    static baseDirectoryPath() {
        return Setting_1.default.value('resourceDir');
    }
    static baseRelativeDirectoryPath() {
        return Setting_1.default.value('resourceDirName');
    }
    static filename(resource, encryptedBlob = false) {
        let extension = encryptedBlob ? 'crypted' : resource.file_extension;
        if (!extension)
            extension = resource.mime ? mime.toFileExtension(resource.mime) : '';
        extension = extension ? `.${extension}` : '';
        return resource.id + extension;
    }
    static friendlySafeFilename(resource) {
        let ext = resource.file_extension;
        if (!ext)
            ext = resource.mime ? mime.toFileExtension(resource.mime) : '';
        const safeExt = ext ? pathUtils.safeFileExtension(ext).toLowerCase() : '';
        let title = resource.title ? resource.title : resource.id;
        if (safeExt && pathUtils.fileExtension(title).toLowerCase() === safeExt)
            title = pathUtils.filename(title);
        return pathUtils.friendlySafeFilename(title) + (safeExt ? `.${safeExt}` : '');
    }
    static relativePath(resource, encryptedBlob = false) {
        return `${Setting_1.default.value('resourceDirName')}/${this.filename(resource, encryptedBlob)}`;
    }
    static fullPath(resource, encryptedBlob = false) {
        return `${Setting_1.default.value('resourceDir')}/${this.filename(resource, encryptedBlob)}`;
    }
    static isReady(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.readyStatus(resource);
            return r === 'ok';
        });
    }
    static readyStatus(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const ls = yield this.localState(resource);
            if (!resource)
                return 'notFound';
            if (ls.fetch_status !== Resource.FETCH_STATUS_DONE)
                return 'notDownloaded';
            if (resource.encryption_blob_encrypted)
                return 'encrypted';
            return 'ok';
        });
    }
    static requireIsReady(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const readyStatus = yield Resource.readyStatus(resource);
            if (readyStatus !== 'ok')
                throw new Error(`Resource is not ready. Status: ${readyStatus}`);
        });
    }
    // For resources, we need to decrypt the item (metadata) and the resource binary blob.
    static decrypt(item) {
        const _super = Object.create(null, {
            decrypt: { get: () => super.decrypt },
            save: { get: () => super.save }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // The item might already be decrypted but not the blob (for instance if it crashes while
            // decrypting the blob or was otherwise interrupted).
            const decryptedItem = item.encryption_cipher_text ? yield _super.decrypt.call(this, item) : Object.assign({}, item);
            if (!decryptedItem.encryption_blob_encrypted)
                return decryptedItem;
            const localState = yield this.localState(item);
            if (localState.fetch_status !== Resource.FETCH_STATUS_DONE) {
                // Not an error - it means the blob has not been downloaded yet.
                // It will be decrypted later on, once downloaded.
                return decryptedItem;
            }
            const plainTextPath = this.fullPath(decryptedItem);
            const encryptedPath = this.fullPath(decryptedItem, true);
            const noExtPath = `${pathUtils.dirname(encryptedPath)}/${pathUtils.filename(encryptedPath)}`;
            // When the resource blob is downloaded by the synchroniser, it's initially a file with no
            // extension (since it's encrypted, so we don't know its extension). So here rename it
            // to a file with a ".crypted" extension so that it's better identified, and then decrypt it.
            // Potentially plainTextPath is also a path with no extension if it's an unknown mime type.
            if (yield this.fsDriver().exists(noExtPath)) {
                yield this.fsDriver().move(noExtPath, encryptedPath);
            }
            try {
                yield this.encryptionService().decryptFile(encryptedPath, plainTextPath);
            }
            catch (error) {
                if (error.code === 'invalidIdentifier') {
                    // As the identifier is invalid it most likely means that this is not encrypted data
                    // at all. It can happen for example when there's a crash between the moment the data
                    // is decrypted and the resource item is updated.
                    this.logger().warn(`Found a resource that was most likely already decrypted but was marked as encrypted. Marked it as decrypted: ${item.id}`);
                    this.fsDriver().move(encryptedPath, plainTextPath);
                }
                else {
                    throw error;
                }
            }
            decryptedItem.encryption_blob_encrypted = 0;
            return _super.save.call(this, decryptedItem, { autoTimestamp: false });
        });
    }
    // Prepare the resource by encrypting it if needed.
    // The call returns the path to the physical file AND a representation of the resource object
    // as it should be uploaded to the sync target. Note that this may be different from what is stored
    // in the database. In particular, the flag encryption_blob_encrypted might be 1 on the sync target
    // if the resource is encrypted, but will be 0 locally because the device has the decrypted resource.
    static fullPathForSyncUpload(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const plainTextPath = this.fullPath(resource);
            const share = resource.share_id ? yield this.shareService().shareById(resource.share_id) : null;
            if (!(0, syncInfoUtils_1.getEncryptionEnabled)() || !(0, itemCanBeEncrypted_1.default)(resource, share)) {
                // Normally not possible since itemsThatNeedSync should only return decrypted items
                if (resource.encryption_blob_encrypted)
                    throw new Error('Trying to access encrypted resource but encryption is currently disabled');
                return { path: plainTextPath, resource: resource };
            }
            const encryptedPath = this.fullPath(resource, true);
            if (resource.encryption_blob_encrypted)
                return { path: encryptedPath, resource: resource };
            try {
                yield this.encryptionService().encryptFile(plainTextPath, encryptedPath, {
                    masterKeyId: share && share.master_key_id ? share.master_key_id : '',
                });
            }
            catch (error) {
                if (error.code === 'ENOENT')
                    throw new JoplinError_1.default(`File not found:${error.toString()}`, 'fileNotFound');
                throw error;
            }
            const resourceCopy = Object.assign({}, resource);
            resourceCopy.encryption_blob_encrypted = 1;
            return { path: encryptedPath, resource: resourceCopy };
        });
    }
    static markdownTag(resource) {
        let tagAlt = resource.alt ? resource.alt : resource.title;
        if (!tagAlt)
            tagAlt = '';
        const lines = [];
        if (Resource.isSupportedImageMimeType(resource.mime)) {
            lines.push('![');
            lines.push(markdownUtils_1.default.escapeTitleText(tagAlt));
            lines.push(`](:/${resource.id})`);
        }
        else {
            lines.push('[');
            lines.push(markdownUtils_1.default.escapeTitleText(tagAlt));
            lines.push(`](:/${resource.id})`);
        }
        return lines.join('');
    }
    static internalUrl(resource) {
        return `:/${resource.id}`;
    }
    static pathToId(path) {
        return filename(path);
    }
    static content(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fsDriver().readFile(this.fullPath(resource), 'Buffer');
        });
    }
    static isResourceUrl(url) {
        return url && url.length === 34 && url[0] === ':' && url[1] === '/';
    }
    static urlToId(url) {
        if (!this.isResourceUrl(url))
            throw new Error(`Not a valid resource URL: ${url}`);
        return url.substr(2);
    }
    static localState(resourceOrId) {
        return __awaiter(this, void 0, void 0, function* () {
            return ResourceLocalState_1.default.byResourceId(typeof resourceOrId === 'object' ? resourceOrId.id : resourceOrId);
        });
    }
    static setLocalState(resourceOrId, state) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = typeof resourceOrId === 'object' ? resourceOrId.id : resourceOrId;
            yield ResourceLocalState_1.default.save(Object.assign({}, state, { resource_id: id }));
        });
    }
    static needFileSizeSet() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.modelSelectAll('SELECT * FROM resources WHERE `size` < 0 AND encryption_blob_encrypted = 0');
        });
    }
    // Only set the `size` field and nothing else, not even the update_time
    // This is because it's only necessary to do it once after migration 20
    // and each client does it so there's no need to sync the resource.
    static setFileSizeOnly(resourceId, fileSize) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.db().exec('UPDATE resources set `size` = ? WHERE id = ?', [fileSize, resourceId]);
        });
    }
    static batchDelete(ids, options = null) {
        const _super = Object.create(null, {
            batchDelete: { get: () => super.batchDelete }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // For resources, there's not really batch deleting since there's the file data to delete
            // too, so each is processed one by one with the item being deleted last (since the db
            // call is the less likely to fail).
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                const resource = yield Resource.load(id);
                if (!resource)
                    continue;
                const path = Resource.fullPath(resource);
                yield this.fsDriver().remove(path);
                yield _super.batchDelete.call(this, [id], options);
                yield NoteResource_1.default.deleteByResource(id); // Clean up note/resource relationships
            }
            yield ResourceLocalState_1.default.batchDelete(ids);
        });
    }
    static markForDownload(resourceId) {
        return __awaiter(this, void 0, void 0, function* () {
            // Insert the row only if it's not already there
            const t = Date.now();
            yield this.db().exec('INSERT INTO resources_to_download (resource_id, updated_time, created_time) SELECT ?, ?, ? WHERE NOT EXISTS (SELECT 1 FROM resources_to_download WHERE resource_id = ?)', [resourceId, t, t, resourceId]);
        });
    }
    static downloadedButEncryptedBlobCount(excludedIds = null) {
        return __awaiter(this, void 0, void 0, function* () {
            let excludedSql = '';
            if (excludedIds && excludedIds.length) {
                excludedSql = `AND resource_id NOT IN ("${excludedIds.join('","')}")`;
            }
            const r = yield this.db().selectOne(`
			SELECT count(*) as total
			FROM resource_local_states
			WHERE fetch_status = ?
			AND resource_id IN (SELECT id FROM resources WHERE encryption_blob_encrypted = 1)
			${excludedSql}
		`, [Resource.FETCH_STATUS_DONE]);
            return r ? r.total : 0;
        });
    }
    static downloadStatusCounts(status) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.db().selectOne(`
			SELECT count(*) as total
			FROM resource_local_states
			WHERE fetch_status = ?
		`, [status]);
            return r ? r.total : 0;
        });
    }
    static createdLocallyCount() {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.db().selectOne(`
			SELECT count(*) as total
			FROM resources
			WHERE id NOT IN
			(SELECT resource_id FROM resource_local_states)
		`);
            return r ? r.total : 0;
        });
    }
    static fetchStatusToLabel(status) {
        if (status === Resource.FETCH_STATUS_IDLE)
            return (0, locale_1._)('Not downloaded');
        if (status === Resource.FETCH_STATUS_STARTED)
            return (0, locale_1._)('Downloading');
        if (status === Resource.FETCH_STATUS_DONE)
            return (0, locale_1._)('Downloaded');
        if (status === Resource.FETCH_STATUS_ERROR)
            return (0, locale_1._)('Error');
        throw new Error(`Invalid status: ${status}`);
    }
    static updateResourceBlobContent(resourceId, newBlobFilePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const resource = yield Resource.load(resourceId);
            yield this.requireIsReady(resource);
            const fileStat = yield this.fsDriver().stat(newBlobFilePath);
            yield this.fsDriver().copy(newBlobFilePath, Resource.fullPath(resource));
            return yield Resource.save({
                id: resource.id,
                size: fileStat.size,
            });
        });
    }
    static resourceBlobContent(resourceId, encoding = 'Buffer') {
        return __awaiter(this, void 0, void 0, function* () {
            const resource = yield Resource.load(resourceId);
            yield this.requireIsReady(resource);
            return yield this.fsDriver().readFile(Resource.fullPath(resource), encoding);
        });
    }
    static duplicateResource(resourceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const resource = yield Resource.load(resourceId);
            const localState = yield Resource.localState(resource);
            let newResource = Object.assign({}, resource);
            delete newResource.id;
            newResource = yield Resource.save(newResource);
            const newLocalState = Object.assign({}, localState);
            newLocalState.resource_id = newResource.id;
            delete newLocalState.id;
            yield Resource.setLocalState(newResource, newLocalState);
            const sourcePath = Resource.fullPath(resource);
            if (yield this.fsDriver().exists(sourcePath)) {
                yield this.fsDriver().copy(sourcePath, Resource.fullPath(newResource));
            }
            return newResource;
        });
    }
    static resourceConflictFolderId() {
        return __awaiter(this, void 0, void 0, function* () {
            const folder = yield this.resourceConflictFolder();
            return folder.id;
        });
    }
    static resourceConflictFolder() {
        return __awaiter(this, void 0, void 0, function* () {
            const conflictFolderTitle = (0, locale_1._)('Conflicts (attachments)');
            const Folder = this.getClass('Folder');
            const folder = yield Folder.loadByTitle(conflictFolderTitle);
            if (!folder || folder.parent_id) {
                return Folder.save({ title: conflictFolderTitle });
            }
            return folder;
        });
    }
    static createConflictResourceNote(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const Note = this.getClass('Note');
            const conflictResource = yield Resource.duplicateResource(resource.id);
            yield Note.save({
                title: (0, locale_1._)('Attachment conflict: "%s"', resource.title),
                body: (0, locale_1._)('There was a [conflict](%s) on the attachment below.\n\n%s', 'https://joplinapp.org/conflict/', Resource.markdownTag(conflictResource)),
                parent_id: yield this.resourceConflictFolderId(),
            }, { changeSource: ItemChange_1.default.SOURCE_SYNC });
        });
    }
}
exports.default = Resource;
Resource.IMAGE_MAX_DIMENSION = 1920;
Resource.FETCH_STATUS_IDLE = 0;
Resource.FETCH_STATUS_STARTED = 1;
Resource.FETCH_STATUS_DONE = 2;
Resource.FETCH_STATUS_ERROR = 3;
Resource.shareService_ = null;
//# sourceMappingURL=Resource.js.map