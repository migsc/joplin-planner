"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Setting_1 = require("../models/Setting");
const test_utils_1 = require("../testing/test-utils");
const fs_extra_1 = require("fs-extra");
const Logger_1 = require("../Logger");
const types_1 = require("../services/profileConfig/types");
const profileConfig_1 = require("../services/profileConfig");
const initProfile_1 = require("../services/profileConfig/initProfile");
function loadSettingsFromFile() {
    return __awaiter(this, void 0, void 0, function* () {
        return JSON.parse(yield (0, fs_extra_1.readFile)(Setting_1.default.settingFilePath, 'utf8'));
    });
}
const switchToSubProfileSettings = () => __awaiter(void 0, void 0, void 0, function* () {
    yield Setting_1.default.reset();
    const rootProfileDir = Setting_1.default.value('profileDir');
    const profileConfigPath = `${rootProfileDir}/profiles.json`;
    let profileConfig = (0, types_1.defaultProfileConfig)();
    const { newConfig, newProfile } = (0, profileConfig_1.createNewProfile)(profileConfig, 'Sub-profile');
    profileConfig = newConfig;
    profileConfig.currentProfileId = newProfile.id;
    yield (0, profileConfig_1.saveProfileConfig)(profileConfigPath, profileConfig);
    const { profileDir } = yield (0, initProfile_1.default)(rootProfileDir);
    yield (0, fs_extra_1.mkdirp)(profileDir);
    yield Setting_1.default.load();
});
describe('models/Setting', function () {
    beforeEach((done) => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.switchClient)(1);
        done();
    }));
    it('should return only sub-values', (() => __awaiter(this, void 0, void 0, function* () {
        const settings = {
            'sync.5.path': 'http://example.com',
            'sync.5.username': 'testing',
        };
        let output = Setting_1.default.subValues('sync.5', settings);
        expect(output['path']).toBe('http://example.com');
        expect(output['username']).toBe('testing');
        output = Setting_1.default.subValues('sync.4', settings);
        expect('path' in output).toBe(false);
        expect('username' in output).toBe(false);
    })));
    it('should not fail when trying to load a key that no longer exist from the setting file', (() => __awaiter(this, void 0, void 0, function* () {
        // To handle the case where a setting value exists in the database but
        // the metadata has been removed in a new Joplin version.
        // https://github.com/laurent22/joplin/issues/5086
        Setting_1.default.setValue('sync.target', 9); // Saved to file
        yield Setting_1.default.saveAll();
        const settingValues = yield Setting_1.default.fileHandler.load();
        settingValues['itsgone'] = 'myvalue';
        yield Setting_1.default.fileHandler.save(settingValues);
        yield Setting_1.default.reset();
        yield (0, test_utils_1.expectNotThrow)(() => __awaiter(this, void 0, void 0, function* () { return Setting_1.default.load(); }));
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return Setting_1.default.value('itsgone'); }));
    })));
    it('should allow registering new settings dynamically', (() => __awaiter(this, void 0, void 0, function* () {
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return Setting_1.default.setValue('myCustom', '123'); }));
        yield Setting_1.default.registerSetting('myCustom', {
            public: true,
            value: 'default',
            type: Setting_1.default.TYPE_STRING,
        });
        yield (0, test_utils_1.expectNotThrow)(() => __awaiter(this, void 0, void 0, function* () { return Setting_1.default.setValue('myCustom', '123'); }));
        expect(Setting_1.default.value('myCustom')).toBe('123');
    })));
    it('should not clear old custom settings', (() => __awaiter(this, void 0, void 0, function* () {
        // In general the following should work:
        //
        // - Plugin register a new setting
        // - User set new value for setting
        // - Settings are saved
        // - => App restart
        // - Plugin does not register setting again
        // - Settings are loaded
        // - Settings are saved
        // - Plugin register setting again
        // - Previous value set by user should still be there.
        //
        // In other words, once a custom setting has been set we don't clear it
        // even if registration doesn't happen immediately. That allows for example
        // to delay setting registration without a risk for the custom setting to be deleted.
        yield Setting_1.default.registerSetting('myCustom', {
            public: true,
            value: 'default',
            type: Setting_1.default.TYPE_STRING,
        });
        Setting_1.default.setValue('myCustom', '123');
        yield Setting_1.default.saveAll();
        yield Setting_1.default.reset();
        yield Setting_1.default.load();
        yield Setting_1.default.registerSetting('myCustom', {
            public: true,
            value: 'default',
            type: Setting_1.default.TYPE_STRING,
        });
        yield Setting_1.default.saveAll();
        expect(Setting_1.default.value('myCustom')).toBe('123');
    })));
    it('should return values with correct type for custom settings', (() => __awaiter(this, void 0, void 0, function* () {
        yield Setting_1.default.registerSetting('myCustom', {
            public: true,
            value: 123,
            type: Setting_1.default.TYPE_INT,
        });
        Setting_1.default.setValue('myCustom', 456);
        yield Setting_1.default.saveAll();
        yield Setting_1.default.reset();
        yield Setting_1.default.load();
        yield Setting_1.default.registerSetting('myCustom', {
            public: true,
            value: 123,
            type: Setting_1.default.TYPE_INT,
        });
        expect(typeof Setting_1.default.value('myCustom')).toBe('number');
        expect(Setting_1.default.value('myCustom')).toBe(456);
    })));
    it('should validate registered keys', (() => __awaiter(this, void 0, void 0, function* () {
        const md = {
            public: true,
            value: 'default',
            type: Setting_1.default.TYPE_STRING,
        };
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield Setting_1.default.registerSetting('', md); }));
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield Setting_1.default.registerSetting('no spaces', md); }));
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield Setting_1.default.registerSetting('nospecialcharacters!!!', md); }));
        yield (0, test_utils_1.expectThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield Setting_1.default.registerSetting('Robert\'); DROP TABLE Students;--', md); }));
        yield (0, test_utils_1.expectNotThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield Setting_1.default.registerSetting('numbersareok123', md); }));
        yield (0, test_utils_1.expectNotThrow)(() => __awaiter(this, void 0, void 0, function* () { return yield Setting_1.default.registerSetting('so-ARE-dashes_123', md); }));
    })));
    it('should register new sections', (() => __awaiter(this, void 0, void 0, function* () {
        yield Setting_1.default.registerSection('mySection', Setting_1.SettingSectionSource.Default, {
            label: 'My section',
        });
        expect(Setting_1.default.sectionNameToLabel('mySection')).toBe('My section');
    })));
    it('should save and load settings from file', (() => __awaiter(this, void 0, void 0, function* () {
        Setting_1.default.setValue('sync.target', 9); // Saved to file
        Setting_1.default.setValue('encryption.passwordCache', {}); // Saved to keychain or db
        Setting_1.default.setValue('plugins.states', { test: true }); // Always saved to db
        yield Setting_1.default.saveAll();
        {
            const settings = yield loadSettingsFromFile();
            expect(settings['sync.target']).toBe(9);
            expect(settings).not.toContain('encryption.passwordCache');
            expect(settings).not.toContain('plugins.states');
        }
        Setting_1.default.setValue('sync.target', 8);
        yield Setting_1.default.saveAll();
        {
            const settings = yield loadSettingsFromFile();
            expect(settings['sync.target']).toBe(8);
        }
    })));
    it('should not save to file if nothing has changed', (() => __awaiter(this, void 0, void 0, function* () {
        Setting_1.default.setValue('sync.mobileWifiOnly', true);
        yield Setting_1.default.saveAll();
        {
            // Double-check that timestamp is indeed changed when the content is
            // changed.
            const beforeStat = yield (0, fs_extra_1.stat)(Setting_1.default.settingFilePath);
            yield (0, test_utils_1.msleep)(1001);
            Setting_1.default.setValue('sync.mobileWifiOnly', false);
            yield Setting_1.default.saveAll();
            const afterStat = yield (0, fs_extra_1.stat)(Setting_1.default.settingFilePath);
            expect(afterStat.mtime.getTime()).toBeGreaterThan(beforeStat.mtime.getTime());
        }
        {
            const beforeStat = yield (0, fs_extra_1.stat)(Setting_1.default.settingFilePath);
            yield (0, test_utils_1.msleep)(1001);
            Setting_1.default.setValue('sync.mobileWifiOnly', false);
            const afterStat = yield (0, fs_extra_1.stat)(Setting_1.default.settingFilePath);
            yield Setting_1.default.saveAll();
            expect(afterStat.mtime.getTime()).toBe(beforeStat.mtime.getTime());
        }
    })));
    it('should handle invalid JSON', (() => __awaiter(this, void 0, void 0, function* () {
        const badContent = '{ oopsIforgotTheQuotes: true}';
        yield (0, fs_extra_1.writeFile)(Setting_1.default.settingFilePath, badContent, 'utf8');
        yield Setting_1.default.reset();
        Logger_1.default.globalLogger.enabled = false;
        yield Setting_1.default.load();
        Logger_1.default.globalLogger.enabled = true;
        // Invalid JSON file has been moved to .bak file
        expect(yield (0, fs_extra_1.pathExists)(Setting_1.default.settingFilePath)).toBe(false);
        const files = yield (0, fs_extra_1.readdir)(Setting_1.default.value('profileDir'));
        expect(files.length).toBe(1);
        expect(files[0].endsWith('.bak')).toBe(true);
        expect(yield (0, fs_extra_1.readFile)(`${Setting_1.default.value('profileDir')}/${files[0]}`, 'utf8')).toBe(badContent);
    })));
    it('should allow applying default migrations', (() => __awaiter(this, void 0, void 0, function* () {
        yield Setting_1.default.reset();
        expect(Setting_1.default.value('sync.target')).toBe(0);
        expect(Setting_1.default.value('style.editor.contentMaxWidth')).toBe(0);
        Setting_1.default.applyDefaultMigrations();
        expect(Setting_1.default.value('sync.target')).toBe(7); // Changed
        expect(Setting_1.default.value('style.editor.contentMaxWidth')).toBe(600); // Changed
    })));
    it('should skip values that are already set', (() => __awaiter(this, void 0, void 0, function* () {
        yield Setting_1.default.reset();
        Setting_1.default.setValue('sync.target', 9);
        Setting_1.default.applyDefaultMigrations();
        expect(Setting_1.default.value('sync.target')).toBe(9); // Not changed
    })));
    it('should allow skipping default migrations', (() => __awaiter(this, void 0, void 0, function* () {
        yield Setting_1.default.reset();
        expect(Setting_1.default.value('sync.target')).toBe(0);
        expect(Setting_1.default.value('style.editor.contentMaxWidth')).toBe(0);
        Setting_1.default.skipDefaultMigrations();
        Setting_1.default.applyDefaultMigrations();
        expect(Setting_1.default.value('sync.target')).toBe(0); // Not changed
        expect(Setting_1.default.value('style.editor.contentMaxWidth')).toBe(0); // Not changed
    })));
    it('should not apply migrations that have already been applied', (() => __awaiter(this, void 0, void 0, function* () {
        yield Setting_1.default.reset();
        Setting_1.default.setValue('lastSettingDefaultMigration', 0);
        expect(Setting_1.default.value('sync.target')).toBe(0);
        expect(Setting_1.default.value('style.editor.contentMaxWidth')).toBe(0);
        Setting_1.default.applyDefaultMigrations();
        expect(Setting_1.default.value('sync.target')).toBe(0); // Not changed
        expect(Setting_1.default.value('style.editor.contentMaxWidth')).toBe(600); // Changed
    })));
    it('should migrate to new setting', (() => __awaiter(this, void 0, void 0, function* () {
        yield Setting_1.default.reset();
        Setting_1.default.setValue('spellChecker.language', 'fr-FR');
        Setting_1.default.applyUserSettingMigration();
        expect(Setting_1.default.value('spellChecker.languages')).toStrictEqual(['fr-FR']);
    })));
    it('should not override new setting, if it already set', (() => __awaiter(this, void 0, void 0, function* () {
        yield Setting_1.default.reset();
        Setting_1.default.setValue('spellChecker.languages', ['fr-FR', 'en-US']);
        Setting_1.default.setValue('spellChecker.language', 'fr-FR');
        Setting_1.default.applyUserSettingMigration();
        expect(Setting_1.default.value('spellChecker.languages')).toStrictEqual(['fr-FR', 'en-US']);
    })));
    it('should not set new setting, if old setting is not set', (() => __awaiter(this, void 0, void 0, function* () {
        yield Setting_1.default.reset();
        expect(Setting_1.default.isSet('spellChecker.language')).toBe(false);
        Setting_1.default.applyUserSettingMigration();
        expect(Setting_1.default.isSet('spellChecker.languages')).toBe(false);
    })));
    it('should load sub-profile settings - 1', () => __awaiter(this, void 0, void 0, function* () {
        yield Setting_1.default.reset();
        Setting_1.default.setValue('locale', 'fr_FR'); // Global setting
        Setting_1.default.setValue('theme', Setting_1.default.THEME_DARK); // Global setting
        Setting_1.default.setValue('sync.target', 9); // Local setting
        yield Setting_1.default.saveAll();
        yield switchToSubProfileSettings();
        expect(Setting_1.default.value('locale')).toBe('fr_FR'); // Should come from the root profile
        expect(Setting_1.default.value('theme')).toBe(Setting_1.default.THEME_DARK); // Should come from the root profile
        expect(Setting_1.default.value('sync.target')).toBe(0); // Should come from the local profile
        // Also check that the special loadOne() function works as expected
        expect((yield Setting_1.default.loadOne('locale')).value).toBe('fr_FR');
        expect((yield Setting_1.default.loadOne('theme')).value).toBe(Setting_1.default.THEME_DARK);
        expect((yield Setting_1.default.loadOne('sync.target')).value).toBe(undefined);
    }));
    it('should save sub-profile settings - 2', () => __awaiter(this, void 0, void 0, function* () {
        yield Setting_1.default.reset();
        Setting_1.default.setValue('locale', 'fr_FR'); // Global setting
        Setting_1.default.setValue('theme', Setting_1.default.THEME_DARK); // Global setting
        yield Setting_1.default.saveAll();
        yield switchToSubProfileSettings();
        Setting_1.default.setValue('locale', 'en_GB'); // Should be saved to global
        Setting_1.default.setValue('sync.target', 8); // Should be saved to local
        yield Setting_1.default.saveAll();
        yield Setting_1.default.reset();
        yield Setting_1.default.load();
        expect(Setting_1.default.value('locale')).toBe('en_GB');
        expect(Setting_1.default.value('theme')).toBe(Setting_1.default.THEME_DARK);
        expect(Setting_1.default.value('sync.target')).toBe(8);
        // Double-check that actual file content is correct
        const globalSettings = JSON.parse(yield (0, fs_extra_1.readFile)(`${Setting_1.default.value('rootProfileDir')}/settings-1.json`, 'utf8'));
        const localSettings = JSON.parse(yield (0, fs_extra_1.readFile)(`${Setting_1.default.value('profileDir')}/settings-1.json`, 'utf8'));
        expect(globalSettings).toEqual({
            '$schema': 'https://joplinapp.org/schema/settings.json',
            locale: 'en_GB',
            theme: 2,
        });
        expect(localSettings).toEqual({
            '$schema': 'https://joplinapp.org/schema/settings.json',
            'sync.target': 8,
        });
    }));
    it('should not erase settings of parent profile', () => __awaiter(this, void 0, void 0, function* () {
        // When a sub-profile settings are saved, we should ensure that the
        // local settings of the root profiles are not lost.
        // https://github.com/laurent22/joplin/issues/6459
        yield Setting_1.default.reset();
        Setting_1.default.setValue('sync.target', 9); // Local setting (Root profile)
        yield Setting_1.default.saveAll();
        yield switchToSubProfileSettings();
        Setting_1.default.setValue('sync.target', 2); // Local setting (Sub-profile)
        yield Setting_1.default.saveAll();
        const globalSettings = JSON.parse(yield (0, fs_extra_1.readFile)(`${Setting_1.default.value('rootProfileDir')}/settings-1.json`, 'utf8'));
        expect(globalSettings['sync.target']).toBe(9);
    }));
    it('all global settings should be saved to file', () => __awaiter(this, void 0, void 0, function* () {
        for (const [k, v] of Object.entries(Setting_1.default.metadata())) {
            if (v.isGlobal && v.storage !== Setting_1.SettingStorage.File)
                throw new Error(`Setting "${k}" is global but storage is not "file"`);
        }
    }));
});
//# sourceMappingURL=Setting.test.js.map