"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseModel_1 = require("../BaseModel");
const syncInfoUtils_1 = require("../services/synchronizer/syncInfoUtils");
const BaseItem_1 = require("./BaseItem");
const uuid_1 = require("../uuid");
class MasterKey extends BaseItem_1.default {
    static tableName() {
        return 'master_keys';
    }
    static modelType() {
        return BaseModel_1.default.TYPE_MASTER_KEY;
    }
    static encryptionSupported() {
        return false;
    }
    static latest() {
        let output = null;
        const syncInfo = (0, syncInfoUtils_1.localSyncInfo)();
        for (const mk of syncInfo.masterKeys) {
            if (!output || output.updated_time < mk.updated_time) {
                output = mk;
            }
        }
        return output;
    }
    static allWithoutEncryptionMethod(masterKeys, methods) {
        return masterKeys.filter(m => !methods.includes(m.encryption_method));
    }
    static all() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, syncInfoUtils_1.localSyncInfo)().masterKeys;
        });
    }
    static allIds() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, syncInfoUtils_1.localSyncInfo)().masterKeys.map(k => k.id);
        });
    }
    static count() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, syncInfoUtils_1.localSyncInfo)().masterKeys.length;
        });
    }
    static load(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, syncInfoUtils_1.localSyncInfo)().masterKeys.find(mk => mk.id === id);
        });
    }
    static save(o) {
        return __awaiter(this, void 0, void 0, function* () {
            const syncInfo = (0, syncInfoUtils_1.localSyncInfo)();
            const masterKey = Object.assign({}, o);
            if (!masterKey.id) {
                masterKey.id = uuid_1.default.create();
                masterKey.created_time = Date.now();
            }
            masterKey.updated_time = Date.now();
            const idx = syncInfo.masterKeys.findIndex(mk => mk.id === masterKey.id);
            if (idx >= 0) {
                syncInfo.masterKeys[idx] = masterKey;
            }
            else {
                syncInfo.masterKeys.push(masterKey);
            }
            (0, syncInfoUtils_1.saveLocalSyncInfo)(syncInfo);
            this.dispatch({
                type: 'MASTERKEY_UPDATE_ONE',
                item: masterKey,
            });
            return masterKey;
            // return super.save(o, options).then(item => {
            // 	this.dispatch({
            // 		type: 'MASTERKEY_UPDATE_ONE',
            // 		item: item,
            // 	});
            // 	return item;
            // });
        });
    }
}
exports.default = MasterKey;
//# sourceMappingURL=MasterKey.js.map