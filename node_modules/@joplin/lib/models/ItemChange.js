"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseModel_1 = require("../BaseModel");
const shim_1 = require("../shim");
const eventManager_1 = require("../eventManager");
const Mutex = require('async-mutex').Mutex;
class ItemChange extends BaseModel_1.default {
    static tableName() {
        return 'item_changes';
    }
    static modelType() {
        return BaseModel_1.default.TYPE_ITEM_CHANGE;
    }
    static add(itemType, itemId, type, changeSource = null, beforeChangeItemJson = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (changeSource === null)
                changeSource = ItemChange.SOURCE_UNSPECIFIED;
            if (!beforeChangeItemJson)
                beforeChangeItemJson = '';
            ItemChange.saveCalls_.push(true);
            // Using a mutex so that records can be added to the database in the
            // background, without making the UI wait.
            const release = yield ItemChange.addChangeMutex_.acquire();
            try {
                yield this.db().transactionExecBatch([
                    {
                        sql: 'DELETE FROM item_changes WHERE item_id = ?',
                        params: [itemId],
                    },
                    {
                        sql: 'INSERT INTO item_changes (item_type, item_id, type, source, created_time, before_change_item) VALUES (?, ?, ?, ?, ?, ?)',
                        params: [itemType, itemId, type, changeSource, Date.now(), beforeChangeItemJson],
                    },
                ]);
            }
            finally {
                release();
                ItemChange.saveCalls_.pop();
                eventManager_1.default.emit('itemChange', {
                    itemType: itemType,
                    itemId: itemId,
                    eventType: type,
                });
            }
        });
    }
    static lastChangeId() {
        return __awaiter(this, void 0, void 0, function* () {
            const row = yield this.db().selectOne('SELECT max(id) as max_id FROM item_changes');
            return row && row.max_id ? row.max_id : 0;
        });
    }
    // Because item changes are recorded in the background, this function
    // can be used for synchronous code, in particular when unit testing.
    static waitForAllSaved() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                const iid = shim_1.default.setInterval(() => {
                    if (!ItemChange.saveCalls_.length) {
                        shim_1.default.clearInterval(iid);
                        resolve(null);
                    }
                }, 100);
            });
        });
    }
    static deleteOldChanges(lowestChangeId, itemMinTtl) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!lowestChangeId)
                return;
            const cutOffDate = Date.now() - itemMinTtl;
            return this.db().exec(`
			DELETE FROM item_changes
			WHERE id <= ?
			AND created_time <= ?
		`, [lowestChangeId, cutOffDate]);
        });
    }
    static changesSinceId(changeId, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            options = Object.assign({ limit: 100, fields: ['id', 'item_type', 'item_id', 'type', 'created_time'] }, options);
            return this.db().selectAll(`
			SELECT ${this.db().escapeFieldsToString(options.fields)}
			FROM item_changes
			WHERE id > ?
			ORDER BY id
			LIMIT ?
		`, [changeId, options.limit]);
        });
    }
}
exports.default = ItemChange;
ItemChange.addChangeMutex_ = new Mutex();
ItemChange.saveCalls_ = [];
ItemChange.TYPE_CREATE = 1;
ItemChange.TYPE_UPDATE = 2;
ItemChange.TYPE_DELETE = 3;
ItemChange.SOURCE_UNSPECIFIED = 1;
ItemChange.SOURCE_SYNC = 2;
ItemChange.SOURCE_DECRYPTION = 2; // CAREFUL - SAME ID AS SOURCE_SYNC!
//# sourceMappingURL=ItemChange.js.map