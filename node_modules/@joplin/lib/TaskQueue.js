"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const time_1 = require("./time");
const Setting_1 = require("./models/Setting");
const Logger_1 = require("./Logger");
class TaskQueue {
    constructor(name, logger = null) {
        this.waitingTasks_ = [];
        this.processingTasks_ = {};
        this.processingQueue_ = false;
        this.stopping_ = false;
        this.results_ = {};
        this.name_ = name;
        this.logger_ = logger ? logger : new Logger_1.default();
    }
    concurrency() {
        return Setting_1.default.value('sync.maxConcurrentConnections');
    }
    push(id, callback) {
        if (this.stopping_)
            throw new Error('Cannot push task when queue is stopping');
        this.waitingTasks_.push({
            id: id,
            callback: callback,
        });
        this.processQueue_();
    }
    processQueue_() {
        if (this.processingQueue_ || this.stopping_)
            return;
        this.processingQueue_ = true;
        const completeTask = (task, result, error) => {
            delete this.processingTasks_[task.id];
            const r = {
                id: task.id,
                result: result,
            };
            if (error)
                r.error = error;
            this.results_[task.id] = r;
            this.processQueue_();
        };
        while (this.waitingTasks_.length > 0 && Object.keys(this.processingTasks_).length < this.concurrency()) {
            if (this.stopping_)
                break;
            const task = this.waitingTasks_.splice(0, 1)[0];
            this.processingTasks_[task.id] = task;
            task
                .callback()
                // eslint-disable-next-line promise/prefer-await-to-then -- Old code before rule was applied
                .then((result) => {
                completeTask(task, result, null);
            })
                // eslint-disable-next-line promise/prefer-await-to-then -- Old code before rule was applied
                .catch((error) => {
                if (!error)
                    error = new Error('Unknown error');
                completeTask(task, null, error);
            });
        }
        this.processingQueue_ = false;
    }
    isWaiting(taskId) {
        return this.waitingTasks_.find(task => task.id === taskId);
    }
    isProcessing(taskId) {
        return taskId in this.processingTasks_;
    }
    isDone(taskId) {
        return taskId in this.results_;
    }
    waitForAll() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                const checkIID = setInterval(() => {
                    if (this.waitingTasks_.length)
                        return;
                    if (this.processingTasks_.length)
                        return;
                    clearInterval(checkIID);
                    resolve(null);
                }, 100);
            });
        });
    }
    taskExists(taskId) {
        return this.isWaiting(taskId) || this.isProcessing(taskId) || this.isDone(taskId);
    }
    taskResult(taskId) {
        if (!this.taskExists(taskId))
            throw new Error(`No such task: ${taskId}`);
        return this.results_[taskId];
    }
    waitForResult(taskId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.taskExists(taskId))
                throw new Error(`No such task: ${taskId}`);
            while (true) {
                const task = this.results_[taskId];
                if (task)
                    return task;
                yield time_1.default.sleep(0.1);
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stopping_ = true;
            this.logger_.info(`TaskQueue.stop: ${this.name_}: waiting for tasks to complete: ${Object.keys(this.processingTasks_).length}`);
            // In general it's not a big issue if some tasks are still running because
            // it won't call anything unexpected in caller code, since the caller has
            // to explicitely retrieve the results
            const startTime = Date.now();
            while (Object.keys(this.processingTasks_).length) {
                yield time_1.default.sleep(0.1);
                if (Date.now() - startTime >= 30000) {
                    this.logger_.warn(`TaskQueue.stop: ${this.name_}: timed out waiting for task to complete`);
                    break;
                }
            }
            this.logger_.info(`TaskQueue.stop: ${this.name_}: Done, waited for ${Date.now() - startTime}`);
        });
    }
    isStopping() {
        return this.stopping_;
    }
}
exports.default = TaskQueue;
//# sourceMappingURL=TaskQueue.js.map