"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_driver_base_1 = require("./fs-driver-base");
const time_1 = require("./time");
const md5File = require('md5-file/promise');
const fs = require('fs-extra');
class FsDriverNode extends fs_driver_base_1.default {
    fsErrorToJsError_(error, path = null) {
        let msg = error.toString();
        if (path !== null)
            msg += `. Path: ${path}`;
        const output = new Error(msg);
        if (error.code)
            output.code = error.code;
        return output;
    }
    appendFileSync(path, string) {
        return fs.appendFileSync(path, string);
    }
    appendFile(path, string, encoding = 'base64') {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield fs.appendFile(path, string, { encoding: encoding });
            }
            catch (error) {
                throw this.fsErrorToJsError_(error, path);
            }
        });
    }
    writeFile(path, string, encoding = 'base64') {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (encoding === 'buffer') {
                    return yield fs.writeFile(path, string);
                }
                else {
                    return yield fs.writeFile(path, string, { encoding: encoding });
                }
            }
            catch (error) {
                throw this.fsErrorToJsError_(error, path);
            }
        });
    }
    // same as rm -rf
    remove(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const r = yield fs.remove(path);
                return r;
            }
            catch (error) {
                throw this.fsErrorToJsError_(error, path);
            }
        });
    }
    move(source, dest) {
        return __awaiter(this, void 0, void 0, function* () {
            let lastError = null;
            for (let i = 0; i < 5; i++) {
                try {
                    const output = yield fs.move(source, dest, { overwrite: true });
                    return output;
                }
                catch (error) {
                    lastError = error;
                    // Normally cannot happen with the `overwrite` flag but sometime it still does.
                    // In this case, retry.
                    if (error.code === 'EEXIST') {
                        yield time_1.default.sleep(1);
                        continue;
                    }
                    throw this.fsErrorToJsError_(error);
                }
            }
            throw lastError;
        });
    }
    exists(path) {
        return fs.pathExists(path);
    }
    mkdir(path) {
        return __awaiter(this, void 0, void 0, function* () {
            // Note that mkdirp() does not throw an error if the directory
            // could not be created. This would make the synchroniser to
            // incorrectly try to sync with a non-existing dir:
            // https://github.com/laurent22/joplin/issues/2117
            const r = yield fs.mkdirp(path);
            if (!(yield this.exists(path)))
                throw new Error(`Could not create directory: ${path}`);
            return r;
        });
    }
    stat(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const stat = yield fs.stat(path);
                return {
                    birthtime: stat.birthtime,
                    mtime: stat.mtime,
                    isDirectory: () => stat.isDirectory(),
                    path: path,
                    size: stat.size,
                };
            }
            catch (error) {
                if (error.code === 'ENOENT')
                    return null;
                throw error;
            }
        });
    }
    setTimestamp(path, timestampDate) {
        return __awaiter(this, void 0, void 0, function* () {
            return fs.utimes(path, timestampDate, timestampDate);
        });
    }
    readDirStats(path, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options)
                options = {};
            if (!('recursive' in options))
                options.recursive = false;
            let items = [];
            try {
                items = yield fs.readdir(path);
            }
            catch (error) {
                throw this.fsErrorToJsError_(error);
            }
            let output = [];
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const stat = yield this.stat(`${path}/${item}`);
                if (!stat)
                    continue; // Has been deleted between the readdir() call and now
                stat.path = stat.path.substr(path.length + 1);
                output.push(stat);
                output = yield this.readDirStatsHandleRecursion_(path, stat, output, options);
            }
            return output;
        });
    }
    open(path, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield fs.open(path, mode);
            }
            catch (error) {
                throw this.fsErrorToJsError_(error, path);
            }
        });
    }
    close(handle) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield fs.close(handle);
            }
            catch (error) {
                throw this.fsErrorToJsError_(error, '');
            }
        });
    }
    readFile(path, encoding = 'utf8') {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (encoding === 'Buffer')
                    return yield fs.readFile(path); // Returns the raw buffer
                return yield fs.readFile(path, encoding);
            }
            catch (error) {
                throw this.fsErrorToJsError_(error, path);
            }
        });
    }
    // Always overwrite destination
    copy(source, dest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield fs.copy(source, dest, { overwrite: true });
            }
            catch (error) {
                throw this.fsErrorToJsError_(error, source);
            }
        });
    }
    unlink(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield fs.unlink(path);
            }
            catch (error) {
                if (error.code === 'ENOENT')
                    return; // Don't throw if the file does not exist
                throw error;
            }
        });
    }
    readFileChunk(handle, length, encoding = 'base64') {
        return __awaiter(this, void 0, void 0, function* () {
            // let buffer = new Buffer(length);
            let buffer = Buffer.alloc(length);
            const result = yield fs.read(handle, buffer, 0, length, null);
            if (!result.bytesRead)
                return null;
            buffer = buffer.slice(0, result.bytesRead);
            if (encoding === 'base64')
                return buffer.toString('base64');
            if (encoding === 'ascii')
                return buffer.toString('ascii');
            throw new Error(`Unsupported encoding: ${encoding}`);
        });
    }
    resolve(path) {
        return require('path').resolve(path);
    }
    // Resolves the provided relative path to an absolute path within baseDir. The function
    // also checks that the absolute path is within baseDir, to avoid security issues.
    // It is expected that baseDir is a safe path (not user-provided).
    resolveRelativePathWithinDir(baseDir, relativePath) {
        const resolvedBaseDir = (0, path_1.resolve)(baseDir);
        const resolvedPath = (0, path_1.resolve)(baseDir, relativePath);
        if (resolvedPath.indexOf(resolvedBaseDir) !== 0)
            throw new Error(`Resolved path for relative path "${relativePath}" is not within base directory "${baseDir}" (Was resolved to ${resolvedPath})`);
        return resolvedPath;
    }
    md5File(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return md5File(path);
        });
    }
    tarExtract(options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield require('tar').extract(options);
        });
    }
    tarCreate(options, filePaths) {
        return __awaiter(this, void 0, void 0, function* () {
            yield require('tar').create(options, filePaths);
        });
    }
}
exports.default = FsDriverNode;
//# sourceMappingURL=fs-driver-node.js.map