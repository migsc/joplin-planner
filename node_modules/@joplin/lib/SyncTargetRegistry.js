"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class SyncTargetRegistry {
    static get reg() {
        return this.reg_;
    }
    static classById(syncTargetId) {
        const info = SyncTargetRegistry.reg[syncTargetId];
        if (!info)
            throw new Error(`Invalid id: ${syncTargetId}`);
        return info.classRef;
    }
    static infoByName(name) {
        for (const [, info] of Object.entries(this.reg)) {
            if (info.name === name)
                return info;
        }
        throw new Error(`Unknown name: ${name}`);
    }
    static infoById(id) {
        return this.infoByName(this.idToName(id));
    }
    static addClass(SyncTargetClass) {
        this.reg[SyncTargetClass.id()] = {
            id: SyncTargetClass.id(),
            name: SyncTargetClass.targetName(),
            label: SyncTargetClass.label(),
            classRef: SyncTargetClass,
            description: SyncTargetClass.description(),
            supportsSelfHosted: SyncTargetClass.supportsSelfHosted(),
            supportsConfigCheck: SyncTargetClass.supportsConfigCheck(),
            supportsRecursiveLinkedNotes: SyncTargetClass.supportsRecursiveLinkedNotes(),
        };
    }
    static allIds() {
        return Object.keys(this.reg);
    }
    static nameToId(name) {
        for (const n in this.reg) {
            if (!this.reg.hasOwnProperty(n))
                continue;
            if (this.reg[n].name === name)
                return this.reg[n].id;
        }
        throw new Error(`Name not found: ${name}. Was the sync target registered?`);
    }
    static idToMetadata(id) {
        for (const n in this.reg) {
            if (!this.reg.hasOwnProperty(n))
                continue;
            if (this.reg[n].id === id)
                return this.reg[n];
        }
        throw new Error(`ID not found: ${id}`);
    }
    static idToName(id) {
        return this.idToMetadata(id).name;
    }
    static idAndLabelPlainObject(os) {
        const output = {};
        for (const n in this.reg) {
            if (!this.reg.hasOwnProperty(n))
                continue;
            const info = this.reg[n];
            if (info.classRef.unsupportedPlatforms().indexOf(os) >= 0) {
                continue;
            }
            output[n] = info.label;
        }
        return output;
    }
    static optionsOrder() {
        return [
            '0',
            '10',
            '7',
            '3', // OneDrive
        ];
    }
}
exports.default = SyncTargetRegistry;
SyncTargetRegistry.reg_ = {};
//# sourceMappingURL=SyncTargetRegistry.js.map