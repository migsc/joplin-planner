"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Setting_1 = require("./models/Setting");
const Logger_1 = require("./Logger");
const shim_1 = require("./shim");
const { setupProxySettings } = require('./shim-init-node');
const BaseService_1 = require("./services/BaseService");
const reducer_1 = require("./reducer");
const KeychainServiceDriver_node_1 = require("./services/keychain/KeychainServiceDriver.node");
const KeychainServiceDriver_dummy_1 = require("./services/keychain/KeychainServiceDriver.dummy");
const locale_1 = require("./locale");
const KvStore_1 = require("./services/KvStore");
const SyncTargetJoplinServer_1 = require("./SyncTargetJoplinServer");
const SyncTargetOneDrive_1 = require("./SyncTargetOneDrive");
const redux_1 = require("redux");
const { defaultState, stateUtils } = require('./reducer');
const JoplinDatabase_1 = require("./JoplinDatabase");
const { FoldersScreenUtils } = require('./folders-screen-utils.js');
const { DatabaseDriverNode } = require('./database-driver-node.js');
const BaseModel_1 = require("./BaseModel");
const Folder_1 = require("./models/Folder");
const BaseItem_1 = require("./models/BaseItem");
const Note_1 = require("./models/Note");
const Tag_1 = require("./models/Tag");
const { splitCommandString } = require('./string-utils.js');
const registry_1 = require("./registry");
const time_1 = require("./time");
const BaseSyncTarget_1 = require("./BaseSyncTarget");
const reduxSharedMiddleware = require('./components/shared/reduxSharedMiddleware');
const os = require('os');
const fs = require('fs-extra');
const JoplinError_1 = require("./JoplinError");
const EventEmitter = require('events');
const syswidecas = require('./vendor/syswide-cas');
const SyncTargetRegistry_1 = require("./SyncTargetRegistry");
const SyncTargetFilesystem = require('./SyncTargetFilesystem.js');
const SyncTargetNextcloud = require('./SyncTargetNextcloud.js');
const SyncTargetWebDAV = require('./SyncTargetWebDAV.js');
const SyncTargetDropbox = require('./SyncTargetDropbox.js');
const SyncTargetAmazonS3 = require('./SyncTargetAmazonS3.js');
const EncryptionService_1 = require("./services/e2ee/EncryptionService");
const ResourceFetcher_1 = require("./services/ResourceFetcher");
const SearchEngineUtils_1 = require("./services/searchengine/SearchEngineUtils");
const SearchEngine_1 = require("./services/searchengine/SearchEngine");
const RevisionService_1 = require("./services/RevisionService");
const ResourceService_1 = require("./services/ResourceService");
const DecryptionWorker_1 = require("./services/DecryptionWorker");
const SettingUtils_1 = require("./services/SettingUtils");
const MigrationService_1 = require("./services/MigrationService");
const ShareService_1 = require("./services/share/ShareService");
const handleSyncStartupOperation_1 = require("./services/synchronizer/utils/handleSyncStartupOperation");
const SyncTargetJoplinCloud_1 = require("./SyncTargetJoplinCloud");
const { toSystemSlashes } = require('./path-utils');
const { setAutoFreeze } = require('immer');
const syncInfoUtils_1 = require("./services/synchronizer/syncInfoUtils");
const utils_1 = require("./services/e2ee/utils");
const SyncTargetNone_1 = require("./SyncTargetNone");
const ppk_1 = require("./services/e2ee/ppk");
const RSA_node_1 = require("./services/e2ee/RSA.node");
const Resource_1 = require("./models/Resource");
const initProfile_1 = require("./services/profileConfig/initProfile");
const appLogger = Logger_1.default.create('App');
class BaseApplication {
    constructor() {
        this.scheduleAutoAddResourcesIID_ = null;
        this.database_ = null;
        this.profileConfig_ = null;
        this.showStackTraces_ = false;
        this.showPromptString_ = false;
        // Note: this is basically a cache of state.selectedFolderId. It should *only*
        // be derived from the state and not set directly since that would make the
        // state and UI out of sync.
        this.currentFolder_ = null;
        this.store_ = null;
        this.eventEmitter_ = new EventEmitter();
        this.decryptionWorker_resourceMetadataButNotBlobDecrypted = this.decryptionWorker_resourceMetadataButNotBlobDecrypted.bind(this);
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.scheduleAutoAddResourcesIID_) {
                shim_1.default.clearTimeout(this.scheduleAutoAddResourcesIID_);
                this.scheduleAutoAddResourcesIID_ = null;
            }
            yield ResourceFetcher_1.default.instance().destroy();
            yield SearchEngine_1.default.instance().destroy();
            yield DecryptionWorker_1.default.instance().destroy();
            yield FoldersScreenUtils.cancelTimers();
            yield BaseItem_1.default.revisionService_.cancelTimers();
            yield ResourceService_1.default.instance().cancelTimers();
            yield registry_1.reg.cancelTimers();
            this.eventEmitter_.removeAllListeners();
            KvStore_1.default.destroyInstance();
            BaseModel_1.default.setDb(null);
            registry_1.reg.setDb(null);
            BaseItem_1.default.revisionService_ = null;
            RevisionService_1.default.instance_ = null;
            ResourceService_1.default.instance_ = null;
            ResourceService_1.default.isRunningInBackground_ = false;
            // ResourceService.isRunningInBackground_ = false;
            ResourceFetcher_1.default.instance_ = null;
            EncryptionService_1.default.instance_ = null;
            DecryptionWorker_1.default.instance_ = null;
            appLogger.info('Base application terminated...');
            this.eventEmitter_ = null;
            this.decryptionWorker_resourceMetadataButNotBlobDecrypted = null;
        });
    }
    logger() {
        return appLogger;
    }
    store() {
        return this.store_;
    }
    currentFolder() {
        return this.currentFolder_;
    }
    refreshCurrentFolder() {
        return __awaiter(this, void 0, void 0, function* () {
            let newFolder = null;
            if (this.currentFolder_)
                newFolder = yield Folder_1.default.load(this.currentFolder_.id);
            if (!newFolder)
                newFolder = yield Folder_1.default.defaultFolder();
            this.switchCurrentFolder(newFolder);
        });
    }
    switchCurrentFolder(folder) {
        if (!this.hasGui()) {
            this.currentFolder_ = Object.assign({}, folder);
            Setting_1.default.setValue('activeFolderId', folder ? folder.id : '');
        }
        else {
            this.dispatch({
                type: 'FOLDER_SELECT',
                id: folder ? folder.id : '',
            });
        }
    }
    // Handles the initial flags passed to main script and
    // returns the remaining args.
    handleStartFlags_(argv, setDefaults = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const matched = {};
            argv = argv.slice(0);
            argv.splice(0, 2); // First arguments are the node executable, and the node JS file
            while (argv.length) {
                const arg = argv[0];
                const nextArg = argv.length >= 2 ? argv[1] : null;
                if (arg === '--profile') {
                    if (!nextArg)
                        throw new JoplinError_1.default((0, locale_1._)('Usage: %s', '--profile <dir-path>'), 'flagError');
                    matched.profileDir = nextArg;
                    argv.splice(0, 2);
                    continue;
                }
                if (arg === '--no-welcome') {
                    matched.welcomeDisabled = true;
                    argv.splice(0, 1);
                    continue;
                }
                if (arg === '--env') {
                    if (!nextArg)
                        throw new JoplinError_1.default((0, locale_1._)('Usage: %s', '--env <dev|prod>'), 'flagError');
                    matched.env = nextArg;
                    argv.splice(0, 2);
                    continue;
                }
                if (arg === '--is-demo') {
                    Setting_1.default.setConstant('isDemo', true);
                    argv.splice(0, 1);
                    continue;
                }
                if (arg === '--open-dev-tools') {
                    Setting_1.default.setConstant('flagOpenDevTools', true);
                    argv.splice(0, 1);
                    continue;
                }
                if (arg === '--debug') {
                    // Currently only handled by ElectronAppWrapper (isDebugMode property)
                    argv.splice(0, 1);
                    continue;
                }
                if (arg === '--update-geolocation-disabled') {
                    Note_1.default.updateGeolocationEnabled_ = false;
                    argv.splice(0, 1);
                    continue;
                }
                if (arg === '--stack-trace-enabled') {
                    this.showStackTraces_ = true;
                    argv.splice(0, 1);
                    continue;
                }
                if (arg === '--log-level') {
                    if (!nextArg)
                        throw new JoplinError_1.default((0, locale_1._)('Usage: %s', '--log-level <none|error|warn|info|debug>'), 'flagError');
                    matched.logLevel = Logger_1.default.levelStringToId(nextArg);
                    argv.splice(0, 2);
                    continue;
                }
                if (arg.indexOf('-psn') === 0) {
                    // Some weird flag passed by macOS - can be ignored.
                    // https://github.com/laurent22/joplin/issues/480
                    // https://stackoverflow.com/questions/10242115
                    argv.splice(0, 1);
                    continue;
                }
                if (arg === '--enable-logging') {
                    // Electron-specific flag used for debugging - ignore it
                    argv.splice(0, 1);
                    continue;
                }
                if (arg === '--dev-plugins') {
                    Setting_1.default.setConstant('startupDevPlugins', nextArg.split(',').map(p => p.trim()));
                    argv.splice(0, 2);
                    continue;
                }
                if (arg.indexOf('--remote-debugging-port=') === 0) {
                    // Electron-specific flag used for debugging - ignore it. Electron expects this flag in '--x=y' form, a single string.
                    argv.splice(0, 1);
                    continue;
                }
                if (arg === '--no-sandbox') {
                    // Electron-specific flag for running the app without chrome-sandbox
                    // Allows users to use it as a workaround for the electron+AppImage issue
                    // https://github.com/laurent22/joplin/issues/2246
                    argv.splice(0, 1);
                    continue;
                }
                if (arg.indexOf('--user-data-dir=') === 0) {
                    // Electron-specific flag. Allows users to run the app with chromedriver.
                    argv.splice(0, 1);
                    continue;
                }
                if (arg.indexOf('--enable-features=') === 0) {
                    // Electron-specific flag - ignore it
                    // Allows users to run the app on native wayland
                    argv.splice(0, 1);
                    continue;
                }
                if (arg.indexOf('--ozone-platform=') === 0) {
                    // Electron-specific flag - ignore it
                    // Allows users to run the app on native wayland
                    argv.splice(0, 1);
                    continue;
                }
                if (arg === '--disable-smooth-scrolling') {
                    // Electron-specific flag - ignore it
                    // Allows users to disable smooth scrolling
                    argv.splice(0, 1);
                    continue;
                }
                if (arg.length && arg[0] === '-') {
                    throw new JoplinError_1.default((0, locale_1._)('Unknown flag: %s', arg), 'flagError');
                }
                else {
                    break;
                }
            }
            if (setDefaults) {
                if (!matched.logLevel)
                    matched.logLevel = Logger_1.default.LEVEL_INFO;
                if (!matched.env)
                    matched.env = 'prod';
                if (!matched.devPlugins)
                    matched.devPlugins = [];
            }
            return {
                matched: matched,
                argv: argv,
            };
        });
    }
    on(eventName, callback) {
        return this.eventEmitter_.on(eventName, callback);
    }
    exit(code = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Setting_1.default.saveAll();
            process.exit(code);
        });
    }
    refreshNotes(state, useSelectedNoteId = false, noteHash = '') {
        return __awaiter(this, void 0, void 0, function* () {
            let parentType = state.notesParentType;
            let parentId = null;
            if (parentType === 'Folder') {
                parentId = state.selectedFolderId;
                parentType = BaseModel_1.default.TYPE_FOLDER;
            }
            else if (parentType === 'Tag') {
                parentId = state.selectedTagId;
                parentType = BaseModel_1.default.TYPE_TAG;
            }
            else if (parentType === 'Search') {
                parentId = state.selectedSearchId;
                parentType = BaseModel_1.default.TYPE_SEARCH;
            }
            else if (parentType === 'SmartFilter') {
                parentId = state.selectedSmartFilterId;
                parentType = BaseModel_1.default.TYPE_SMART_FILTER;
            }
            appLogger.debug('Refreshing notes:', parentType, parentId);
            const options = {
                order: stateUtils.notesOrder(state.settings),
                uncompletedTodosOnTop: Setting_1.default.value('uncompletedTodosOnTop'),
                showCompletedTodos: Setting_1.default.value('showCompletedTodos'),
                caseInsensitive: true,
            };
            const source = JSON.stringify({
                options: options,
                parentId: parentId,
            });
            let notes = [];
            let highlightedWords = [];
            if (parentId) {
                if (parentType === Folder_1.default.modelType()) {
                    notes = yield Note_1.default.previews(parentId, options);
                }
                else if (parentType === Tag_1.default.modelType()) {
                    notes = yield Tag_1.default.notes(parentId, options);
                }
                else if (parentType === BaseModel_1.default.TYPE_SEARCH) {
                    const search = BaseModel_1.default.byId(state.searches, parentId);
                    notes = yield SearchEngineUtils_1.default.notesForQuery(search.query_pattern, true);
                    const parsedQuery = yield SearchEngine_1.default.instance().parseQuery(search.query_pattern);
                    highlightedWords = SearchEngine_1.default.instance().allParsedQueryTerms(parsedQuery);
                }
                else if (parentType === BaseModel_1.default.TYPE_SMART_FILTER) {
                    notes = yield Note_1.default.previews(parentId, options);
                }
            }
            this.store().dispatch({
                type: 'SET_HIGHLIGHTED',
                words: highlightedWords,
            });
            this.store().dispatch({
                type: 'NOTE_UPDATE_ALL',
                notes: notes,
                notesSource: source,
            });
            if (useSelectedNoteId) {
                this.store().dispatch({
                    type: 'NOTE_SELECT',
                    id: state.selectedNoteIds && state.selectedNoteIds.length ? state.selectedNoteIds[0] : null,
                    hash: noteHash,
                });
            }
            else {
                const lastSelectedNoteIds = stateUtils.lastSelectedNoteIds(state);
                const foundIds = [];
                for (let i = 0; i < lastSelectedNoteIds.length; i++) {
                    const noteId = lastSelectedNoteIds[i];
                    let found = false;
                    for (let j = 0; j < notes.length; j++) {
                        if (notes[j].id === noteId) {
                            found = true;
                            break;
                        }
                    }
                    if (found)
                        foundIds.push(noteId);
                }
                let selectedNoteId = null;
                if (foundIds.length) {
                    selectedNoteId = foundIds[0];
                }
                else {
                    selectedNoteId = notes.length ? notes[0].id : null;
                }
                this.store().dispatch({
                    type: 'NOTE_SELECT',
                    id: selectedNoteId,
                });
            }
        });
    }
    resourceFetcher_downloadComplete(event) {
        if (event.encrypted) {
            void DecryptionWorker_1.default.instance().scheduleStart();
        }
    }
    decryptionWorker_resourceMetadataButNotBlobDecrypted() {
        return __awaiter(this, void 0, void 0, function* () {
            ResourceFetcher_1.default.instance().scheduleAutoAddResources();
        });
    }
    reducerActionToString(action) {
        const o = [action.type];
        if ('id' in action)
            o.push(action.id);
        if ('noteId' in action)
            o.push(action.noteId);
        if ('folderId' in action)
            o.push(action.folderId);
        if ('tagId' in action)
            o.push(action.tagId);
        if ('tag' in action)
            o.push(action.tag.id);
        if ('folder' in action)
            o.push(action.folder.id);
        if ('notesSource' in action)
            o.push(JSON.stringify(action.notesSource));
        return o.join(', ');
    }
    hasGui() {
        return false;
    }
    uiType() {
        return this.hasGui() ? 'gui' : 'cli';
    }
    generalMiddlewareFn() {
        const middleware = (store) => (next) => (action) => {
            return this.generalMiddleware(store, next, action);
        };
        return middleware;
    }
    applySettingsSideEffects(action = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const sideEffects = {
                'dateFormat': () => __awaiter(this, void 0, void 0, function* () {
                    time_1.default.setLocale(Setting_1.default.value('locale'));
                    time_1.default.setDateFormat(Setting_1.default.value('dateFormat'));
                    time_1.default.setTimeFormat(Setting_1.default.value('timeFormat'));
                }),
                'net.ignoreTlsErrors': () => __awaiter(this, void 0, void 0, function* () {
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = Setting_1.default.value('net.ignoreTlsErrors') ? '0' : '1';
                }),
                'net.customCertificates': () => __awaiter(this, void 0, void 0, function* () {
                    const caPaths = Setting_1.default.value('net.customCertificates').split(',');
                    for (let i = 0; i < caPaths.length; i++) {
                        const f = caPaths[i].trim();
                        if (!f)
                            continue;
                        syswidecas.addCAs(f);
                    }
                }),
                'net.proxyEnabled': () => __awaiter(this, void 0, void 0, function* () {
                    setupProxySettings({
                        maxConcurrentConnections: Setting_1.default.value('sync.maxConcurrentConnections'),
                        proxyTimeout: Setting_1.default.value('net.proxyTimeout'),
                        proxyEnabled: Setting_1.default.value('net.proxyEnabled'),
                        proxyUrl: Setting_1.default.value('net.proxyUrl'),
                    });
                }),
                // Note: this used to run when "encryption.enabled" was changed, but
                // now we run it anytime any property of the sync target info is
                // changed. This is not optimal but:
                // - The sync target info rarely changes.
                // - All the calls below are cheap or do nothing if there's nothing
                //   to do.
                'syncInfoCache': () => __awaiter(this, void 0, void 0, function* () {
                    if (this.hasGui()) {
                        appLogger.info('"syncInfoCache" was changed - setting up encryption related code');
                        yield (0, utils_1.loadMasterKeysFromSettings)(EncryptionService_1.default.instance());
                        void DecryptionWorker_1.default.instance().scheduleStart();
                        const loadedMasterKeyIds = EncryptionService_1.default.instance().loadedMasterKeyIds();
                        this.dispatch({
                            type: 'MASTERKEY_REMOVE_NOT_LOADED',
                            ids: loadedMasterKeyIds,
                        });
                        // Schedule a sync operation so that items that need to be encrypted
                        // are sent to sync target.
                        void registry_1.reg.scheduleSync();
                    }
                }),
                'sync.interval': () => __awaiter(this, void 0, void 0, function* () {
                    if (this.hasGui())
                        registry_1.reg.setupRecurrentSync();
                }),
            };
            sideEffects['timeFormat'] = sideEffects['dateFormat'];
            sideEffects['locale'] = sideEffects['dateFormat'];
            sideEffects['encryption.passwordCache'] = sideEffects['syncInfoCache'];
            sideEffects['encryption.masterPassword'] = sideEffects['syncInfoCache'];
            sideEffects['sync.maxConcurrentConnections'] = sideEffects['net.proxyEnabled'];
            sideEffects['sync.proxyTimeout'] = sideEffects['net.proxyEnabled'];
            sideEffects['sync.proxyUrl'] = sideEffects['net.proxyEnabled'];
            if (action) {
                const effect = sideEffects[action.key];
                if (effect)
                    yield effect();
            }
            else {
                for (const key in sideEffects) {
                    yield sideEffects[key]();
                }
            }
        });
    }
    generalMiddleware(store, next, action) {
        return __awaiter(this, void 0, void 0, function* () {
            // appLogger.debug('Reducer action', this.reducerActionToString(action));
            const result = next(action);
            let refreshNotes = false;
            let refreshFolders = false;
            // let refreshTags = false;
            let refreshNotesUseSelectedNoteId = false;
            let refreshNotesHash = '';
            yield reduxSharedMiddleware(store, next, action);
            const newState = store.getState();
            if (this.hasGui() && ['NOTE_UPDATE_ONE', 'NOTE_DELETE', 'FOLDER_UPDATE_ONE', 'FOLDER_DELETE'].indexOf(action.type) >= 0) {
                if (!(yield registry_1.reg.syncTarget().syncStarted()))
                    void registry_1.reg.scheduleSync(30 * 1000, { syncSteps: ['update_remote', 'delete_remote'] });
                SearchEngine_1.default.instance().scheduleSyncTables();
            }
            // Don't add FOLDER_UPDATE_ALL as refreshFolders() is calling it too, which
            // would cause the sidebar to refresh all the time.
            if (this.hasGui() && ['FOLDER_UPDATE_ONE'].indexOf(action.type) >= 0) {
                refreshFolders = true;
            }
            if (action.type === 'HISTORY_BACKWARD' || action.type === 'HISTORY_FORWARD') {
                refreshNotes = true;
                refreshNotesUseSelectedNoteId = true;
            }
            if (action.type === 'HISTORY_BACKWARD' || action.type === 'HISTORY_FORWARD' || action.type === 'FOLDER_SELECT' || action.type === 'FOLDER_DELETE' || action.type === 'FOLDER_AND_NOTE_SELECT' || (action.type === 'SEARCH_UPDATE' && newState.notesParentType === 'Folder')) {
                Setting_1.default.setValue('activeFolderId', newState.selectedFolderId);
                this.currentFolder_ = newState.selectedFolderId ? yield Folder_1.default.load(newState.selectedFolderId) : null;
                refreshNotes = true;
                if (action.type === 'FOLDER_AND_NOTE_SELECT') {
                    refreshNotesUseSelectedNoteId = true;
                    refreshNotesHash = action.hash;
                }
            }
            if (this.hasGui() && (action.type === 'NOTE_IS_INSERTING_NOTES' && !action.value)) {
                refreshNotes = true;
            }
            if (this.hasGui() && ((action.type === 'SETTING_UPDATE_ONE' && action.key === 'uncompletedTodosOnTop') || action.type === 'SETTING_UPDATE_ALL')) {
                refreshNotes = true;
            }
            if (this.hasGui() && ((action.type === 'SETTING_UPDATE_ONE' && action.key === 'showCompletedTodos') || action.type === 'SETTING_UPDATE_ALL')) {
                refreshNotes = true;
            }
            if (this.hasGui() && ((action.type === 'SETTING_UPDATE_ONE' && action.key.indexOf('notes.sortOrder') === 0) || action.type === 'SETTING_UPDATE_ALL')) {
                refreshNotes = true;
            }
            if (action.type === 'SMART_FILTER_SELECT') {
                refreshNotes = true;
                refreshNotesUseSelectedNoteId = true;
            }
            // Should refresh the notes when:
            // - A tag is selected, to show the notes for that tag
            // - When a tag is updated so that when searching by tags, the search results are updated
            // https://github.com/laurent22/joplin/issues/3754
            if (['TAG_SELECT', 'TAG_DELETE', 'TAG_UPDATE_ONE', 'NOTE_TAG_REMOVE'].includes(action.type)) {
                refreshNotes = true;
            }
            if (action.type === 'SEARCH_SELECT' || action.type === 'SEARCH_DELETE') {
                refreshNotes = true;
            }
            if (action.type === 'NOTE_TAG_REMOVE') {
                if (newState.notesParentType === 'Tag' && newState.selectedTagId === action.item.id) {
                    if (newState.notes.length === newState.selectedNoteIds.length) {
                        yield this.refreshCurrentFolder();
                        refreshNotesUseSelectedNoteId = true;
                    }
                    refreshNotes = true;
                }
            }
            if (refreshNotes) {
                yield this.refreshNotes(newState, refreshNotesUseSelectedNoteId, refreshNotesHash);
            }
            if (action.type === 'NOTE_UPDATE_ONE') {
                if (!action.changedFields.length ||
                    action.changedFields.includes('parent_id') ||
                    action.changedFields.includes('encryption_applied') ||
                    action.changedFields.includes('is_conflict')) {
                    refreshFolders = true;
                }
            }
            if (action.type === 'NOTE_DELETE') {
                refreshFolders = true;
            }
            if (this.hasGui() && action.type === 'SETTING_UPDATE_ALL') {
                refreshFolders = 'now';
            }
            if (this.hasGui() && action.type === 'SETTING_UPDATE_ONE' && (action.key.indexOf('folders.sortOrder') === 0 ||
                action.key === 'showNoteCounts' ||
                action.key === 'showCompletedTodos')) {
                refreshFolders = 'now';
            }
            if (this.hasGui() && action.type === 'SYNC_GOT_ENCRYPTED_ITEM') {
                void DecryptionWorker_1.default.instance().scheduleStart();
            }
            if (this.hasGui() && action.type === 'SYNC_CREATED_OR_UPDATED_RESOURCE') {
                void ResourceFetcher_1.default.instance().autoAddResources();
            }
            if (action.type === 'SETTING_UPDATE_ONE') {
                yield this.applySettingsSideEffects(action);
            }
            else if (action.type === 'SETTING_UPDATE_ALL') {
                yield this.applySettingsSideEffects();
            }
            if (refreshFolders) {
                if (refreshFolders === 'now') {
                    yield FoldersScreenUtils.refreshFolders();
                }
                else {
                    yield FoldersScreenUtils.scheduleRefreshFolders();
                }
            }
            return result;
        });
    }
    dispatch(action) {
        if (this.store())
            return this.store().dispatch(action);
    }
    reducer(state = defaultState, action) {
        return (0, reducer_1.default)(state, action);
    }
    initRedux() {
        this.store_ = (0, redux_1.createStore)(this.reducer, (0, redux_1.applyMiddleware)(this.generalMiddlewareFn()));
        (0, reducer_1.setStore)(this.store_);
        this.store_.dispatch({
            type: 'PROFILE_CONFIG_SET',
            value: this.profileConfig_,
        });
        BaseModel_1.default.dispatch = this.store().dispatch;
        FoldersScreenUtils.dispatch = this.store().dispatch;
        // reg.dispatch = this.store().dispatch;
        BaseSyncTarget_1.default.dispatch = this.store().dispatch;
        DecryptionWorker_1.default.instance().dispatch = this.store().dispatch;
        ResourceFetcher_1.default.instance().dispatch = this.store().dispatch;
        ShareService_1.default.instance().initialize(this.store(), EncryptionService_1.default.instance());
    }
    deinitRedux() {
        this.store_ = null;
        BaseModel_1.default.dispatch = function () { };
        FoldersScreenUtils.dispatch = function () { };
        // reg.dispatch = function() {};
        BaseSyncTarget_1.default.dispatch = function () { };
        DecryptionWorker_1.default.instance().dispatch = function () { };
        ResourceFetcher_1.default.instance().dispatch = function () { };
    }
    readFlagsFromFile(flagPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fs.existsSync(flagPath))
                return {};
            let flagContent = fs.readFileSync(flagPath, 'utf8');
            if (!flagContent)
                return {};
            flagContent = flagContent.trim();
            let flags = splitCommandString(flagContent);
            flags.splice(0, 0, 'cmd');
            flags.splice(0, 0, 'node');
            flags = yield this.handleStartFlags_(flags, false);
            return flags.matched;
        });
    }
    determineProfileDir(initArgs) {
        let output = '';
        if (initArgs.profileDir) {
            output = initArgs.profileDir;
        }
        else if (process && process.env && process.env.PORTABLE_EXECUTABLE_DIR) {
            output = `${process.env.PORTABLE_EXECUTABLE_DIR}/JoplinProfile`;
        }
        else {
            output = `${os.homedir()}/.config/${Setting_1.default.value('appName')}`;
        }
        return toSystemSlashes(output, 'linux');
    }
    start(argv, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            options = Object.assign({ keychainEnabled: true }, options);
            const startFlags = yield this.handleStartFlags_(argv);
            argv = startFlags.argv;
            let initArgs = startFlags.matched;
            if (argv.length)
                this.showPromptString_ = false;
            let appName = initArgs.env === 'dev' ? 'joplindev' : 'joplin';
            if (Setting_1.default.value('appId').indexOf('-desktop') >= 0)
                appName += '-desktop';
            Setting_1.default.setConstant('appName', appName);
            // https://immerjs.github.io/immer/docs/freezing
            setAutoFreeze(initArgs.env === 'dev');
            const rootProfileDir = this.determineProfileDir(initArgs);
            const { profileDir, profileConfig, isSubProfile } = yield (0, initProfile_1.default)(rootProfileDir);
            this.profileConfig_ = profileConfig;
            const resourceDirName = 'resources';
            const resourceDir = `${profileDir}/${resourceDirName}`;
            const tempDir = `${profileDir}/tmp`;
            const cacheDir = `${profileDir}/cache`;
            Setting_1.default.setConstant('env', initArgs.env);
            Setting_1.default.setConstant('resourceDirName', resourceDirName);
            Setting_1.default.setConstant('resourceDir', resourceDir);
            Setting_1.default.setConstant('tempDir', tempDir);
            Setting_1.default.setConstant('pluginDataDir', `${profileDir}/plugin-data`);
            Setting_1.default.setConstant('cacheDir', cacheDir);
            Setting_1.default.setConstant('pluginDir', `${rootProfileDir}/plugins`);
            SyncTargetRegistry_1.default.addClass(SyncTargetNone_1.default);
            SyncTargetRegistry_1.default.addClass(SyncTargetFilesystem);
            SyncTargetRegistry_1.default.addClass(SyncTargetOneDrive_1.default);
            SyncTargetRegistry_1.default.addClass(SyncTargetNextcloud);
            SyncTargetRegistry_1.default.addClass(SyncTargetWebDAV);
            SyncTargetRegistry_1.default.addClass(SyncTargetDropbox);
            SyncTargetRegistry_1.default.addClass(SyncTargetAmazonS3);
            SyncTargetRegistry_1.default.addClass(SyncTargetJoplinServer_1.default);
            SyncTargetRegistry_1.default.addClass(SyncTargetJoplinCloud_1.default);
            try {
                yield shim_1.default.fsDriver().remove(tempDir);
            }
            catch (error) {
                // Can't do anything in this case, not even log, since the logger
                // is not yet ready. But normally it's not an issue if the temp
                // dir cannot be deleted.
            }
            yield fs.mkdirp(profileDir, 0o755);
            yield fs.mkdirp(resourceDir, 0o755);
            yield fs.mkdirp(tempDir, 0o755);
            yield fs.mkdirp(cacheDir, 0o755);
            // Clean up any remaining watched files (they start with "edit-")
            yield shim_1.default.fsDriver().removeAllThatStartWith(profileDir, 'edit-');
            const extraFlags = yield this.readFlagsFromFile(`${profileDir}/flags.txt`);
            initArgs = Object.assign(initArgs, extraFlags);
            const globalLogger = new Logger_1.default();
            globalLogger.addTarget(Logger_1.TargetType.File, { path: `${profileDir}/log.txt` });
            if (Setting_1.default.value('appType') === 'desktop') {
                globalLogger.addTarget(Logger_1.TargetType.Console);
            }
            globalLogger.setLevel(initArgs.logLevel);
            Logger_1.default.initializeGlobalLogger(globalLogger);
            registry_1.reg.setLogger(Logger_1.default.create(''));
            // reg.dispatch = () => {};
            BaseService_1.default.logger_ = globalLogger;
            appLogger.info(`Profile directory: ${profileDir}`);
            appLogger.info(`Root profile directory: ${rootProfileDir}`);
            this.database_ = new JoplinDatabase_1.default(new DatabaseDriverNode());
            this.database_.setLogExcludedQueryTypes(['SELECT']);
            this.database_.setLogger(globalLogger);
            yield this.database_.open({ name: `${profileDir}/database.sqlite` });
            // if (Setting.value('env') === 'dev') await this.database_.clearForTesting();
            registry_1.reg.setDb(this.database_);
            BaseModel_1.default.setDb(this.database_);
            (0, ppk_1.setRSA)(RSA_node_1.default);
            yield (0, SettingUtils_1.loadKeychainServiceAndSettings)(options.keychainEnabled ? KeychainServiceDriver_node_1.default : KeychainServiceDriver_dummy_1.default);
            yield (0, utils_1.migrateMasterPassword)();
            yield (0, handleSyncStartupOperation_1.default)();
            appLogger.info(`Client ID: ${Setting_1.default.value('clientId')}`);
            if (Setting_1.default.value('firstStart')) {
                // If it's a sub-profile, the locale must come from the root
                // profile.
                if (!Setting_1.default.value('isSubProfile')) {
                    const locale = shim_1.default.detectAndSetLocale(Setting_1.default);
                    registry_1.reg.logger().info(`First start: detected locale as ${locale}`);
                }
                Setting_1.default.skipDefaultMigrations();
                if (Setting_1.default.value('env') === 'dev') {
                    Setting_1.default.setValue('showTrayIcon', 0);
                    Setting_1.default.setValue('autoUpdateEnabled', 0);
                    Setting_1.default.setValue('sync.interval', 3600);
                }
                Setting_1.default.setValue('firstStart', 0);
            }
            else {
                Setting_1.default.applyDefaultMigrations();
                Setting_1.default.applyUserSettingMigration();
            }
            (0, locale_1.setLocale)(Setting_1.default.value('locale'));
            if (Setting_1.default.value('env') === Setting_1.Env.Dev) {
                // Setting.setValue('sync.10.path', 'https://api.joplincloud.com');
                // Setting.setValue('sync.10.userContentPath', 'https://joplinusercontent.com');
                Setting_1.default.setValue('sync.10.path', 'http://api.joplincloud.local:22300');
                Setting_1.default.setValue('sync.10.userContentPath', 'http://joplincloud.local:22300');
            }
            // For now always disable fuzzy search due to performance issues:
            // https://discourse.joplinapp.org/t/1-1-4-keyboard-locks-up-while-typing/11231/11
            // https://discourse.joplinapp.org/t/serious-lagging-when-there-are-tens-of-thousands-of-notes/11215/23
            Setting_1.default.setValue('db.fuzzySearchEnabled', 0);
            if (Setting_1.default.value('encryption.shouldReencrypt') < 0) {
                // We suggest re-encryption if the user has at least one notebook
                // and if encryption is enabled. This code runs only when shouldReencrypt = -1
                // which can be set by a maintenance script for example.
                const folderCount = yield Folder_1.default.count();
                const itShould = (0, syncInfoUtils_1.getEncryptionEnabled)() && !!folderCount ? Setting_1.default.SHOULD_REENCRYPT_YES : Setting_1.default.SHOULD_REENCRYPT_NO;
                Setting_1.default.setValue('encryption.shouldReencrypt', itShould);
            }
            if ('welcomeDisabled' in initArgs)
                Setting_1.default.setValue('welcome.enabled', !initArgs.welcomeDisabled);
            if (isSubProfile)
                Setting_1.default.setValue('welcome.enabled', false);
            if (!Setting_1.default.value('api.token')) {
                void EncryptionService_1.default.instance()
                    .generateApiToken()
                    // eslint-disable-next-line promise/prefer-await-to-then -- Old code before rule was applied
                    .then((token) => {
                    Setting_1.default.setValue('api.token', token);
                });
            }
            time_1.default.setDateFormat(Setting_1.default.value('dateFormat'));
            time_1.default.setTimeFormat(Setting_1.default.value('timeFormat'));
            BaseItem_1.default.revisionService_ = RevisionService_1.default.instance();
            KvStore_1.default.instance().setDb(registry_1.reg.db());
            BaseItem_1.default.encryptionService_ = EncryptionService_1.default.instance();
            BaseItem_1.default.shareService_ = ShareService_1.default.instance();
            Resource_1.default.shareService_ = ShareService_1.default.instance();
            DecryptionWorker_1.default.instance().setLogger(globalLogger);
            DecryptionWorker_1.default.instance().setEncryptionService(EncryptionService_1.default.instance());
            DecryptionWorker_1.default.instance().setKvStore(KvStore_1.default.instance());
            yield (0, utils_1.loadMasterKeysFromSettings)(EncryptionService_1.default.instance());
            DecryptionWorker_1.default.instance().on('resourceMetadataButNotBlobDecrypted', this.decryptionWorker_resourceMetadataButNotBlobDecrypted);
            ResourceFetcher_1.default.instance().setFileApi(() => {
                return registry_1.reg.syncTarget().fileApi();
            });
            ResourceFetcher_1.default.instance().setLogger(globalLogger);
            ResourceFetcher_1.default.instance().on('downloadComplete', this.resourceFetcher_downloadComplete);
            void ResourceFetcher_1.default.instance().start();
            SearchEngine_1.default.instance().setDb(registry_1.reg.db());
            SearchEngine_1.default.instance().setLogger(registry_1.reg.logger());
            SearchEngine_1.default.instance().scheduleSyncTables();
            const currentFolderId = Setting_1.default.value('activeFolderId');
            let currentFolder = null;
            if (currentFolderId)
                currentFolder = yield Folder_1.default.load(currentFolderId);
            if (!currentFolder)
                currentFolder = yield Folder_1.default.defaultFolder();
            Setting_1.default.setValue('activeFolderId', currentFolder ? currentFolder.id : '');
            yield MigrationService_1.default.instance().run();
            return argv;
        });
    }
}
exports.default = BaseApplication;
//# sourceMappingURL=BaseApplication.js.map