"use strict";
// On mobile all the setTimeout and setInterval should go through this class
// as it will either use the native timeout/interval for short intervals or
// the custom one for long intervals.
Object.defineProperty(exports, "__esModule", { value: true });
// For custom intervals, they are triggered
// whenever the update() function is called, and in mobile it's called for
// example on the Redux action middleware or when the app gets focus.
const time_1 = require("./time");
class PoorManIntervals {
    static setInterval(callback, interval) {
        if (interval <= this.maxNativeTimerDuration_)
            return setInterval(callback, interval);
        this.intervalId_++;
        const id = this.intervalId_;
        this.intervals_[id] = {
            id: id,
            callback: callback,
            interval: interval,
            lastIntervalTime: time_1.default.unixMs(),
            isTimeout: false,
        };
        return id;
    }
    static setTimeout(callback, interval) {
        if (interval <= this.maxNativeTimerDuration_)
            return setTimeout(callback, interval);
        this.intervalId_++;
        const id = this.intervalId_;
        this.intervals_[id] = {
            id: id,
            callback: callback,
            interval: interval,
            lastIntervalTime: time_1.default.unixMs(),
            isTimeout: true,
        };
        return id;
    }
    static clearInterval(id) {
        const r = this.intervals_[id];
        if (!r) {
            clearInterval(id);
        }
        else {
            delete this.intervals_[id];
        }
    }
    static clearTimeout(id) {
        const r = this.intervals_[id];
        if (!r) {
            clearTimeout(id);
        }
        else {
            delete this.intervals_[id];
        }
    }
    static update() {
        // Don't update more than once a second
        if (this.lastUpdateTime_ + 1000 > time_1.default.unixMs())
            return;
        for (const id in this.intervals_) {
            const interval = this.intervals_[id];
            const now = time_1.default.unixMs();
            if (now - interval.lastIntervalTime >= interval.interval) {
                interval.lastIntervalTime = now;
                interval.callback();
                if (interval.isTimeout) {
                    this.clearTimeout(interval.id);
                }
            }
        }
        this.lastUpdateTime_ = time_1.default.unixMs();
    }
}
exports.default = PoorManIntervals;
PoorManIntervals.maxNativeTimerDuration_ = 10 * 1000;
PoorManIntervals.lastUpdateTime_ = 0;
PoorManIntervals.intervalId_ = 0;
PoorManIntervals.intervals_ = {};
//# sourceMappingURL=PoorManIntervals.js.map