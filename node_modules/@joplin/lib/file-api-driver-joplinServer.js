"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const JoplinError_1 = require("./JoplinError");
const path_utils_1 = require("./path-utils");
// All input paths should be in the format: "path/to/file". This is converted to
// "root:/path/to/file:" when doing the API call.
class FileApiDriverJoplinServer {
    constructor(api) {
        this.api_ = api;
    }
    initialize(basePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const pieces = (0, path_utils_1.trimSlashes)(basePath).split('/');
            if (!pieces.length)
                return;
            const parent = [];
            for (let i = 0; i < pieces.length; i++) {
                const p = pieces[i];
                const subPath = parent.concat(p).join('/');
                parent.push(p);
                yield this.mkdir(subPath);
            }
        });
    }
    api() {
        return this.api_;
    }
    get supportsMultiPut() {
        return true;
    }
    get supportsAccurateTimestamp() {
        return true;
    }
    get supportsLocks() {
        return true;
    }
    requestRepeatCount() {
        return 3;
    }
    metadataToStat_(md, path, isDeleted = false, rootPath) {
        const output = {
            path: rootPath ? path.substr(rootPath.length + 1) : path,
            updated_time: md.updated_time,
            jop_updated_time: md.jop_updated_time,
            isDir: false,
            isDeleted: isDeleted,
        };
        return output;
    }
    metadataToStats_(mds, rootPath) {
        const output = [];
        for (let i = 0; i < mds.length; i++) {
            output.push(this.metadataToStat_(mds[i], mds[i].name, false, rootPath));
        }
        return output;
    }
    // Transforms a path such as "Apps/Joplin/file.txt" to a complete a complete
    // API URL path: "api/items/root:/Apps/Joplin/file.txt:"
    apiFilePath_(p) {
        return `api/items/root:/${(0, path_utils_1.trimSlashes)(p)}:`;
    }
    stat(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.api().exec('GET', this.apiFilePath_(path));
                return this.metadataToStat_(response, path, false, '');
            }
            catch (error) {
                if (error.code === 404)
                    return null;
                throw error;
            }
        });
    }
    delta(path, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = options ? options.context : null;
            let cursor = context ? context.cursor : null;
            while (true) {
                try {
                    const query = cursor ? { cursor } : {};
                    const response = yield this.api().exec('GET', `${this.apiFilePath_(path)}/delta`, query);
                    const stats = response.items
                        .filter((item) => {
                        // We don't need to know about lock changes, since this
                        // is handled by the LockHandler.
                        if (item.item_name.indexOf('locks/') === 0)
                            return false;
                        // We don't need to sync what's in the temp folder
                        if (item.item_name.indexOf('temp/') === 0)
                            return false;
                        // Although we sync the content of .resource, whether we
                        // fetch or upload data to it is driven by the
                        // associated resource item (.md) file. So at this point
                        // we don't want to automatically fetch from it.
                        if (item.item_name.indexOf('.resource/') === 0)
                            return false;
                        return true;
                    })
                        .map((item) => {
                        return this.metadataToStat_(item, item.item_name, item.type === 3, '');
                    });
                    const output = {
                        items: stats,
                        hasMore: response.has_more,
                        context: { cursor: response.cursor },
                    };
                    return output;
                }
                catch (error) {
                    // If there's an error related to an invalid cursor, clear the cursor and retry.
                    if (cursor && error.code === 'resyncRequired') {
                        cursor = null;
                        continue;
                    }
                    throw error;
                }
            }
        });
    }
    list(path, options = null) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            options = Object.assign({ context: null }, options);
            let isUsingWildcard = false;
            let searchPath = path;
            if (searchPath) {
                searchPath += '/*';
                isUsingWildcard = true;
            }
            const query = ((_a = options.context) === null || _a === void 0 ? void 0 : _a.cursor) ? { cursor: options.context.cursor } : null;
            const results = yield this.api().exec('GET', `${this.apiFilePath_(searchPath)}/children`, query);
            const newContext = {};
            if (results.cursor)
                newContext.cursor = results.cursor;
            return {
                items: this.metadataToStats_(results.items, isUsingWildcard ? path : ''),
                hasMore: results.has_more,
                context: newContext,
            };
        });
    }
    get(path, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options)
                options = {};
            if (!options.responseFormat)
                options.responseFormat = 'text';
            try {
                const response = yield this.api().exec('GET', `${this.apiFilePath_(path)}/content`, null, null, null, options);
                return response;
            }
            catch (error) {
                if (error.code !== 404)
                    throw error;
                return null;
            }
        });
    }
    mkdir(_path) {
        return __awaiter(this, void 0, void 0, function* () {
            // This is a no-op because all items technically are at the root, but
            // they can have names such as ".resources/xxxxxxxxxx'
        });
    }
    put(path, content, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const output = yield this.api().exec('PUT', `${this.apiFilePath_(path)}/content`, options && options.shareId ? { share_id: options.shareId } : null, content, {
                    'Content-Type': 'application/octet-stream',
                }, options);
                return output;
            }
            catch (error) {
                if (error.code === 413) {
                    throw new JoplinError_1.default(error.message, 'rejectedByTarget');
                }
                throw error;
            }
        });
    }
    multiPut(items, options = null) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.api().exec('PUT', 'api/batch_items', null, { items: items }, null, options);
        });
    }
    delete(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.api().exec('DELETE', this.apiFilePath_(path));
        });
    }
    format() {
        throw new Error('Not supported');
    }
    // private lockClientTypeToId(clientType:AppType):number {
    // 	if (clientType === AppType.Desktop) return 1;
    // 	if (clientType === AppType.Mobile) return 2;
    // 	if (clientType === AppType.Cli) return 3;
    // 	throw new Error('Invalid client type: ' + clientType);
    // }
    // private lockTypeToId(lockType:LockType):number {
    // 	if (lockType === LockType.None) return 0; // probably not possible?
    // 	if (lockType === LockType.Sync) return 1;
    // 	if (lockType === LockType.Exclusive) return 2;
    // 	throw new Error('Invalid lock type: ' + lockType);
    // }
    // private lockClientIdTypeToType(clientType:number):AppType {
    // 	if (clientType === 1) return AppType.Desktop;
    // 	if (clientType === 2) return AppType.Mobile;
    // 	if (clientType === 3) return AppType.Cli;
    // 	throw new Error('Invalid client type: ' + clientType);
    // }
    // private lockIdToType(lockType:number):LockType {
    // 	if (lockType === 0) return LockType.None; // probably not possible?
    // 	if (lockType === 1) return LockType.Sync;
    // 	if (lockType === 2) return LockType.Exclusive;
    // 	throw new Error('Invalid lock type: ' + lockType);
    // }
    acquireLock(type, clientType, clientId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.api().exec('POST', 'api/locks', null, {
                type,
                clientType,
                clientId: clientId,
            });
        });
    }
    releaseLock(type, clientType, clientId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.api().exec('DELETE', `api/locks/${type}_${clientType}_${clientId}`);
        });
    }
    listLocks() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.api().exec('GET', 'api/locks');
        });
    }
    clearRoot(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.list(path);
            for (const item of response.items) {
                yield this.delete(item.path);
            }
            yield this.api().exec('POST', 'api/debug', null, { action: 'clearKeyValues' });
            if (response.has_more)
                throw new Error('has_more support not implemented');
        });
    }
}
exports.default = FileApiDriverJoplinServer;
//# sourceMappingURL=file-api-driver-joplinServer.js.map