"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventManager = void 0;
const fastDeepEqual = require('fast-deep-equal');
const events = require('events');
class EventManager {
    constructor() {
        this.reset();
    }
    reset() {
        this.emitter_ = new events.EventEmitter();
        this.appStatePrevious_ = {};
        this.appStateWatchedProps_ = [];
        this.appStateListeners_ = {};
    }
    on(eventName, callback) {
        return this.emitter_.on(eventName, callback);
    }
    emit(eventName, object = null) {
        return this.emitter_.emit(eventName, object);
    }
    removeListener(eventName, callback) {
        return this.emitter_.removeListener(eventName, callback);
    }
    off(eventName, callback) {
        return this.removeListener(eventName, callback);
    }
    filterOn(filterName, callback) {
        return this.emitter_.on(`filter:${filterName}`, callback);
    }
    filterOff(filterName, callback) {
        return this.removeListener(`filter:${filterName}`, callback);
    }
    filterEmit(filterName, object) {
        return __awaiter(this, void 0, void 0, function* () {
            let output = object;
            const listeners = this.emitter_.listeners(`filter:${filterName}`);
            for (const listener of listeners) {
                // When we pass the object to the plugin, it is always going to be
                // modified since it is serialized/unserialized. So we need to use a
                // deep equality check to see if it's been changed. Normally the
                // filter objects should be relatively small so there shouldn't be
                // much of a performance hit.
                const newOutput = yield listener(output);
                // Plugin didn't return anything - so we leave the object as it is.
                if (newOutput === undefined)
                    continue;
                if (!fastDeepEqual(newOutput, output)) {
                    output = newOutput;
                }
            }
            return output;
        });
    }
    appStateOn(propName, callback) {
        if (!this.appStateListeners_[propName]) {
            this.appStateListeners_[propName] = [];
            this.appStateWatchedProps_.push(propName);
        }
        this.appStateListeners_[propName].push(callback);
    }
    appStateOff(propName, callback) {
        if (!this.appStateListeners_[propName]) {
            throw new Error('EventManager: Trying to unregister a state prop watch for a non-watched prop (1)');
        }
        const idx = this.appStateListeners_[propName].indexOf(callback);
        if (idx < 0)
            throw new Error('EventManager: Trying to unregister a state prop watch for a non-watched prop (2)');
        this.appStateListeners_[propName].splice(idx, 1);
    }
    stateValue_(state, propName) {
        const parts = propName.split('.');
        let s = state;
        for (const p of parts) {
            if (!(p in s))
                throw new Error(`Invalid state property path: ${propName}`);
            s = s[p];
        }
        return s;
    }
    // This function works by keeping a copy of the watched props and, whenever this function
    // is called, comparing the previous and new values and emitting events if they have changed.
    // The appStateEmit function should be called from a middleware.
    appStateEmit(state) {
        if (!this.appStateWatchedProps_.length)
            return;
        for (const propName of this.appStateWatchedProps_) {
            let emit = false;
            const stateValue = this.stateValue_(state, propName);
            if (!(propName in this.appStatePrevious_) || this.appStatePrevious_[propName] !== stateValue) {
                this.appStatePrevious_[propName] = stateValue;
                emit = true;
            }
            if (emit) {
                const listeners = this.appStateListeners_[propName];
                if (!listeners || !listeners.length)
                    continue;
                const eventValue = Object.freeze(stateValue);
                for (const listener of listeners) {
                    listener({ value: eventValue });
                }
            }
        }
    }
}
exports.EventManager = EventManager;
const eventManager = new EventManager();
exports.default = eventManager;
//# sourceMappingURL=eventManager.js.map