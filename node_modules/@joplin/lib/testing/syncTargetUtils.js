"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = exports.deploySyncTargetSnapshot = exports.checkTestData = exports.createTestData = exports.testData = void 0;
const test_utils_1 = require("../testing/test-utils");
const Setting_1 = require("../models/Setting");
const Folder_1 = require("../models/Folder");
const Note_1 = require("../models/Note");
const Tag_1 = require("../models/Tag");
const Resource_1 = require("../models/Resource");
const markdownUtils_1 = require("../markdownUtils");
const shim_1 = require("../shim");
const fs = require("fs-extra");
const syncInfoUtils_1 = require("../services/synchronizer/syncInfoUtils");
const { shimInit } = require('../shim-init-node');
const sharp = require('sharp');
const nodeSqlite = require('sqlite3');
const snapshotBaseDir = `${test_utils_1.supportDir}/syncTargetSnapshots`;
exports.testData = {
    folder1: {
        subFolder1: {},
        subFolder2: {
            note1: {
                resource: true,
                tags: ['tag1'],
            },
            note2: {},
        },
        note3: {
            tags: ['tag1', 'tag2'],
        },
        note4: {
            tags: ['tag2'],
        },
    },
    folder2: {},
    folder3: {
        note5: {
            resource: true,
            tags: ['tag2'],
        },
    },
};
function createTestData(data) {
    return __awaiter(this, void 0, void 0, function* () {
        function recurseStruct(s, parentId = '') {
            return __awaiter(this, void 0, void 0, function* () {
                for (const n in s) {
                    if (n.toLowerCase().includes('folder')) {
                        const folder = yield Folder_1.default.save({ title: n, parent_id: parentId });
                        yield recurseStruct(s[n], folder.id);
                    }
                    else {
                        const note = yield Note_1.default.save({ title: n, parent_id: parentId });
                        if (s[n].resource) {
                            yield shim_1.default.attachFileToNote(note, `${test_utils_1.supportDir}/photo.jpg`);
                        }
                        if (s[n].tags) {
                            for (const tagTitle of s[n].tags) {
                                yield Tag_1.default.addNoteTagByTitle(note.id, tagTitle);
                            }
                        }
                    }
                }
            });
        }
        yield recurseStruct(data);
    });
}
exports.createTestData = createTestData;
function checkTestData(data) {
    return __awaiter(this, void 0, void 0, function* () {
        function recurseCheck(s) {
            return __awaiter(this, void 0, void 0, function* () {
                for (const n in s) {
                    const obj = s[n];
                    if (n.toLowerCase().includes('folder')) {
                        const folder = yield Folder_1.default.loadByTitle(n);
                        if (!folder)
                            throw new Error(`Cannot load folder: ${n}`);
                        yield recurseCheck(obj);
                    }
                    else {
                        const note = yield Note_1.default.loadByTitle(n);
                        if (!note)
                            throw new Error(`Cannot load note: ${n}`);
                        const parent = yield Folder_1.default.load(note.parent_id);
                        if (!parent)
                            throw new Error(`Cannot load note parent: ${n}`);
                        if (obj.resource) {
                            const urls = markdownUtils_1.default.extractImageUrls(note.body);
                            const resourceId = urls[0].substr(2);
                            const resource = yield Resource_1.default.load(resourceId);
                            if (!resource)
                                throw new Error(`Cannot load note resource: ${n}`);
                        }
                        if (obj.tags) {
                            for (const tagTitle of obj.tags) {
                                const tag = yield Tag_1.default.loadByTitle(tagTitle);
                                if (!tag)
                                    throw new Error(`Cannot load note tag: ${tagTitle}`);
                                const hasNote = yield Tag_1.default.hasNote(tag.id, note.id);
                                if (!hasNote)
                                    throw new Error(`Tag not associated with note: ${tagTitle}`);
                            }
                        }
                    }
                }
            });
        }
        yield recurseCheck(data);
    });
}
exports.checkTestData = checkTestData;
function deploySyncTargetSnapshot(syncTargetType, syncVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        const sourceDir = `${snapshotBaseDir}/${syncVersion}/${syncTargetType}`;
        yield fs.remove(test_utils_1.syncDir);
        yield fs.copy(sourceDir, test_utils_1.syncDir);
    });
}
exports.deploySyncTargetSnapshot = deploySyncTargetSnapshot;
function main(syncTargetType) {
    return __awaiter(this, void 0, void 0, function* () {
        shimInit({ sharp, nodeSqlite });
        const validSyncTargetTypes = ['normal', 'e2ee'];
        if (!validSyncTargetTypes.includes(syncTargetType))
            throw new Error(`Sync target type must be: ${validSyncTargetTypes.join(', ')}`);
        yield (0, test_utils_1.setupDatabaseAndSynchronizer)(1);
        yield (0, test_utils_1.switchClient)(1);
        yield createTestData(exports.testData);
        if (syncTargetType === 'e2ee') {
            (0, syncInfoUtils_1.setEncryptionEnabled)(true);
            yield (0, test_utils_1.loadEncryptionMasterKey)();
        }
        yield (0, test_utils_1.synchronizerStart)();
        yield (0, test_utils_1.synchronizer)().start();
        if (!Setting_1.default.value('syncVersion'))
            throw new Error('syncVersion is not set');
        const destDir = `${snapshotBaseDir}/${Setting_1.default.value('syncVersion')}/${syncTargetType}`;
        yield fs.mkdirp(destDir); // Create intermediate directories
        yield fs.remove(destDir);
        yield fs.mkdirp(destDir);
        yield fs.copy(test_utils_1.syncDir, destDir);
        console.info(`Sync target snapshot created in: ${destDir}`);
    });
}
exports.main = main;
//# sourceMappingURL=syncTargetUtils.js.map