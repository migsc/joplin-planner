"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const shim_1 = require("./shim");
const time_1 = require("./time");
const Logger_1 = require("./Logger");
const locale_1 = require("./locale");
const { stringify } = require('query-string');
const urlUtils = require('./urlUtils.js');
const Buffer = require('buffer').Buffer;
const logger = Logger_1.default.create('OneDriveApi');
class OneDriveApi {
    // `isPublic` is to tell OneDrive whether the application is a "public" one (Mobile and desktop
    // apps are considered "public"), in which case the secret should not be sent to the API.
    // In practice the React Native app is public, and the Node one is not because we
    // use a local server for the OAuth dance.
    constructor(clientId, clientSecret, isPublic) {
        this.auth_ = null;
        this.accountProperties_ = null;
        this.clientId_ = clientId;
        this.clientSecret_ = clientSecret;
        this.auth_ = null;
        this.accountProperties_ = null;
        this.isPublic_ = isPublic;
        this.listeners_ = {
            authRefreshed: [],
        };
    }
    isPublic() {
        return this.isPublic_;
    }
    dispatch(eventName, param) {
        const ls = this.listeners_[eventName];
        for (let i = 0; i < ls.length; i++) {
            ls[i](param);
        }
    }
    on(eventName, callback) {
        this.listeners_[eventName].push(callback);
    }
    tokenBaseUrl() {
        return 'https://login.microsoftonline.com/common/oauth2/v2.0/token';
    }
    nativeClientRedirectUrl() {
        return 'https://login.microsoftonline.com/common/oauth2/nativeclient';
    }
    auth() {
        return this.auth_;
    }
    setAuth(auth) {
        this.auth_ = auth;
        this.dispatch('authRefreshed', this.auth());
    }
    token() {
        return this.auth_ ? this.auth_.access_token : null;
    }
    clientId() {
        return this.clientId_;
    }
    clientSecret() {
        return this.clientSecret_;
    }
    appDirectory() {
        return __awaiter(this, void 0, void 0, function* () {
            const driveId = this.accountProperties_.driveId;
            const r = yield this.execJson('GET', `/me/drives/${driveId}/special/approot`);
            return `${r.parentReference.path}/${r.name}`;
        });
    }
    authCodeUrl(redirectUri) {
        const query = {
            client_id: this.clientId_,
            scope: 'files.readwrite offline_access sites.readwrite.all',
            response_type: 'code',
            redirect_uri: redirectUri,
            prompt: 'login',
        };
        return `https://login.microsoftonline.com/common/oauth2/v2.0/authorize?${stringify(query)}`;
    }
    execTokenRequest(code, redirectUri) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {};
            body['client_id'] = this.clientId();
            if (!this.isPublic())
                body['client_secret'] = this.clientSecret();
            body['code'] = code;
            body['redirect_uri'] = redirectUri;
            body['grant_type'] = 'authorization_code';
            const r = yield shim_1.default.fetch(this.tokenBaseUrl(), {
                method: 'POST',
                body: urlUtils.objectToQueryString(body),
                headers: {
                    ['Content-Type']: 'application/x-www-form-urlencoded',
                },
            });
            if (!r.ok) {
                const text = yield r.text();
                throw new Error(`Could not retrieve auth code: ${r.status}: ${r.statusText}: ${text}`);
            }
            try {
                const json = yield r.json();
                this.setAuth(json);
            }
            catch (error) {
                this.setAuth(null);
                const text = yield r.text();
                error.message += `: ${text}`;
                throw error;
            }
        });
    }
    oneDriveErrorResponseToError(errorResponse) {
        if (!errorResponse)
            return new Error('Undefined error');
        if (errorResponse.error) {
            const e = errorResponse.error;
            const output = new Error(e.message);
            if (e.code)
                output.code = e.code;
            if (e.innerError)
                output.innerError = e.innerError;
            return output;
        }
        else {
            return new Error(JSON.stringify(errorResponse));
        }
    }
    uploadChunk(url, handle, buffer, options) {
        return __awaiter(this, void 0, void 0, function* () {
            options = Object.assign({}, options);
            if (!options.method) {
                options.method = 'POST';
            }
            if (!options.contentLength)
                throw new Error('uploadChunk: contentLength is missing');
            if (!options.headers)
                throw new Error('uploadChunk: header is missing');
            if (buffer) {
                options.body = buffer.slice(options.startByte, options.startByte + options.contentLength);
            }
            else {
                const chunk = yield shim_1.default.fsDriver().readFileChunk(handle, options.contentLength);
                const buffer = Buffer.from(chunk, 'base64');
                options.body = buffer;
            }
            delete options.contentLength;
            delete options.startByte;
            const response = yield shim_1.default.fetch(url, options);
            return response;
        });
    }
    uploadBigFile(url, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield shim_1.default.fetch(url, {
                method: 'POST',
                headers: {
                    'Authorization': options.headers.Authorization,
                    'Content-Type': 'application/json',
                },
            });
            if (!response.ok) {
                return response;
            }
            else {
                const uploadUrl = (yield response.json()).uploadUrl;
                const chunkSize = 7.5 * 1024 * 1024;
                let byteSize = null;
                let handle = null;
                let buffer = null;
                if (options.body) {
                    byteSize = Buffer.byteLength(options.body);
                    buffer = Buffer.from(options.body);
                }
                else {
                    byteSize = (yield shim_1.default.fsDriver().stat(options.path)).size;
                    handle = yield shim_1.default.fsDriver().open(options.path, 'r');
                }
                const numberOfChunks = Math.ceil(byteSize / chunkSize);
                try {
                    for (let i = 0; i < numberOfChunks; i++) {
                        const startByte = i * chunkSize;
                        let endByte = null;
                        let contentLength = null;
                        if (i === numberOfChunks - 1) {
                            // Last fragment. It is not ensured that the last fragment is a multiple of 327,680 bytes as recommanded in the api doc. The reasons is that the docs are out of day for this purpose: https://github.com/OneDrive/onedrive-api-docs/issues/1200#issuecomment-597281253
                            endByte = byteSize - 1;
                            contentLength = byteSize - ((numberOfChunks - 1) * chunkSize);
                        }
                        else {
                            endByte = (i + 1) * chunkSize - 1;
                            contentLength = chunkSize;
                        }
                        logger.debug(`Uploading File Fragment ${(startByte / 1048576).toFixed(2)} - ${(endByte / 1048576).toFixed(2)} from ${(byteSize / 1048576).toFixed(2)} Mbit ...`);
                        const headers = {
                            'Content-Length': contentLength,
                            'Content-Range': `bytes ${startByte}-${endByte}/${byteSize}`,
                            'Content-Type': 'application/octet-stream; charset=utf-8',
                        };
                        const response = yield this.uploadChunk(uploadUrl, handle, buffer, { startByte: startByte, contentLength: contentLength, method: 'PUT', headers: headers });
                        if (!response.ok) {
                            return response;
                        }
                    }
                    return { ok: true };
                }
                catch (error) {
                    const type = (handle) ? 'Resource' : 'Note Content';
                    logger.error(`Couldn't upload ${type} > 4 Mb. Got unhandled error:`, error ? error.code : '', error ? error.message : '', error);
                    throw error;
                }
                finally {
                    if (handle)
                        yield shim_1.default.fsDriver().close(handle);
                }
            }
        });
    }
    exec(method, path, query = null, data = null, options = null) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!path)
                throw new Error('Path is required');
            method = method.toUpperCase();
            if (!options)
                options = {};
            if (!options.headers)
                options.headers = {};
            if (!options.target)
                options.target = 'string';
            if (method !== 'GET') {
                options.method = method;
            }
            if (method === 'PATCH' || method === 'POST') {
                options.headers['Content-Type'] = 'application/json';
                if (data)
                    data = JSON.stringify(data);
            }
            let url = path;
            // In general, `path` contains a path relative to the base URL, but in some
            // cases the full URL is provided (for example, when it's a URL that was
            // retrieved from the API).
            if (url.indexOf('https://') !== 0) {
                const slash = path.indexOf('/') === 0 ? '' : '/';
                url = `https://graph.microsoft.com/v1.0${slash}${path}`;
            }
            if (query) {
                url += url.indexOf('?') < 0 ? '?' : '&';
                url += stringify(query);
            }
            if (data)
                options.body = data;
            options.timeout = 1000 * 60 * 5; // in ms
            for (let i = 0; i < 5; i++) {
                options.headers['Authorization'] = `bearer ${this.token()}`;
                options.headers['User-Agent'] = `ISV|Joplin|Joplin/${shim_1.default.appVersion()}`;
                const handleRequestRepeat = (error, sleepSeconds = null) => __awaiter(this, void 0, void 0, function* () {
                    sleepSeconds !== null && sleepSeconds !== void 0 ? sleepSeconds : (sleepSeconds = (i + 1) * 5);
                    logger.info(`Got error below - retrying (${i})...`);
                    logger.info(error);
                    yield time_1.default.sleep(sleepSeconds);
                });
                let response = null;
                try {
                    if (path.includes('/createUploadSession')) {
                        response = yield this.uploadBigFile(url, options);
                    }
                    else if (options.source === 'file' && (method === 'POST' || method === 'PUT')) {
                        response = yield shim_1.default.uploadBlob(url, options);
                    }
                    else if (options.target === 'string') {
                        response = yield shim_1.default.fetch(url, options);
                    }
                    else {
                        // file
                        response = yield shim_1.default.fetchBlob(url, options);
                    }
                }
                catch (error) {
                    if (shim_1.default.fetchRequestCanBeRetried(error)) {
                        yield handleRequestRepeat(error);
                        continue;
                    }
                    else {
                        logger.error('Got unhandled error:', error ? error.code : '', error ? error.message : '', error);
                        throw error;
                    }
                }
                if (!response.ok) {
                    const errorResponseText = yield response.text();
                    let errorResponse = null;
                    try {
                        errorResponse = JSON.parse(errorResponseText); // await response.json();
                    }
                    catch (error) {
                        error.message = `OneDriveApi::exec: Cannot parse JSON error: ${errorResponseText} ${error.message}`;
                        yield handleRequestRepeat(error);
                        continue;
                    }
                    const error = this.oneDriveErrorResponseToError(errorResponse);
                    if (error.code === 'InvalidAuthenticationToken' || error.code === 'unauthenticated') {
                        logger.info('Token expired: refreshing...');
                        yield this.refreshAccessToken();
                        continue;
                    }
                    else if (error && ((error.error && error.error.code === 'generalException') || error.code === 'generalException' || error.code === 'EAGAIN')) {
                        // Rare error (one Google hit) - I guess the request can be repeated
                        // { error:
                        //    { code: 'generalException',
                        //      message: 'An error occurred in the data store.',
                        //      innerError:
                        //       { 'request-id': 'b4310552-c18a-45b1-bde1-68e2c2345eef',
                        //         date: '2017-06-29T00:15:50' } } }
                        // { FetchError: request to https://graph.microsoft.com/v1.0/drive/root:/Apps/Joplin/.sync/7ee5dc04afcb414aa7c684bfc1edba8b.md_1499352102856 failed, reason: connect EAGAIN 65.52.64.250:443 - Local (0.0.0.0:54374)
                        //   name: 'FetchError',
                        //   message: 'request to https://graph.microsoft.com/v1.0/drive/root:/Apps/Joplin/.sync/7ee5dc04afcb414aa7c684bfc1edba8b.md_1499352102856 failed, reason: connect EAGAIN 65.52.64.250:443 - Local (0.0.0.0:54374)',
                        //   type: 'system',
                        //   errno: 'EAGAIN',
                        //   code: 'EAGAIN' }
                        yield handleRequestRepeat(error);
                        continue;
                    }
                    else if (error && (error.code === 'resourceModified' || (error.error && error.error.code === 'resourceModified'))) {
                        // NOTE: not tested, very hard to reproduce and non-informative error message, but can be repeated
                        // Error: ETag does not match current item's value
                        // Code: resourceModified
                        // Header: {"_headers":{"cache-control":["private"],"transfer-encoding":["chunked"],"content-type":["application/json"],"request-id":["d...ea47"],"client-request-id":["d99...ea47"],"x-ms-ags-diagnostic":["{\"ServerInfo\":{\"DataCenter\":\"North Europe\",\"Slice\":\"SliceA\",\"Ring\":\"2\",\"ScaleUnit\":\"000\",\"Host\":\"AGSFE_IN_13\",\"ADSiteName\":\"DUB\"}}"],"duration":["96.9464"],"date":[],"connection":["close"]}}
                        // Request: PATCH https://graph.microsoft.com/v1.0/drive/root:/Apps/JoplinDev/f56c5601fee94b8085524513bf3e352f.md null "{\"fileSystemInfo\":{\"lastModifiedDateTime\":\"....\"}}" {"headers":{"Content-Type":"application/json","Authorization":"bearer ...
                        yield handleRequestRepeat(error);
                        continue;
                    }
                    else if ((error === null || error === void 0 ? void 0 : error.code) === 'activityLimitReached' && ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a._headers['retry-after'][0]) && !isNaN(Number((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b._headers['retry-after'][0]))) {
                        // Wait for OneDrive throttling
                        // Relavent Microsoft Docs: https://docs.microsoft.com/en-us/sharepoint/dev/general-development/how-to-avoid-getting-throttled-or-blocked-in-sharepoint-online#best-practices-to-handle-throttling
                        // Decrement retry count as multiple sync threads will cause repeated throttling errors - this will wait until throttling is resolved to continue, preventing a hard stop on the sync
                        i--;
                        const sleepSeconds = response.headers._headers['retry-after'][0];
                        logger.info(`OneDrive Throttle, sync thread sleeping for ${sleepSeconds} seconds...`);
                        yield handleRequestRepeat(error, Number(sleepSeconds));
                        continue;
                    }
                    else if (error.code === 'itemNotFound' && method === 'DELETE') {
                        // Deleting a non-existing item is ok - noop
                        return;
                    }
                    else {
                        error.request = `${method} ${url} ${JSON.stringify(query)} ${JSON.stringify(data)} ${JSON.stringify(options)}`;
                        error.headers = yield response.headers;
                        throw error;
                    }
                }
                return response;
            }
            throw new Error(`Could not execute request after multiple attempts: ${method} ${url}`);
        });
    }
    setAccountProperties(accountProperties) {
        this.accountProperties_ = accountProperties;
    }
    execAccountPropertiesRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.exec('GET', 'https://graph.microsoft.com/v1.0/me/drive');
                const data = yield response.json();
                const accountProperties = { accountType: data.driveType, driveId: data.id };
                return accountProperties;
            }
            catch (error) {
                throw new Error(`Could not retrieve account details (drive ID, Account type. Error code: ${error.code}, Error message: ${error.message}`);
            }
        });
    }
    execJson(method, path, query = null, data = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.exec(method, path, query, data);
            const errorResponseText = yield response.text();
            try {
                const output = JSON.parse(errorResponseText); // await response.json();
                return output;
            }
            catch (error) {
                error.message = `OneDriveApi::execJson: Cannot parse JSON: ${errorResponseText} ${error.message}`;
                throw error;
                // throw new Error('Cannot parse JSON: ' + text);
            }
        });
    }
    execText(method, path, query = null, data = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.exec(method, path, query, data);
            const output = yield response.text();
            return output;
        });
    }
    refreshAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.auth_ || !this.auth_.refresh_token) {
                this.setAuth(null);
                throw new Error((0, locale_1._)('Cannot refresh token: authentication data is missing. Starting the synchronisation again may fix the problem.'));
            }
            const body = {};
            body['client_id'] = this.clientId();
            if (!this.isPublic())
                body['client_secret'] = this.clientSecret();
            body['refresh_token'] = this.auth_.refresh_token;
            body['redirect_uri'] = 'http://localhost:1917';
            body['grant_type'] = 'refresh_token';
            const response = yield shim_1.default.fetch(this.tokenBaseUrl(), {
                method: 'POST',
                body: urlUtils.objectToQueryString(body),
                headers: {
                    ['Content-Type']: 'application/x-www-form-urlencoded',
                },
            });
            if (!response.ok) {
                this.setAuth(null);
                const msg = yield response.text();
                throw new Error(`${msg}: TOKEN: ${this.auth_}`);
            }
            const auth = yield response.json();
            this.setAuth(auth);
        });
    }
}
exports.default = OneDriveApi;
//# sourceMappingURL=onedrive-api.js.map