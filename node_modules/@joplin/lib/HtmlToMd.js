"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TurndownService = require('@joplin/turndown');
const turndownPluginGfm = require('@joplin/turndown-plugin-gfm').gfm;
const markdownUtils_1 = require("./markdownUtils");
const pdfUrlRegex = /[\s\S]*?\.pdf$/i;
class HtmlToMd {
    parse(html, options = {}) {
        const turndownOpts = {
            headingStyle: 'atx',
            anchorNames: options.anchorNames ? options.anchorNames.map(n => n.trim().toLowerCase()) : [],
            codeBlockStyle: 'fenced',
            preserveImageTagsWithSize: !!options.preserveImageTagsWithSize,
            bulletListMarker: '-',
            emDelimiter: '*',
            strongDelimiter: '**',
            br: '',
            disableEscapeContent: 'disableEscapeContent' in options ? options.disableEscapeContent : false,
        };
        if (options.convertEmbeddedPdfsToLinks) {
            // Turndown ignores empty <object> tags, so we need to handle this case seperately
            // https://github.com/mixmark-io/turndown/issues/293#issuecomment-588984202
            turndownOpts.blankReplacement = (content, node) => {
                if (node.matches('object')) {
                    return pdfRule.replacement(content, node, {});
                }
                return '\n\n';
            };
        }
        const turndown = new TurndownService(turndownOpts);
        turndown.use(turndownPluginGfm);
        turndown.remove('script');
        turndown.remove('style');
        const pdfRule = {
            filter: ['embed', 'object'],
            replacement: function (_content, node, _options) {
                // We are setting embedded_pdf as name so that we can later distingish them from normal links and create resources for them.
                if (node.matches('embed') && node.getAttribute('src') && pdfUrlRegex.test(node.getAttribute('src'))) {
                    return `[embedded_pdf](${node.getAttribute('src')})`;
                }
                else if (node.matches('object') && node.getAttribute('data') && pdfUrlRegex.test(node.getAttribute('data'))) {
                    return `[embedded_pdf](${node.getAttribute('data')})`;
                }
                return '';
            },
        };
        if (options.convertEmbeddedPdfsToLinks) {
            turndown.addRule('pdf', pdfRule);
        }
        let md = turndown.turndown(html);
        if (options.baseUrl)
            md = markdownUtils_1.default.prependBaseUrl(md, options.baseUrl);
        return md;
    }
}
exports.default = HtmlToMd;
//# sourceMappingURL=HtmlToMd.js.map